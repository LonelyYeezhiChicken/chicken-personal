[{"title":"第一代 RPG Game","type":0,"sectionRef":"#","url":"/en/blog/RPG-v1-Game-post","content":"","keywords":"","version":null},{"title":"關於 Phaser 3​","type":1,"pageTitle":"第一代 RPG Game","url":"/en/blog/RPG-v1-Game-post#關於-phaser-3","content":"什麼是 Phaser js 呢? 他是一個 Game Framework 為什麼要選擇它呢? 首先因為他的文件非常完整，而且一直持續在更新接下來最重要的是他還支持 TypeScript因為都屬於靜態資源，因此可以使用 Github page 建立屬於你的小遊戲 ","version":null,"tagName":"h2"},{"title":"RPG Game​","type":1,"pageTitle":"第一代 RPG Game","url":"/en/blog/RPG-v1-Game-post#rpg-game","content":"選角畫面 戰士 坦克 法師 ","version":null,"tagName":"h2"},{"title":"遊戲連結​","type":1,"pageTitle":"第一代 RPG Game","url":"/en/blog/RPG-v1-Game-post#遊戲連結","content":"","version":null,"tagName":"h2"},{"title":"vue-ts 模板","type":0,"sectionRef":"#","url":"/en/blog/vue-ts-template-post","content":"","keywords":"","version":null},{"title":"關於模板​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#關於模板","content":"方便每次開新專案時，不須重裝套件 ","version":null,"tagName":"h2"},{"title":"使用方式​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#使用方式","content":"","version":null,"tagName":"h2"},{"title":"1. 下載模板​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#1-下載模板","content":"","version":null,"tagName":"h3"},{"title":"2. 於 package.json 修改專案名稱​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#2-於-packagejson-修改專案名稱","content":"{ &quot;name&quot;: &quot;vue-ts-template&quot;, &quot;private&quot;: true, &quot;version&quot;: &quot;0.0.0&quot;, &quot;type&quot;: &quot;module&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vue-tsc &amp;&amp; vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot; }, &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^1.1.3&quot;, &quot;jssha&quot;: &quot;^3.3.0&quot;, &quot;pinia&quot;: &quot;^2.0.23&quot;, &quot;tailwindcss&quot;: &quot;^3.2.1&quot;, &quot;vue&quot;: &quot;^3.2.41&quot;, &quot;vue-router&quot;: &quot;^4.1.6&quot; }, &quot;devDependencies&quot;: { &quot;@vitejs/plugin-vue&quot;: &quot;^3.2.0&quot;, &quot;typescript&quot;: &quot;^4.6.4&quot;, &quot;vite&quot;: &quot;^3.2.0&quot;, &quot;vue-tsc&quot;: &quot;^1.0.9&quot; } }  ","version":null,"tagName":"h3"},{"title":"完整版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#完整版","content":"vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6axios 1.1.3jssha 3.3.0pinia 2.0.23tailwindcss 3.2.1 ","version":null,"tagName":"h2"},{"title":"標準版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#標準版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6axios 1.1.3jssha 3.3.0pinia 2.0.23 ","version":null,"tagName":"h2"},{"title":"Api版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#api版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6axios 1.1.3jssha 3.3.0 ","version":null,"tagName":"h2"},{"title":"Router版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#router版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6 ","version":null,"tagName":"h2"},{"title":"簡約版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#簡約版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4 ","version":null,"tagName":"h2"},{"title":"🧣 ActiveMQ 持久化和非持久化","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/fundamentals/durable","content":"","keywords":"","version":"Next"},{"title":"持久化訊息​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#持久化訊息","content":"持久化訊息在 ActiveMQ 中的實現涉及到訊息中間件的存儲機制一旦發送一條持久化訊息，它會被永久保存在訊息中間件的存儲系統中，通常是一種可靠且高效的存儲介質，例如資料庫這樣的設計確保了即使在訊息發送後，如果消費者暫時無法接收訊息，訊息仍然安全地存儲在系統中，不會丟失這對於需要保證訊息不會丟失且能夠被後續消費者處理的場景非常重要 ","version":"Next","tagName":"h2"},{"title":"持久化訊息在 ActiveMQ 中的實現​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#持久化訊息在-activemq-中的實現","content":"在訊息驅動的應用程式中，訊息的可靠性是至關重要的確保即使在系統故障或消費者暫時無法接收訊息的情況下，訊息仍然安全地存儲在系統中不會丟失 ","version":"Next","tagName":"h3"},{"title":"什麼是持久化訊息？​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#什麼是持久化訊息","content":"持久化訊息是指一旦發送到訊息中間件，該訊息將被永久保存在中間件的存儲系統中這種存儲機制通常使用可靠且高效的介質，比如資料庫這樣的設計確保了訊息的持久性，即使在發送後，消費者暫時無法接收訊息，訊息仍然存在等待被處理 ","version":"Next","tagName":"h3"},{"title":"ActiveMQ 中的持久化訊息機制​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#activemq-中的持久化訊息機制","content":"ActiveMQ 使用多種方式實現持久化訊息，其中之一是通過資料庫當訊息被標記為持久化時，ActiveMQ 將該訊息存儲在設定的資料庫中這使得即使訊息代理重啟，訊息仍然可用，並且能夠在需要時被重新發送給消費者 ","version":"Next","tagName":"h3"},{"title":"應用場景：訂單處理系統​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#應用場景訂單處理系統","content":"讓我們以一個訂單處理系統為例，來理解持久化訊息的實際應用 在這樣的系統中，當用戶建立一個新訂單時，一條訂單建立的訊息被發送到訊息中間件，同時被標記為持久化這意味著即使在訂單系統發生故障或暫時性的消費者不可用的情況下，訂單訊息仍然安全地存儲在資料庫中當系統恢復正常時，訊息中間件將再次嘗試將訊息發送給消費者，確保訂單被正確處理 ","version":"Next","tagName":"h3"},{"title":"Kahadb 持久化機制​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#kahadb-持久化機制","content":"在 ActiveMQ 中，KahaDB 是一個儲存引擎，用於實現訊息的持久化，它提供了高效且可靠的本地存儲解決方案，適用於需要快速訪問訊息的應用場景 以下是有關 Kahadb 持久化機制的補充訊息： 儲存格式： Kahadb 使用一種高效的二進制格式來儲存訊息，這有助於提高讀寫性能 事務支持： Kahadb 提供了事務支持，確保訊息的原子性這意味著當多個訊息需要被一併處理時，它們要麼全部成功，要麼全部失敗，從而確保訊息的一致性 索引結構： Kahadb 使用 B-tree 索引結構，這使得在大型數據集上進行高效的查詢和檢索成為可能 ","version":"Next","tagName":"h2"},{"title":"Kahadb 持久化流程​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#kahadb-持久化流程","content":"訊息寫入： 當一條訊息需要被持久化時，Kahadb 將該訊息追加到日誌文件（Log File）中 索引更新： 同時，Kahadb 更新 B-tree 索引，以便能夠快速地查找和檢索訊息 定期檔案合併： 為了提高效能，Kahadb 執行定期的檔案合併操作，將多個日誌文件合併為一個更大的文件這有助於減少文件數量，提高查詢效率 快照： Kahadb 還支持快照，這是一種在運行時創建索引的方法，有助於加速啟動時間 Kahadb 持久化流程及 B-tree 索引結構 檔案合併流程 ","version":"Next","tagName":"h3"},{"title":"Kahadb 的優勢​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#kahadb-的優勢","content":"高性能： Kahadb 的二進制格式和 B-tree 索引結構確保了高性能的訊息持久化和檢索 可靠性： 事務支持確保了訊息的原子性，從而確保了訊息的可靠性和一致性 有效的檔案管理： 定期的檔案合併操作有助於維護文件數量，提高整體效能 ","version":"Next","tagName":"h3"},{"title":"Kahadb 的設定​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#kahadb-的設定","content":"在 ActiveMQ 的設定文件中，可以通過設定屬性來調整 Kahadb 的行為，例如調整檔案合併的頻率、設置快照等，這些設定選項使得 Kahadb 可以根據特定應用場景進行調優，以達到最佳性能 ","version":"Next","tagName":"h3"},{"title":"非持久化訊息​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#非持久化訊息","content":"非持久化訊息是一種訊息處理方式，其特點在於更加注重實時性和即時性，相較於持久化訊息更著重於即時通知和瞬時事件的傳遞，在這種設計下訊息僅在成功發送到所有活動的消費者後保留在記憶體中，並在確保所有消費者都已接收訊息後被立即刪除 ","version":"Next","tagName":"h2"},{"title":"非持久化訊息的特點​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#非持久化訊息的特點","content":"即時性： 這類訊息不需要長時間保存，而是專注於即時地傳遞給所有需要的消費者 記憶體存儲： 與持久化訊息使用可靠且高效的存儲介質（如資料庫）不同，非持久化訊息通常僅在記憶體中暫存，以確保快速的傳遞和即時的反應 資源效率： 由於不需要將訊息永久保存，非持久化訊息的設計更輕量，能夠節省系統資源，確保系統高效運作 ","version":"Next","tagName":"h3"},{"title":"應用場景：即時股票價格更新​","type":1,"pageTitle":"🧣 ActiveMQ 持久化和非持久化","url":"/en/docs/activeMQ/fundamentals/durable#應用場景即時股票價格更新","content":"一個典型的應用場景是即時股票價格更新 當股票價格發生變動時，即時性變得至關重要非持久化訊息確保價格變動的訊息迅速地被發送給所有感興趣的消費者一旦這些消費者成功接收到訊息，系統即可安全地將訊息從記憶體中移除，節省資源，同時確保後續價格變動的訊息仍能迅速而有效地傳遞 總體而言，非持久化訊息是一種適用於即時通知和事件的輕量級設計，通常用於那些不需要長時間保存的訊息，並強調系統的即時性和資源效率 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 延遲和優先順序","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization","content":"","keywords":"","version":"Next"},{"title":"延遲管理​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#延遲管理","content":"延遲指的是訊息從發送到接收所需的時間，在ActiveMQ中，我們不僅能夠細緻地設定延遲時間，還可以根據應用的實際需求靈活調整，舉例來說，即時通知可能要求極低的延遲，而某些非緊急事件可能容許較長的延遲 ","version":"Next","tagName":"h2"},{"title":"延遲管理與MQTT的不同等級​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#延遲管理與mqtt的不同等級","content":"MQTT 定義了不同的服務品質（Quality of Service, QoS）等級，這些等級決定了訊息的傳遞保證和延遲特性 主要有三個等級： 等級\t描述\t特點QoS 0\t保證訊息傳送，但不保證接收，簡單且低延遲\t適用於不太重要的應用場景 QoS 1\t保證訊息至少被傳送一次，可能有重複訊息\t提高了傳遞的可靠性，但可能增加延遲 QoS 2\t保證訊息僅被傳送一次，消除了重複訊息的可能性\t提供最高的可靠性，但伴隨著更多的延遲 ","version":"Next","tagName":"h2"},{"title":"QoS 0 (最多一次傳遞)​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#qos-0-最多一次傳遞","content":"這個等級保證訊息會被傳送，但不保證它是否被接收這是一個最簡單且延遲最低的等級，適用於一些不太重要的應用場景 ","version":"Next","tagName":"h3"},{"title":"QoS 1 (至少一次傳遞)​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#qos-1-至少一次傳遞","content":"這個等級保證訊息至少被傳送一次，但可能會有重複訊息這增加了傳遞的可靠性，但也可能增加一些延遲 ","version":"Next","tagName":"h3"},{"title":"QoS 2 (只有一次傳遞)​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#qos-2-只有一次傳遞","content":"這個等級保證訊息僅被傳送一次，消除了重複訊息的可能性同時也帶來了更多的延遲 ","version":"Next","tagName":"h3"},{"title":"MQTT的延遲管理靈活性​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#mqtt的延遲管理靈活性","content":"與 ActiveMQ 相似 MQTT 協議也允許使用者根據不同應用場景的需求調整延遲管理，透過選擇不同的QoS等級，使用者可以權衡訊息的可靠性和傳遞速度 在一個即時通訊應用中，可能會選擇使用 QoS 0，以降低延遲，確保訊息盡快到達，即時通知給使用者，而在某些非緊急的監控應用中，可能更願意接受較高的延遲，以保證訊息的完整性和唯一性，這時可考慮使用 QoS 2 ","version":"Next","tagName":"h3"},{"title":"ActiveMQ中的延遲管理​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#activemq中的延遲管理","content":"在Apache ActiveMQ（AMQ）中，雖然沒有像MQTT那樣嚴格定義的 QoS 等級，但它提供了一些特性和設定選項，允許使用者在一定程度上調整訊息的傳遞和延遲管理 ActiveMQ中的延遲管理可以透過以下方式實現： 功能\t描述\t特點訊息持久性\t允許將訊息設置為持久性，確保即使在接收者離線時，訊息仍然會在之後被傳遞\t保障訊息的可靠傳遞，可能增加一些延遲 Prefetch策略\t允許消費者預先從代理中獲取多個訊息，提高消費者效率\t通過調整預取限制影響延遲 Time-to-Live\t可為訊息設置TTL，指定訊息在系統中存留的時間，超過TTL的訊息將被丟棄\t影響訊息的存留時間，直接影響延遲 Redelivery策略\t允許設定重新傳遞策略，確保訊息在發送或接收時的可靠性\t影響訊息的重新傳遞機制，可能在觸發時增加延遲 ","version":"Next","tagName":"h2"},{"title":"訊息持久性​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#訊息持久性","content":"ActiveMQ允許將訊息設置為持久性，這意味著即使在接收者離線時，訊息仍然會在之後被傳遞這有助於確保訊息的可靠傳遞，但也可能增加一些延遲 ","version":"Next","tagName":"h3"},{"title":"Prefetch策略​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#prefetch策略","content":"Prefetch策略允許消費者在預先從代理中獲取多個訊息，從而提高消費者的效率這可以通過調整預取限制來影響延遲 ","version":"Next","tagName":"h3"},{"title":"Time-to-Live（TTL）​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#time-to-livettl","content":"可以為訊息設置TTL，指定訊息在系統中存留的時間超過TTL的訊息將被丟棄，這影響了訊息的延遲 ","version":"Next","tagName":"h3"},{"title":"Redelivery策略​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#redelivery策略","content":"ActiveMQ允許設定重新傳遞策略，確保訊息在發送或接收時的可靠性這也可能影響延遲，特別是在重新傳遞機制觸發時 ","version":"Next","tagName":"h3"},{"title":"應用場景的延遲需求​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#應用場景的延遲需求","content":"在現代的數位化環境中，應用場景的多樣性對延遲管理提出了不同的挑戰和需求 延遲管理成為系統優化的一個關鍵因素，而不同應用場景的需求差異更凸顯了其重要性 ","version":"Next","tagName":"h2"},{"title":"即時通知：極低延遲的迫切需求​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#即時通知極低延遲的迫切需求","content":"應用場景範例：即時通訊應用 在即時通知的場景中，如即時通訊應用，對於訊息的傳遞速度有著極低的延遲要求 當一方使用者發送訊息時，另一方使用者應盡快接收到該訊息，以確保即時性和提升使用者體驗 這種即時通知的場景包括聊天應用、社交媒體訊息等 ActiveMQ的延遲管理在這種情境下發揮關鍵作用，系統能夠通過調整延遲參數，確保訊息的快速傳遞，從而滿足即時通知的需求，這種低延遲的特性確保了使用者之間的即時互動，使得通訊更加實時、流暢 ","version":"Next","tagName":"h3"},{"title":"非緊急事件：靈活設定以節省資源​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#非緊急事件靈活設定以節省資源","content":"應用場景範例：系統報告與監控 某些應用場景中的事件可能並不緊急，且容許較長的延遲 舉例來說，在系統報告和監控的場景中，即時性並非首要考慮因素，而是更關注有效地利用資源 系統可以將這些非緊急事件的訊息設定為具有較長延遲時間，以達到更有效的資源分配 這種情境下，ActiveMQ的延遲管理允許系統管理員靈活設定延遲參數，以滿足特定應用場景的需求，通過調整延遲時間，系統能夠有效地處理非緊急事件，降低即時通知所需的資源，從而達到更好的效能 ","version":"Next","tagName":"h3"},{"title":"訊息處理中的優先順序管理​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#訊息處理中的優先順序管理","content":"在實際應用中，訊息處理的優先順序管理不僅是理論上的概念，更是許多系統成功運作的關鍵，以下將透過實際案例來融入更多實務上的內容，以更全面地理解訊息處理中的優先順序管理 ","version":"Next","tagName":"h2"},{"title":"優先順序與金融交易​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#優先順序與金融交易","content":"在金融領域，每一筆交易的處理順序直接關係到交易的合法性和準確性 在股票市場中，如果某筆買賣交易的訊息沒有按照正確的順序處理，可能導致交易錯誤或價格不一致的情況 透過ActiveMQ的優先順序管理，系統可以確保交易訊息按照時間順序被正確處理，防止潛在的風險 ","version":"Next","tagName":"h3"},{"title":"優先順序與實時資料處理​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#優先順序與實時資料處理","content":"在實時大資料應用中，不同類型的資料可能需要不同的處理順序 在一個監控系統中，傳感器資料的處理可能比其他日誌訊息更為緊急 透過 ActiveMQ 的優先順序管理，系統可以根據資料的重要性和即時性進行調整，確保關鍵訊息優先被處理 ","version":"Next","tagName":"h3"},{"title":"優先順序與系統穩定性​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#優先順序與系統穩定性","content":"優先順序管理還直接影響系統的穩定性 在某些情況下，系統可能需要處理大量的訊息，而合理的優先順序可以確保資源的有效分配，防止系統過載或崩潰 這種實務上的考量對於建立高效穩定的訊息處理系統至關重要 ","version":"Next","tagName":"h3"},{"title":"優先順序管理與異常處理​","type":1,"pageTitle":"🧣 ActiveMQ 延遲和優先順序","url":"/en/docs/activeMQ/fundamentals/efficientPrioritization#優先順序管理與異常處理","content":"系統總是面臨各種異常情況，例如訊息丟失或處理超時 ActiveMQ提供了進階的優先順序管理功能，讓使用者能夠針對異常情況進行更細緻的控制 將異常訊息標記為高優先順序，以優先處理和解決這些異常情況，提高系統的韌性 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 訊息過濾","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/fundamentals/filter","content":"","keywords":"","version":"Next"},{"title":"為什麼需要訊息過濾？​","type":1,"pageTitle":"🧣 ActiveMQ 訊息過濾","url":"/en/docs/activeMQ/fundamentals/filter#為什麼需要訊息過濾","content":"在實際應用中，訊息的種類可能非常多樣，而消費者並不一定對所有的訊息都感興趣 這時就需要一種機制來實現訊息的篩選，使得消費者只接收符合特定條件的訊息 這樣可以降低消費者端的資源浪費，提高系統的效率 ","version":"Next","tagName":"h2"},{"title":"ActiveMQ 中的訊息過濾​","type":1,"pageTitle":"🧣 ActiveMQ 訊息過濾","url":"/en/docs/activeMQ/fundamentals/filter#activemq-中的訊息過濾","content":"在 ActiveMQ 中，訊息過濾通常通過 SQL 表達式來實現這些表達式基於訊息的屬性進行篩選，只有符合條件的訊息才會被選擇性地傳送給相應的消費者，例如一個簡單的訊息過濾條件可以是選擇所有屬性 type 為 important 的訊息，這樣消費者就只會接收到這一類型的訊息，而忽略其他訊息 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"🧣 ActiveMQ 訊息過濾","url":"/en/docs/activeMQ/fundamentals/filter#範例","content":"以下是一個使用 JMS API 中的訊息過濾的簡單示例，假設有一個訊息屬性為 category： // 建立一個過濾條件，只接收屬性 &quot;category&quot; 為 &quot;urgent&quot; 的訊息 String messageFilter = &quot;category = 'urgent'&quot;; // 設定訊息過濾條件 consumer.setMessageSelector(messageFilter); // 設定訊息過濾監聽器 consumer.setMessageListener(message -&gt; { // 在這裡處理符合過濾條件的訊息 System.out.println(&quot;Received message: &quot; + message); });  在這個例子中，只有屬性 category 為 urgent 的訊息才會觸發消費者的訊息處理邏輯 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 成員","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/fundamentals/member","content":"","keywords":"","version":"Next"},{"title":"訊息（Message）​","type":1,"pageTitle":"🧣 ActiveMQ 成員","url":"/en/docs/activeMQ/fundamentals/member#訊息message","content":"訊息是在 ActiveMQ 中進行數據交換的基本單位，它可以包含各種類型的內容，例如文本、二進制數據，或其他格式的數據 ActiveMQ 支援兩種主要的訊息類型：點對點訊息和發布/訂閱訊息 ","version":"Next","tagName":"h2"},{"title":"點對點 訊息​","type":1,"pageTitle":"🧣 ActiveMQ 成員","url":"/en/docs/activeMQ/fundamentals/member#點對點-訊息","content":"是一種單發單收的模型，其中生產者將訊息發送到特定的隊列（Queue），而僅有一個消費者可以接收並處理該訊息 這種模型適用於需要確保每條訊息僅被一個消費者處理的場景 ","version":"Next","tagName":"h3"},{"title":"發布/訂閱 訊息​","type":1,"pageTitle":"🧣 ActiveMQ 成員","url":"/en/docs/activeMQ/fundamentals/member#發布訂閱-訊息","content":"允許生產者將訊息發送到特定的主題（Topic），而多個消費者可以訂閱這個主題以接收訊息 這種模型適用於需要一條訊息被多個消費者處理的場景 ","version":"Next","tagName":"h3"},{"title":"生產者（Producer）​","type":1,"pageTitle":"🧣 ActiveMQ 成員","url":"/en/docs/activeMQ/fundamentals/member#生產者producer","content":"生產者是負責建立和發送訊息的實體 它們扮演著將信息注入 ActiveMQ 系統的角色 生產者通常需要指定訊息的目的地，即訊息要發送到的隊列或主題 這樣的設定確保了訊息被發送到正確的地方，以便相應的消費者能夠接收和處理 ","version":"Next","tagName":"h2"},{"title":"消費者（Consumer）​","type":1,"pageTitle":"🧣 ActiveMQ 成員","url":"/en/docs/activeMQ/fundamentals/member#消費者consumer","content":"消費者是訊息的接收者和處理者 它們在 ActiveMQ 中訂閱特定的隊列或主題，以接收生產者發送的訊息 消費者的角色至關重要，因為它們確保訊息得以有效地傳遞並被適當地利用 消費者可以選擇以同步或異步的方式處理訊息，具體取決於應用的需求 ","version":"Next","tagName":"h2"},{"title":"🧣 ActiveMQ 隊列和主題","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/fundamentals/queueAndTopic","content":"","keywords":"","version":"Next"},{"title":"隊列（Queue）​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#隊列queue","content":"隊列是一種點對點（Point-to-Point）的訊息傳遞模型 在隊列中，訊息的生產者（Producer）將訊息發送到隊列中，而訊息的消費者（Consumer）則從隊列中接收訊息，每條訊息只有一個消費者能夠接收，確保訊息的獨立性即便有多個消費者，每條訊息也只會被其中一個消費者處理，這種模型適用於需要點對點通信的情境，如任務分配、工作排程等 ","version":"Next","tagName":"h2"},{"title":"隊列的應用場景​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#隊列的應用場景","content":"點對點通信需求確保每條訊息只被一個消費者處理 ","version":"Next","tagName":"h3"},{"title":"主題（Topic）​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#主題topic","content":"主題是一種發布/訂閱（Publish/Subscribe）的訊息傳遞模型 在主題中，訊息的生產者將訊息發送到主題，而所有訂閱了該主題的消費者都能夠接收這些訊息，每條訊息會被所有訂閱者收到，這種模型適用於需要一對多通信的情境，如訊息通知、事件發佈等 ","version":"Next","tagName":"h2"},{"title":"主題的應用場景​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#主題的應用場景","content":"一對多通信需求多個消費者需要獲取相同的訊息 ","version":"Next","tagName":"h3"},{"title":"訊息的生命週期​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#訊息的生命週期","content":"在 ActiveMQ 中，訊息的生命週期包括幾個關鍵階段，這些階段涵蓋了訊息從生產者到消費者的整個傳遞過程 ","version":"Next","tagName":"h2"},{"title":"生產階段​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#生產階段","content":"當訊息的生產者將訊息發送到隊列或主題時，這標誌著訊息的生命週期的起始點在這個階段 訊息被建立，並包含有關內容的元數據，例如訊息的標題、內容和發送時間戳 ","version":"Next","tagName":"h3"},{"title":"存儲階段​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#存儲階段","content":"一旦訊息進入隊列或主題，它進入了存儲階段 在這個階段，ActiveMQ 負責存儲訊息，並根據訊息的特性進行分發 在隊列中訊息按照先進先出（FIFO）的原則排隊，而在主題中所有訂閱者都能夠獲取訊息的副本 ","version":"Next","tagName":"h3"},{"title":"消費階段​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#消費階段","content":"當消費者開始從隊列或主題中接收訊息時，這標誌著訊息的消費階段 在這個階段，訊息被傳遞給消費者，並且消費者可以開始處理訊息的內容消費者可能執行與訊息相關的業務邏輯，並在需要時進行回應 ","version":"Next","tagName":"h3"},{"title":"確認階段​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#確認階段","content":"在成功處理完訊息後，消費者可能需要向 ActiveMQ 發送確認（acknowledge）以表明訊息已經被成功處理 這是確保訊息處理完畢並成功處理的重要步驟 在某些情況下，如果消費者未能成功處理訊息，可能需要發送拒絕（reject）通知，以便訊息能夠被重新處理或進入死信隊列 ","version":"Next","tagName":"h3"},{"title":"進階特性​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#進階特性","content":"除了基本的訊息傳遞模型外，ActiveMQ 還提供了一些進階特性，這些特性能夠進一步定制訊息的生命週期和處理流程 例如，訊息的優先級、持久性、以及死信隊列的配置都是可以調整的參數，這使得開發人員能夠根據應用的需求來優化訊息的處理 ","version":"Next","tagName":"h3"},{"title":"生命週期圖示​","type":1,"pageTitle":"🧣 ActiveMQ 隊列和主題","url":"/en/docs/activeMQ/fundamentals/queueAndTopic#生命週期圖示","content":"","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 通訊協議","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/overView/protocol","content":"","keywords":"","version":"Next"},{"title":"官方預設通訊協議​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#官方預設通訊協議","content":"檔案: /conf/activemq.xml &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h2"},{"title":"傳輸協議​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#傳輸協議","content":"","version":"Next","tagName":"h2"},{"title":"TCP​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#tcp","content":"TCP (Transmission Control Protocol) 預設 port 為 61616在預設的情況下，被命名為 openwire連線字串的組成為 tcp://ip:port?key=valueTCP 優點 TPC 協議為保證連線效率高，socket 本身有 retry 機制 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"AMQP​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#amqp","content":"AMQP (Advanced Message Queuing Protocol) 預設 port 為 5672在預設的情況下，AMQP 連線被命名為 amqp連線字串的組成為 amqp://ip:port?key=valueAMQP 優點 支援多種客戶端和伺服器，使其成為一個極具靈活性的協議提供高度可靠的訊息交付機制，適合需要確保訊息不會丟失的應用程序能夠處理大量訊息，使其適用於高流量環境 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"STORM​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#storm","content":"STORM (STOMP - Streaming Text Oriented Messaging Protocol) 預設 port 為 61613在預設的情況下，STORM 連線被命名為 stomp連線字串的組成為 stomp://ip:port?key=valueSTORM 優點 提供輕量級的訊息傳遞協議，適合實時通訊和流數據處理易於實現並與多種客戶端和伺服器庫兼容 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"MQTT​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#mqtt","content":"MQTT (Message Queuing Telemetry Transport) 預設 port 為 1883在預設的情況下，MQTT 連線被命名為 mqtt連線字串的組成為 mqtt://ip:port?key=valueMQTT 優點 非常適合 IOT 設備，因為它是一個輕量級協議，節省網路和資源提供發布/訂閱和請求/回應訊息傳遞模式 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"WebSocket​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/activeMQ/overView/protocol#websocket","content":"預設 port 為 61614在預設的情況下，WebSocket 連線被命名為 ws連線字串的組成為 ws://ip:port?key=valueWebSocket 優點 允許伺服器和客戶端之間的即時雙向通信適用於互動性應用程序，如即時聊天、在線遊戲等 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"🧣 關於 ActiveMQ","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/overView/whatIsMQ","content":"","keywords":"","version":"Next"},{"title":"消息列隊 (Message Queue)​","type":1,"pageTitle":"🧣 關於 ActiveMQ","url":"/en/docs/activeMQ/overView/whatIsMQ#消息列隊-message-queue","content":"提供了分布式應用程序之間進行通信的基礎架構這種通信模型允許應用程序通過發送和接收消息來實現彼此之間的通信，而無需直接相互連接這種間接的通信方式降低了應用程序之間的耦合度，使系統更具有靈活性和擴展性 在消息列隊中，核心概念是消息（Message），它是包含有關某個操作或事件訊息的資料單元，發送方將消息發送到列隊，然後列隊負責將消息按照順序路由到正確的接收方，這種模型的優勢在於它使得應用程序的各個組件可以獨立開發、測試和部署 ","version":"Next","tagName":"h2"},{"title":"消息列隊重要功能​","type":1,"pageTitle":"🧣 關於 ActiveMQ","url":"/en/docs/activeMQ/overView/whatIsMQ#消息列隊重要功能","content":"消息的持久化 (Message Persistence)： 即使接收方未準備好接收，也能確保消息不會遺失優先順序 (Message Priority)： 可以根據優先級確保高優先級消息被優先處理過濾 (Message Filtering)： ActiveMQ 支援消息過濾功能，允許接收方只接收符合特定條件的消息，提高系統效率路由 (Message Routing)： 利用消息列隊，可以實現消息的自動路由，確保消息被準確且高效地傳遞到目的地 ","version":"Next","tagName":"h3"},{"title":"ActiveMQ 概述​","type":1,"pageTitle":"🧣 關於 ActiveMQ","url":"/en/docs/activeMQ/overView/whatIsMQ#activemq-概述","content":"ActiveMQ 是一個開源的消息中間件（Message Broker），它實現了 Java Message Service（JMS）規範，並提供了強大的消息通信功能作為一個消息中間件 ActiveMQ 的主要任務是在分布式應用程序中促進不同組件之間的可靠通信 ","version":"Next","tagName":"h2"},{"title":"ActiveMQ 的特點​","type":1,"pageTitle":"🧣 關於 ActiveMQ","url":"/en/docs/activeMQ/overView/whatIsMQ#activemq-的特點","content":"跨平台性： ActiveMQ 可以運行在不同的操作系統上，包括 Windows、Linux 和 macOS，這使得它適用於各種不同的環境彈性的消息模型： 它支持多種消息模型，包括點對點（Point-to-Point）和發佈/訂閱（Publish/Subscribe）持久性： ActiveMQ 允許消息的持久性存儲，確保即使在接收方離線時，消息仍然可以被保留，並在稍後傳遞給接收方豐富的 API 支持： 除了原生的 JMS API，ActiveMQ 還提供了用於多種程式語言的客戶端 API，包括 Java、C++、Python 和 Ruby易於集成： ActiveMQ 與 Spring 框架緊密集成，這使得在使用 Spring 的應用程序中使用 ActiveMQ 變得更加容易 ","version":"Next","tagName":"h3"},{"title":"ActiveMQ 的角色​","type":1,"pageTitle":"🧣 關於 ActiveMQ","url":"/en/docs/activeMQ/overView/whatIsMQ#activemq-的角色","content":"在 ActiveMQ 中，有兩個主要的角色：生產者（Producer） 和 消費者（Consumer） 生產者 負責發送消息到 ActiveMQ Broker 消費者 則負責從 Broker 接收消息 這種角色的協同工作使得應用程序的不同部分能夠實現高效的通信，ActiveMQ 是一個強大而靈活的消息中間件 ","version":"Next","tagName":"h3"},{"title":"其他消息中間件的比較​","type":1,"pageTitle":"🧣 關於 ActiveMQ","url":"/en/docs/activeMQ/overView/whatIsMQ#其他消息中間件的比較","content":"特徵/屬性\tActiveMQ\tRabbitMQ\tKafka消息模型\t點對點和發佈/訂閱\t點對點和發佈/訂閱\t發佈/訂閱 協議\tJMS（Java Message Service）標準實現\tAMQP（Advanced Message Queuing Protocol）\t自有的協議 語言支持\tJava、C++、Python、Ruby 等\tErlang、Java、C#、Python 等\tJava、Scala、Python 等 易於集成\t與 Spring 框架緊密集成\t提供多種語言的客戶端庫，易於集成\t提供多種語言的客戶端庫，易於集成 持久性\t提供消息的持久性存儲\t提供消息的持久性存儲\t提供消息的持久性存儲，以日誌為基礎 可靠性\t以可靠的消息傳遞機制聞名\t強調快速的消息傳遞，提供可靠機制\t強調分佈式日誌，提供高可靠性 開源社區\t龐大的開源社區支持\t積極的開源社區參與\t積極的開源社區參與 管理和監控\t提供 Web 控制台和 JMX 支持\t提供 Web 控制台和 Prometheus 監控\t提供一系列工具和指標用於監控和管理 可擴展性\t支持插件擴展，具有豐富的功能\t以插件形式提供可擴展功能\t可擴展，支持水平擴展和垂直擴展 性能優化\t提供多種性能優化選項\t着重於高性能，支持多種優化配置\t聞名於高吞吐量和低延遲 社區活躍度\t活躍的社區和維護\t穩定的社區支持\t穩定的社區支持 應用場景\t適用於多種場景，尤其適合 Java 環境\t適用於多種語言，強調分佈式系統\t適用於高吞吐、低延遲的大數據場景 ","version":"Next","tagName":"h2"},{"title":"🧣 ActiveMQ 單機建立多組","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/setUp/createMoreActiveMQ","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/activeMQ/setUp/createMoreActiveMQ#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"在 windows 底下安裝多組​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/activeMQ/setUp/createMoreActiveMQ#在-windows-底下安裝多組","content":"","version":"Next","tagName":"h2"},{"title":"設定後台 port​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/activeMQ/setUp/createMoreActiveMQ#設定後台-port","content":"檔案: /conf/jetty.xmlport 不可重複 &lt;bean id=&quot;jettyPort&quot; class=&quot;org.apache.activemq.web.WebConsolePort&quot; init-method=&quot;start&quot;&gt; &lt;!-- the default port number for the web console --&gt; &lt;property name=&quot;host&quot; value=&quot;127.0.0.1&quot;/&gt; &lt;property name=&quot;port&quot; value=&quot;8161&quot;/&gt; &lt;/bean&gt;  ","version":"Next","tagName":"h3"},{"title":"設定通訊協議 port​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/activeMQ/setUp/createMoreActiveMQ#設定通訊協議-port","content":"檔案: /conf/activemq.xml所有通訊協議的 port 必須不重複 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"修改服務名稱​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/activeMQ/setUp/createMoreActiveMQ#修改服務名稱","content":"檔案: /bin/win64/wrapper.conf console 啟動時 CMD 的標題 # Title to use when running as a console wrapper.console.title=ActiveMQ_1895  服務的名稱 # Name of the service wrapper.ntservice.name=ActiveMQ_1895  服務管理器看到的名稱 # Display name of the service wrapper.ntservice.displayname=ActiveMQ_1895  服務管理器的敘述 # Description of the service wrapper.ntservice.description=ActiveMQ_1895 Broker  ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 安裝 - windows","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/setUp/inatallInWin","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/activeMQ/setUp/inatallInWin#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"安裝流程​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/activeMQ/setUp/inatallInWin#安裝流程","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/activeMQ/setUp/inatallInWin#下載","content":"選擇 apache-activemq-5.16.6-bin.zip 點擊下載 解壓縮 copy Apache24 to C:\\apache-activemq-5.16.6 ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/activeMQ/setUp/inatallInWin#啟動","content":"檔案: /bin/win64/activemq.bat 右鍵 以系統管理員身分執行 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 安裝 - Artemis","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#環境","content":"windows10 ~ 11 (win64)ActiveMQ Artemis 2.31.2 (注意版本與 JDK 的相容性)OpenJDK 17.0.2 ","version":"Next","tagName":"h2"},{"title":"安裝流程​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#安裝流程","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#下載","content":"點擊下載 解壓縮 copy Apache24 to C:\\apache-artemis-2.31.2 ","version":"Next","tagName":"h3"},{"title":"建立 Broker​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#建立-broker","content":"檔案: /apache-artemis-2.31.2/bin/ 右鍵 在終端機開啟 ","version":"Next","tagName":"h2"},{"title":"建立新的 Broker​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#建立新的-broker","content":".\\artemis create MyBroker  終端機顯示 PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username?  ","version":"Next","tagName":"h3"},{"title":"輸入帳戶名稱​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#輸入帳戶名稱","content":"admin  終端機顯示 PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username? admin --password: is mandatory with this configuration: What is the default password?  ","version":"Next","tagName":"h3"},{"title":"輸入密碼​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#輸入密碼","content":"test123  終端機顯示 PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username? admin --password: is mandatory with this configuration: What is the default password? --allow-anonymous | --require-login: Allow anonymous access?, valid values are Y, N, True, False  ","version":"Next","tagName":"h3"},{"title":"匿名模式​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#匿名模式","content":"caution 如果設定成 Y 隨意連線都可以連進來訂閱與推播 所以一律要設定成 N N  PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username? admin --password: is mandatory with this configuration: What is the default password? --allow-anonymous | --require-login: Allow anonymous access?, valid values are Y, N, True, False N Auto tuning journal ... done! Your system can make 0.45 writes per millisecond, your journal-buffer-timeout will be 2236000 You can now start the broker by executing: &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis&quot; run Or you can setup the broker as Windows service and run it in the background: &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; install &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; start To stop the windows service: &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; stop To uninstall the windows service &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; uninstall  到這邊可以看到目錄底下長出一個 Broker ","version":"Next","tagName":"h3"},{"title":"目錄位置​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#目錄位置","content":"","version":"Next","tagName":"h2"},{"title":"設定​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#設定","content":"位於 /apache-artemis-2.31.2/bin/MyBroker/etc/ ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/activeMQ/setUp/inatallInWinArtemis#啟動","content":"位於 /apache-artemis-2.31.2/bin/MyBroker/bin/ .\\artemis run  後台 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 自動回收","type":0,"sectionRef":"#","url":"/en/docs/activeMQ/setUp/setGC","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"訂閱者回收​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#訂閱者回收","content":"","version":"Next","tagName":"h2"},{"title":"訂閱者回收 - 設定​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#訂閱者回收---設定","content":"檔案: /conf/activemq.xml &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot; offlineDurableSubscriberTimeout=&quot;86400000&quot; offlineDurableSubscriberTaskSchedule=&quot;30000&quot;&gt; &lt;!-- 其他設定 --&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"訂閱者回收 - 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#訂閱者回收---屬性","content":"offlineDurableSubscriberTimeout: 此屬性設定了離線持久訂閱者的超時時間如果一個持久訂閱者在指定的超時時間內沒有任何活動，系統可能會將其視為離線狀態，並進行相應的處理超時時間設定為 86400000 毫秒，即 24 小時。 offlineDurableSubscriberTaskSchedule: 此屬性設定了執行離線持久訂閱者任務的排程間隔系統將以指定的間隔執行任務，以確保離線持久訂閱者的狀態得以更新排程間隔設定為 30000 毫秒，即 30 秒 ","version":"Next","tagName":"h3"},{"title":"Topic 回收​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#topic-回收","content":"","version":"Next","tagName":"h2"},{"title":"Topic 回收 - 設定​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#topic-回收---設定","content":"&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot; offlineDurableSubscriberTimeout=&quot;86400000&quot; offlineDurableSubscriberTaskSchedule=&quot;30000&quot;&gt; &lt;destinationPolicy&gt; &lt;policyMap&gt; &lt;policyEntries&gt; &lt;policyEntry topic=&quot;&gt;&quot;&gt; &lt;pendingMessageLimitStrategy&gt; &lt;constantPendingMessageLimitStrategy limit=&quot;1000&quot;/&gt; &lt;/pendingMessageLimitStrategy&gt; &lt;/policyEntry&gt; &lt;/policyEntries&gt; &lt;/policyMap&gt; &lt;/destinationPolicy&gt; &lt;!-- 其他設定 --&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"Topic 回收 - 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#topic-回收---屬性","content":"topic: 此屬性指定了 Topic 的名稱，這裡使用了 &gt;，表示所有的 Topic回收策略將應用於所有的 Topic pendingMessageLimitStrategy: 此屬性設定了待處理訊息數的限制策略，即當一個 Topic 上的待處理訊息數超過指定限制時，將採取相應的處理策略在這個例子中，使用了常數限制策略，設定的限制為每個 Topic 最多允許 1000 則待處理訊息 ","version":"Next","tagName":"h3"},{"title":"Queue 回收​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#queue-回收","content":"","version":"Next","tagName":"h2"},{"title":"Queue 回收 - 設定​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#queue-回收---設定","content":"&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot; offlineDurableSubscriberTimeout=&quot;86400000&quot; offlineDurableSubscriberTaskSchedule=&quot;30000&quot;&gt; &lt;destinationPolicy&gt; &lt;policyMap&gt; &lt;policyEntries&gt; &lt;policyEntry queue=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimoutBeforeGC=&quot;30000&quot;/&gt; &lt;/policyEntries&gt; &lt;/policyMap&gt; &lt;/destinationPolicy&gt; &lt;!-- 其他設定 --&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"Queue 回收 - 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/activeMQ/setUp/setGC#queue-回收---屬性","content":"gcInactiveDestinations: 此屬性用於啟用或禁用對閒置目的地的垃圾回收（Garbage Collection）如果設定為 true，系統將對閒置的 Queue 進行垃圾回收 inactiveTimoutBeforeGC: 此屬性設定了在執行垃圾回收之前，目的地可以保持閒置的時間閾值設定為 30000 毫秒，即 30 秒如果一個 Queue 在 30 秒內沒有活動，系統將視其為閒置目的地，並在啟用垃圾回收的情況下將其回收 ","version":"Next","tagName":"h3"},{"title":"📪 馬戲團","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate1","content":"","keywords":"","version":"Next"},{"title":"1. 定義要使用的委派​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#1-定義要使用的委派","content":"使用delegate關鍵字定義傳入參數string name  /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private delegate void Animal(string name);  ","version":"Next","tagName":"h2"},{"title":"2. 定義要接收委派的函式​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#2-定義要接收委派的函式","content":"定義馬戲團表演的函式傳入委派與動物姓名在函式裡實現委派animal(name);  /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;動物名字&lt;/param&gt; private static void RunCircus(Animal animal, string name) { animal(name); }  ","version":"Next","tagName":"h2"},{"title":"3. 定義小狗函式​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#3-定義小狗函式","content":" /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private static void Dog(string name) { Console.WriteLine($&quot;汪汪! 我是{name}&quot;); }  ","version":"Next","tagName":"h2"},{"title":"4. 在主程式實例化動物委派​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#4-在主程式實例化動物委派","content":"將小狗作為函式帶入  Animal deleDog = new Animal(Dog);  ","version":"Next","tagName":"h2"},{"title":"5. 將呼叫馬戲團函式​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#5-將呼叫馬戲團函式","content":"將動物委派傳入  RunCircus(deleDog, &quot;小狗&quot;);   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#完整程式碼","content":"using System; using System.Collections.Generic; using System.Text; namespace CSharpExercise.EventDemo { public class DelegateExercise1 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { Animal deleDog = new Animal(Dog); RunCircus(deleDog, &quot;小狗&quot;); } /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private delegate void Animal(string name); /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;動物名字&lt;/param&gt; private static void RunCircus(Animal animal, string name) { animal(name); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private static void Dog(string name) { Console.WriteLine($&quot;汪汪! 我是{name}&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"📪 馬戲團(多隻動物版)","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate2","content":"","keywords":"","version":"Next"},{"title":"1. 新增各種動物​","type":1,"pageTitle":"📪 馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate2#1-新增各種動物","content":" /// &lt;summary&gt; /// 貓 /// &lt;/summary&gt; public static void Cat() { Console.WriteLine($&quot;喵喵!&quot;); } /// &lt;summary&gt; /// 鴨 /// &lt;/summary&gt; public static void Duck() { Console.WriteLine($&quot;呱呱!&quot;); } /// &lt;summary&gt; /// 雞 /// &lt;/summary&gt; public static void Chicken() { Console.WriteLine($&quot;咕咕!&quot;); }  ","version":"Next","tagName":"h2"},{"title":"2. 取消掉委派傳入的名字​","type":1,"pageTitle":"📪 馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate2#2-取消掉委派傳入的名字","content":" /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private delegate void Animal(); /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;動物名字&lt;/param&gt; private static void RunCircus(Animal animal) { animal(); }  ","version":"Next","tagName":"h2"},{"title":"3. 使用迴圈建立動物 List​","type":1,"pageTitle":"📪 馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate2#3-使用迴圈建立動物-list","content":" List&lt;Animal&gt; deleAnimal = new List&lt;Animal&gt;() { new Animal(Dog), new Animal(Cat), new Animal(Duck), new Animal(Chicken) };  ","version":"Next","tagName":"h2"},{"title":"4. 使用foreach執行馬戲團​","type":1,"pageTitle":"📪 馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate2#4-使用foreach執行馬戲團","content":" foreach(var animalFunc in deleAnimal) { RunCircus(animalFunc); }   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate2#完整程式碼","content":"using System; using System.Collections.Generic; namespace csharpExercise.DelegateExercise { public class DelegateExercise2 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { List&lt;Animal&gt; deleAnimal = new List&lt;Animal&gt;() { new Animal(Dog), new Animal(Cat), new Animal(Duck), new Animal(Chicken) }; foreach(var animalFunc in deleAnimal) { RunCircus(animalFunc); } } /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; private delegate void Animal(); /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Animal animal) { animal(); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; private static void Dog() { Console.WriteLine($&quot;汪汪!&quot;); } /// &lt;summary&gt; /// 貓 /// &lt;/summary&gt; public static void Cat() { Console.WriteLine($&quot;喵喵!&quot;); } /// &lt;summary&gt; /// 鴨 /// &lt;/summary&gt; public static void Duck() { Console.WriteLine($&quot;呱呱!&quot;); } /// &lt;summary&gt; /// 雞 /// &lt;/summary&gt; public static void Chicken() { Console.WriteLine($&quot;咕咕!&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"📪 多點傳送委派-馬戲團(多隻動物版)","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate3","content":"","keywords":"","version":"Next"},{"title":"MulticastDelegate​","type":1,"pageTitle":"📪 多點傳送委派-馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate3#multicastdelegate","content":"","version":"Next","tagName":"h2"},{"title":"1. 使用 += 進行註冊​","type":1,"pageTitle":"📪 多點傳送委派-馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate3#1-使用--進行註冊","content":" Animal deleAnimal = new Animal(Dog); deleAnimal += new Animal(Cat); deleAnimal += new Animal(Duck); deleAnimal += new Animal(Chicken);   ","version":"Next","tagName":"h3"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 多點傳送委派-馬戲團(多隻動物版)","url":"/en/docs/csDelegate/csDelegate3#完整程式碼","content":"using System; namespace csharpExercise.DelegateExercise { public class DelegateExercise3 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { Animal deleAnimal = new Animal(Dog); deleAnimal += new Animal(Cat); deleAnimal += new Animal(Duck); deleAnimal += new Animal(Chicken); RunCircus(deleAnimal); } /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; private delegate void Animal(); /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Animal animal) { animal(); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; private static void Dog() { Console.WriteLine($&quot;汪汪!&quot;); } /// &lt;summary&gt; /// 貓 /// &lt;/summary&gt; public static void Cat() { Console.WriteLine($&quot;喵喵!&quot;); } /// &lt;summary&gt; /// 鴨 /// &lt;/summary&gt; public static void Duck() { Console.WriteLine($&quot;呱呱!&quot;); } /// &lt;summary&gt; /// 雞 /// &lt;/summary&gt; public static void Chicken() { Console.WriteLine($&quot;咕咕!&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"📪 Acton 泛型委派","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate4","content":"","keywords":"","version":"Next"},{"title":"1. 定義函式​","type":1,"pageTitle":"📪 Acton 泛型委派","url":"/en/docs/csDelegate/csDelegate4#1-定義函式","content":"傳入值設定為 ActionAction -&gt; 可以直接傳入函式  /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Action animal) { animal(); }  ","version":"Next","tagName":"h2"},{"title":"2. 呼叫馬戲團​","type":1,"pageTitle":"📪 Acton 泛型委派","url":"/en/docs/csDelegate/csDelegate4#2-呼叫馬戲團","content":"直接傳入狗函式無須做任何實例化  RunCircus(Dog);   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 Acton 泛型委派","url":"/en/docs/csDelegate/csDelegate4#完整程式碼","content":"using System; namespace csharpExercise.DelegateExercise { public class DelegateExercise4 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { RunCircus(Dog); } /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Action animal) { animal(); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; private static void Dog() { Console.WriteLine($&quot;汪汪!&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"📪 Acton 泛型委派 - 傳參數","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate5","content":"","keywords":"","version":"Next"},{"title":"1. 定義函式​","type":1,"pageTitle":"📪 Acton 泛型委派 - 傳參數","url":"/en/docs/csDelegate/csDelegate5#1-定義函式","content":"傳入值設定為 Action &lt;string&gt;&lt;T&gt; 之中帶入要傳遞的變數型別Action -&gt; 可以直接傳入函式  /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Action&lt;string&gt; animal, string name) { animal(name); }  ","version":"Next","tagName":"h2"},{"title":"2. 呼叫馬戲團​","type":1,"pageTitle":"📪 Acton 泛型委派 - 傳參數","url":"/en/docs/csDelegate/csDelegate5#2-呼叫馬戲團","content":"直接傳入狗函式無須做任何實例化  RunCircus(Dog, &quot;狗狗&quot;);   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 Acton 泛型委派 - 傳參數","url":"/en/docs/csDelegate/csDelegate5#完整程式碼","content":"using System; namespace CSharpExercise.DelegateExercise { public class DelegateExercise5 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { RunCircus(Dog, &quot;狗狗&quot;); } /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Action&lt;string&gt; animal, string name) { animal(name); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; private static void Dog(string name) { Console.WriteLine($&quot;汪汪!我是{name}&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"📪 Func<T> 泛型委派 - 有回傳值","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate6","content":"","keywords":"","version":"Next"},{"title":"1. 定義函式​","type":1,"pageTitle":"📪 Func<T> 泛型委派 - 有回傳值","url":"/en/docs/csDelegate/csDelegate6#1-定義函式","content":"傳入值設定為 Func&lt;string&gt;&lt;T&gt; 設定回傳值型態Func &lt;string&gt; -&gt;可以直接傳入函式  /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Func&lt;string&gt; animal) { string sound = animal(); Console.WriteLine(sound); }  ","version":"Next","tagName":"h2"},{"title":"2. 呼叫馬戲團​","type":1,"pageTitle":"📪 Func<T> 泛型委派 - 有回傳值","url":"/en/docs/csDelegate/csDelegate6#2-呼叫馬戲團","content":"直接傳入狗函式無須做任何實例化  RunCircus(Dog);   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 Func<T> 泛型委派 - 有回傳值","url":"/en/docs/csDelegate/csDelegate6#完整程式碼","content":"using System; namespace csharpExercise.DelegateExercise { public class DelegateExercise6 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { RunCircus(Dog); } /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Func&lt;string&gt; animal) { string sound = animal(); Console.WriteLine(sound); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string Dog() { return &quot;汪汪!&quot;; } } }  ","version":"Next","tagName":"h2"},{"title":"📪 Func<T,TResult> 泛型委派 - 有回傳值","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate7","content":"","keywords":"","version":"Next"},{"title":"1. 定義函式​","type":1,"pageTitle":"📪 Func<T,TResult> 泛型委派 - 有回傳值","url":"/en/docs/csDelegate/csDelegate7#1-定義函式","content":"傳入值設定為 Func&lt;int, string&gt;&lt;T,TResult&gt; T -&gt; 傳入參數TResult -&gt; 設定回傳值型態 Func&lt;string&gt; -&gt; 可以直接傳入函式  /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Func&lt;int, string&gt; animal, int age) { string sound = animal(age); Console.WriteLine(sound); }  ","version":"Next","tagName":"h2"},{"title":"2. 呼叫馬戲團​","type":1,"pageTitle":"📪 Func<T,TResult> 泛型委派 - 有回傳值","url":"/en/docs/csDelegate/csDelegate7#2-呼叫馬戲團","content":"直接傳入狗函式無須做任何實例化帶入年紀  RunCircus(Dog, 5);   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 Func<T,TResult> 泛型委派 - 有回傳值","url":"/en/docs/csDelegate/csDelegate7#完整程式碼","content":"using System; namespace csharpExercise.DelegateExercise { public class DelegateExercise7 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { RunCircus(Dog, 5); } /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; private static void RunCircus(Func&lt;int, string&gt; animal, int age) { string sound = animal(age); Console.WriteLine(sound); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string Dog(int age) { return $&quot;汪汪!{age.ToString()} 歲&quot;; } } }  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Web API 攔截器","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpAPIFilter","content":"","keywords":"","version":"Next"},{"title":"實做​","type":1,"pageTitle":"👩‍💻 Web API 攔截器","url":"/en/docs/daylily/csharpDaylily/csharpAPIFilter#實做","content":"using System; using System.Net; using System.Net.Http; using System.Threading; using System.Threading.Tasks; using System.Web.Http.Controllers; using System.Web.Http.Filters; public class SampleApiInterceptorAttribute : ActionFilterAttribute { public override async Task OnActionExecutingAsync(HttpActionContext actionContext, CancellationToken cancellationToken) { // 在執行操作之前攔截請求 // 可以在這裡記錄請求資訊，進行驗證等操作 string requestInfo = $&quot;{DateTime.Now}: Request from {actionContext.Request.RequestUri}&quot;; Console.WriteLine(requestInfo); // 繼續處理請求 await base.OnActionExecutingAsync(actionContext, cancellationToken); } public override async Task OnActionExecutedAsync(HttpActionExecutedContext actionExecutedContext, CancellationToken cancellationToken) { // 在執行操作之後攔截回應 // 可以在這裡記錄回應資訊，進行後續處理等操作 string responseInfo = $&quot;{DateTime.Now}: Response to {actionExecutedContext.Request.RequestUri}&quot;; Console.WriteLine(responseInfo); // 繼續處理回應 await base.OnActionExecutedAsync(actionExecutedContext, cancellationToken); } }  ","version":"Next","tagName":"h2"},{"title":"使用​","type":1,"pageTitle":"👩‍💻 Web API 攔截器","url":"/en/docs/daylily/csharpDaylily/csharpAPIFilter#使用","content":"","version":"Next","tagName":"h2"},{"title":"指定 Controller​","type":1,"pageTitle":"👩‍💻 Web API 攔截器","url":"/en/docs/daylily/csharpDaylily/csharpAPIFilter#指定-controller","content":"[SampleApiInterceptor] public class MyController : ApiController { // ...... }  ","version":"Next","tagName":"h3"},{"title":"全域註冊​","type":1,"pageTitle":"👩‍💻 Web API 攔截器","url":"/en/docs/daylily/csharpDaylily/csharpAPIFilter#全域註冊","content":"在程式的起始點設定  GlobalConfiguration.Configuration.Filters.Add(new SampleApiInterceptorAttribute());  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 判斷字串是否為數字","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpCharIsDigit","content":"👩‍💻 判斷字串是否為數字 StringName.All(char.IsDigit); using System; using System.Linq; public class IdentifyString { public static void Main() { string number = &quot;123456&quot;; if(number.All(char.IsDigit)) { Console.WriteLine(&quot;The Given String is a Number.&quot;); } else { Console.WriteLine(&quot;The Given String is Not a Number.&quot;); } } } ref: C# 識別字串是否為數字 | D棧 - Delft Stack","keywords":"","version":"Next"},{"title":"👩‍💻 委派與委派表達樹","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpFunc2Expression","content":"","keywords":"","version":"Next"},{"title":"Func to Expression (Compile())​","type":1,"pageTitle":"👩‍💻 委派與委派表達樹","url":"/en/docs/daylily/csharpDaylily/csharpFunc2Expression#func-to-expression-compile","content":"void Main() { data.Where(GetNo5().Compile()).Dump(); } public Expression&lt;Func&lt;int,bool&gt;&gt; GetNo5() { return x =&gt; x == 5; } public List&lt;int&gt; data = new List&lt;int&gt;(){1,2,3,4,5,6,7,8,9};  ","version":"Next","tagName":"h2"},{"title":"Expression to Func​","type":1,"pageTitle":"👩‍💻 委派與委派表達樹","url":"/en/docs/daylily/csharpDaylily/csharpFunc2Expression#expression-to-func","content":"void Main() { data.Where(GetNo(No1()).Compile()).Dump(); data.Where(GetNo(No5()).Compile()).Dump(); } public Expression&lt;Func&lt;int,bool&gt;&gt; GetNo(Func&lt;int,bool&gt; func) { return x =&gt; func(x); } public Func&lt;int,bool&gt; No1() =&gt; x =&gt; x == 1; public Func&lt;int,bool&gt; No5() =&gt; x =&gt; x == 5; public List&lt;int&gt; data = new List&lt;int&gt;(){1,2,3,4,5,6,7,8,9};  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 取得 Windows Product Id","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpGetOsPdId","content":"👩‍💻 取得 Windows Product Id 使用查詢 Win32_OperatingSystem 類別， 然後獲取操作系統的產品識別碼（ SerialNumber 屬性） caution 根據操作系統版本和權限，有時可能無法獲取操作系統的產品識別碼 這個訊息有時會受到保護，只有系統管理員權限才能訪問 using System; using System.Management; class Program { static void Main() { try { ManagementObjectSearcher searcher = new ManagementObjectSearcher(&quot;SELECT * FROM Win32_OperatingSystem&quot;); ManagementObjectCollection collection = searcher.Get(); foreach (ManagementObject m in collection) { // 獲取產品識別碼 string productId = m[&quot;SerialNumber&quot;].ToString(); Console.WriteLine(&quot;操作系統產品識別碼: &quot; + productId); } } catch (Exception e) { Console.WriteLine(&quot;無法獲取操作系統產品識別碼: &quot; + e.Message); } } } ","keywords":"","version":"Next"},{"title":"👩‍💻 圖片存檔(base64 to image)","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpImg","content":"","keywords":"","version":"Next"},{"title":"伺服器取得檔案路徑與建立目錄​","type":1,"pageTitle":"👩‍💻 圖片存檔(base64 to image)","url":"/en/docs/daylily/csharpDaylily/csharpImg#伺服器取得檔案路徑與建立目錄","content":" /// &lt;summary&gt; /// 取得圖片資料夾 /// 資料夾不存在就建立 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetFolder() { var storagePath = System.Web.Hosting.HostingEnvironment.MapPath(&quot;~/&quot;+ type); if (!System.IO.Directory.Exists(storagePath)) { System.IO.Directory.CreateDirectory(storagePath); } return storagePath; }  ","version":"Next","tagName":"h2"},{"title":"圖片資訊修改 (任意檔案通用)​","type":1,"pageTitle":"👩‍💻 圖片存檔(base64 to image)","url":"/en/docs/daylily/csharpDaylily/csharpImg#圖片資訊修改-任意檔案通用","content":"var folder = new DirectoryInfo(storagePath); IEnumerable&lt;FileInfo&gt; imgList = folder.GetFiles().Where(fi =&gt; fi.Name == syncImg.Name); imgList.First().CreationTime = syncImg.UpdateDateTime; // 建立時間 imgList.First().LastWriteTime = syncImg.UpdateDateTime;// 編輯時間  ","version":"Next","tagName":"h2"},{"title":"永久刪除圖片 (任意檔案通用)​","type":1,"pageTitle":"👩‍💻 圖片存檔(base64 to image)","url":"/en/docs/daylily/csharpDaylily/csharpImg#永久刪除圖片-任意檔案通用","content":" imgList.Where(fi =&gt; fi.Name == del.Key).First().Delete();  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 List to string 加入分隔符號","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpList2StringAddWord","content":"👩‍💻 List to string 加入分隔符號 void Main() { List&lt;string&gt; testList = new List&lt;string&gt;(){&quot;a&quot;,&quot;z&quot;,&quot;c&quot;,&quot;d&quot;,&quot;x&quot;}; string testStr = string.Join(&quot;,&quot;,testList); testStr.Dump(); } ","keywords":"","version":"Next"},{"title":"👩‍💻 多 List 比較","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpListContains","content":"","keywords":"","version":"Next"},{"title":"在 C# 中比較兩個列表​","type":1,"pageTitle":"👩‍💻 多 List 比較","url":"/en/docs/daylily/csharpDaylily/csharpListContains#在-c-中比較兩個列表","content":"用 C# 中的 Linq 方法比較列表以查詢差異用 C# 中的 List.Contains() 函式比較列表以尋找差異 ","version":"Next","tagName":"h2"},{"title":"用 C# 中的 Linq 方法比較列表以查詢差異​","type":1,"pageTitle":"👩‍💻 多 List 比較","url":"/en/docs/daylily/csharpDaylily/csharpListContains#用-c-中的-linq-方法比較列表以查詢差異","content":"","version":"Next","tagName":"h2"},{"title":"考慮以下情況​","type":1,"pageTitle":"👩‍💻 多 List 比較","url":"/en/docs/daylily/csharpDaylily/csharpListContains#考慮以下情況","content":"我們有兩個列表，分別是 list1 和 list2 ，我們想知道: list1 中哪些元素不在 list2 中list2 中哪些元素不在 list1 中 可以使用 Linq 中的 Except() 函式來完成。Linq 或語言整合查詢用於查詢 C# 中的資料結構。 Except() 函式返回一個列表的一組元素，這些元素在另一個列表中不存在。下面的程式碼例子向我們展示瞭如何用 C# 中的 Linq 來比較兩個列表的差異。 using System; using System.Collections.Generic; using System.Linq; namespace compare_lists { class Program { static void Main(string[] args) { List&lt;int&gt; list1 = new List&lt;int&gt; { 1, 1, 2, 3, 4 }; List&lt;int&gt; list2 = new List&lt;int&gt; { 3, 4, 5, 6 }; List&lt;int&gt; firstNotSecond = list1.Except(list2).ToList(); var secondNotFirst = list2.Except(list1).ToList(); Console.WriteLine(&quot;Present in List1 But not in List2&quot;); foreach (var x in firstNotSecond) { Console.WriteLine(x); } Console.WriteLine(&quot;Present in List2 But not in List1&quot;); foreach (var y in secondNotFirst) { Console.WriteLine(y); } } } }  輸出 Present in List1 But not in List2 1 2 Present in List2 But not in List1 5 6  ","version":"Next","tagName":"h3"},{"title":"用 C# 中的 List.Contains() 函式比較列表以尋找差異​","type":1,"pageTitle":"👩‍💻 多 List 比較","url":"/en/docs/daylily/csharpDaylily/csharpListContains#用-c-中的-listcontains-函式比較列表以尋找差異","content":"List.Contains() 函式用於確定 C# 中列表中是否存在元素。 如果列表中存在元素 x，則 List.Contains(x) 函式將返回 true； 如果元素 x 不存在，則該函式將返回 false。 我們可以對 Linq 使用 List.Contains() 方法來確定哪些元素存在於一個列表中，而不存在於另一個列表中。下面的程式碼示例向我們展示瞭如何使用 C# 中的 List.Contains() 函式比較兩個列表的差異。 using System; using System.Collections.Generic; using System.Linq; namespace compare_lists { class Program { static void Main(string[] args) { List&lt;int&gt; list1 = new List&lt;int&gt; { 1, 2, 3, 4 }; List&lt;int&gt; list2 = new List&lt;int&gt; { 3, 4, 5, 6 }; var firstNotSecond = list1.Where(i =&gt; !list2.Contains(i)).ToList(); var secondNotFirst = list2.Where(i =&gt; !list1.Contains(i)).ToList(); Console.WriteLine(&quot;Present in List1 But not in List2&quot;); foreach (var x in firstNotSecond) { Console.WriteLine(x); } Console.WriteLine(&quot;Present in List2 But not in List1&quot;); foreach (var y in secondNotFirst) { Console.WriteLine(y); } } } }  輸出 Present in List1 But not in List2 1 2 Present in List2 But not in List1 5 6  我們比較了列表 list1 和 list2 在上述程式碼中的區別。 我們首先將元素存在於列表 1 中，而不是儲存在新列表 firstNotSecond 中的列表 2 中。 然後，我們將存在於列表 2 中但不存在於列表 1 中的元素儲存在新列表 secondNotFirst 中。 最後，我們同時列印了 firstNotSecond 和 secondNotFirst 列表中的元素。 在此，輸出被重複與重複值一樣多的次數。如果我們要考慮重複值，則該方法應該比以前的方法更可取。 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 讀文檔 逐行讀取","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpReadAllLines","content":"","keywords":"","version":"Next"},{"title":"1. File.ReadAllLines​","type":1,"pageTitle":"👩‍💻 讀文檔 逐行讀取","url":"/en/docs/daylily/csharpDaylily/csharpReadAllLines#1-filereadalllines","content":"File.ReadAllLines(FileName);  ","version":"Next","tagName":"h2"},{"title":"2. ReadLine()​","type":1,"pageTitle":"👩‍💻 讀文檔 逐行讀取","url":"/en/docs/daylily/csharpDaylily/csharpReadAllLines#2-readline","content":"//We have to create Streader Object to use this method StreamReader ObjectName = new StreamReader(FileName); ObjectName.ReadLine();  using System; using System.IO; public class ReadFile { public static void Main() { string FileToRead = @&quot;D:\\New folder\\textFile.txt&quot;; using (StreamReader ReaderObject = new StreamReader(FileToRead)) { string Line; // ReaderObject reads a single line, stores it in Line string variable and then displays it on console while((Line = ReaderObject.ReadLine()) != null) { Console.WriteLine(Line); } } } }  ref: C# 逐行讀取文字檔案 | D棧 - Delft Stack ","version":"Next","tagName":"h2"},{"title":"👩‍💻 反射類別屬性，取值與改值","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpReflectionClass","content":"👩‍💻 反射類別屬性，取值與改值 void Main() { string jsonKey =&quot;Email&quot;; var user = new User(); user.Name = &quot;Dog&quot;; user.Email = &quot;Dog@gmail.com&quot;; Type t = user.GetType(); PropertyInfo[] pArray = t.GetProperties(); Console.WriteLine(pArray.Select(x =&gt; x.Name)); string emailKey = pArray.Where(x=&gt;x.Name == jsonKey).Select(x =&gt; x.Name).First(); Console.WriteLine(emailKey); // 取值 var emailValue = t.GetProperty(emailKey).GetValue(user); Console.WriteLine(emailValue); // 改值 t.GetProperty(emailKey).SetValue(user,&quot;Hi&quot;); Console.WriteLine(user.Email); } public class User { public string Name {get;set;} public string Email {get;set;} } ","keywords":"","version":"Next"},{"title":"👩‍💻 .NET Framework Self Host","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost","content":"","keywords":"","version":"Next"},{"title":"Self Host​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#self-host","content":"可以在 .NET Framework 中不須透過 IIS，直接啟動 REST API ","version":"Next","tagName":"h2"},{"title":"建構步驟​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#建構步驟","content":"","version":"Next","tagName":"h2"},{"title":"建立專案​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#建立專案","content":"建立一個 Console App (.NET Framework) 的專案 ","version":"Next","tagName":"h3"},{"title":"安裝 SelfHost​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#安裝-selfhost","content":"Install-Package Microsoft.AspNet.WebApi.SelfHost -Version 5.3.0  ","version":"Next","tagName":"h3"},{"title":"啟動設定​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#啟動設定","content":"檔案: Program.cs internal class Program { static void Main(string[] args) { // 指定聆聽的URL string host = &quot;localhost&quot;, port = &quot;8080&quot;; string hostPort = $@&quot;http://{host}:{port}&quot;; var config = new HttpSelfHostConfiguration(hostPort); // 設定路由 config.Routes.MapHttpRoute(&quot;API&quot;, &quot;{controller}/{action}/{id}&quot;, new { id = RouteParameter.Optional }); // 啟用 Cors // config.EnableCors(); // 移除 XML 格式 config.Formatters.XmlFormatter.SupportedMediaTypes.Clear(); // 使用 Json 格式 config.Formatters.JsonFormatter.SerializerSettings.Formatting = Newtonsoft.Json.Formatting.Indented; // 啟動服務 Task.Factory.StartNew(async () =&gt; { try { using (var httpServer = new HttpSelfHostServer(config)) { httpServer.OpenAsync().Wait(); // 需等到 Open 之後才能進行其他事項 Console.WriteLine(&quot;Web API host started...&quot;); //輸入exit 按 Enter 結束 httpServer string line = null; do { line = Console.ReadLine(); } while (line != &quot;exit&quot;); Console.WriteLine(&quot;Web API host closed...&quot;); //結束連線 await httpServer.CloseAsync(); } } catch (Exception ex) { Console.WriteLine($&quot;Web API host error={ex}&quot;); } }); } }  ","version":"Next","tagName":"h3"},{"title":"Controller​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#controller","content":"檔案: Controllers/TestController.cs public class TestController : ApiController { [HttpGet] public async Task&lt;IHttpActionResult&gt; Get() { await Task.Delay(100); return Ok(&quot;Hi Hi&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#啟動","content":"使用瀏覽器輸入 http://localhost:port 畫面顯示結果 Hi Hi  ","version":"Next","tagName":"h3"},{"title":"Ref​","type":1,"pageTitle":"👩‍💻 .NET Framework Self Host","url":"/en/docs/daylily/csharpDaylily/csharpSelfHost#ref","content":"不用IIS也能執行ASP.NET Web API[ASP.NET Web API] 使用 Self-Host 掛載 Web API 1 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 string to enum","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpString2Enum","content":"","keywords":"","version":"Next"},{"title":"我們在某些情境下會應用到將字串轉為列舉​","type":1,"pageTitle":"👩‍💻 string to enum","url":"/en/docs/daylily/csharpDaylily/csharpString2Enum#我們在某些情境下會應用到將字串轉為列舉","content":"從客戶端傳入一個字串，我想將它轉換為我自定義的列舉  StatusEnum myStatus; Enum.TryParse(&quot;Active&quot;, out myStatus);  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 字串擷取","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpSubstring","content":"","keywords":"","version":"Next"},{"title":"取得字串的末五碼​","type":1,"pageTitle":"👩‍💻 字串擷取","url":"/en/docs/daylily/csharpDaylily/csharpSubstring#取得字串的末五碼","content":"string originalString = &quot;這是一個很長的字串&quot;; int length = originalString.Length; if (length &gt;= 5) { string lastThreeCharacters = originalString.Substring(length - 5); Console.WriteLine(&quot;末五碼: &quot; + lastThreeCharacters); } else { // 處理字符串長度不足五個char的情況 Console.WriteLine(&quot;字串長度不足三個char&quot;); }  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 千分位符","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpThousandthPlace","content":"","keywords":"","version":"Next"},{"title":"如果需要將數字每三位做一個逗號可以使用​","type":1,"pageTitle":"👩‍💻 千分位符","url":"/en/docs/daylily/csharpDaylily/csharpThousandthPlace#如果需要將數字每三位做一個逗號可以使用","content":"12345567.ToString(&quot;N0&quot;);  結果: =&gt; 12,345,567  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 抓取最後一個commit","type":0,"sectionRef":"#","url":"/en/docs/daylily/gitDaylily/gitDepth","content":"👩‍💻 抓取最後一個commit 要只下載最後一個 commit，您可以使用以下命令： git clone --depth 1 &lt;repository_url&gt; 這個命令會只下載最後一個 commit，而不是整個 repository 的歷史版本。使用 --depth 選項，可以限制 git 克隆 repository 的歷史版本的深度。在此例中，我們將它設置為 1，這表示只下載最後一個 commit。 注意!! 使用 --depth 選項克隆的 repository 不包括歷史版本的信息。如果您需要查看更早期的 commit，則需要重新克隆 repository 或克隆整個 repository 歷史版本的深度","keywords":"","version":"Next"},{"title":"👩‍💻 commit type","type":0,"sectionRef":"#","url":"/en/docs/daylily/gitDaylily/gitCommitType","content":"","keywords":"","version":"Next"},{"title":"commit 的類型​","type":1,"pageTitle":"👩‍💻 commit type","url":"/en/docs/daylily/gitDaylily/gitCommitType#commit-的類型","content":"feat： 新功能、新特性fix： 修改 bugperf： 更改代碼，以提高性能（在不影響代碼內部行為的前提下，對程式性能進行優化）refactor： 代碼重構（重構，在不影響代碼內部行為、功能下的代碼修改）docs： 文件修改style： 代碼格式修改， 注意不是 css 修改（例如分號修改）test： 測試用例新增、修改build： 影響項目構建或依賴項修改revert： 恢復上一次提交ci： 持續集成相關文件修改chore： 其他修改（不在上述類型中的修改）release： 發佈新版本workflow： 工作流相關文件修改 ref: git commit 提交规范 - 知乎 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 聯集","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/csharpUnion","content":"","keywords":"","version":"Next"},{"title":"取得兩個 list 得聯集​","type":1,"pageTitle":"👩‍💻 聯集","url":"/en/docs/daylily/csharpDaylily/csharpUnion#取得兩個-list-得聯集","content":"void Main() { List&lt;int&gt; A = new List&lt;int&gt;(){1,2,3,5,7}; List&lt;int&gt; B = new List&lt;int&gt;(){2,3,4,5,6,7}; List&lt;int&gt; C = new List&lt;int&gt;(){2,3,4,5,6,7,9,10,11,12}; A = A.Union(B).ToList(); A.OrderBy(x =&gt; x).Dump(); A = A.Union(C).ToList(); A.OrderBy(x =&gt; x).Dump(); }  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 dotnet6 的 dockerfile","type":0,"sectionRef":"#","url":"/en/docs/daylily/csharpDaylily/dotnet6Dockerfile","content":"","keywords":"","version":"Next"},{"title":"建立檔案​","type":1,"pageTitle":"👩‍💻 dotnet6 的 dockerfile","url":"/en/docs/daylily/csharpDaylily/dotnet6Dockerfile#建立檔案","content":"在專案底下建立一個檔案 dockerfile FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build-env WORKDIR /app # Copy everything COPY . ./ # Restore as distinct layers RUN dotnet restore # Build and publish a release RUN dotnet publish -c Release -o out # Build runtime image FROM mcr.microsoft.com/dotnet/aspnet:6.0 WORKDIR /app COPY --from=build-env /app/out . ENTRYPOINT [&quot;dotnet&quot;, &quot;Foreteller-Backend.dll&quot;]  在專案底下建立一個檔案 .dockerignore，來過濾用不到的檔案 dockerfile .dockerignore  ","version":"Next","tagName":"h2"},{"title":"建立 image​","type":1,"pageTitle":"👩‍💻 dotnet6 的 dockerfile","url":"/en/docs/daylily/csharpDaylily/dotnet6Dockerfile#建立-image","content":"docker build -t dotnet6-app .  ","version":"Next","tagName":"h2"},{"title":"啟動 dotnet6 容器​","type":1,"pageTitle":"👩‍💻 dotnet6 的 dockerfile","url":"/en/docs/daylily/csharpDaylily/dotnet6Dockerfile#啟動-dotnet6-容器","content":"docker run -p 80:3050 dotnet6-app  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Spring Boot Hibernate 連接 MSSQL","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/javaConnentMSSQL","content":"","keywords":"","version":"Next"},{"title":"1. 在 pom.xml 中添加 MSSQL 驅動程序的依賴​","type":1,"pageTitle":"👩‍💻 Spring Boot Hibernate 連接 MSSQL","url":"/en/docs/daylily/javaDaylily/javaConnentMSSQL#1-在-pomxml-中添加-mssql-驅動程序的依賴","content":"&lt;dependency&gt; &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt; &lt;artifactId&gt;mssql-jdbc&lt;/artifactId&gt; &lt;version&gt;7.4.1.jre8&lt;/version&gt; &lt;/dependency&gt;  ","version":"Next","tagName":"h2"},{"title":"2. 在 application.properties 中添加 MSSQL 連接屬性​","type":1,"pageTitle":"👩‍💻 Spring Boot Hibernate 連接 MSSQL","url":"/en/docs/daylily/javaDaylily/javaConnentMSSQL#2-在-applicationproperties-中添加-mssql-連接屬性","content":"spring.datasource.url=jdbc:sqlserver://localhost:1433;databaseName=mydb spring.datasource.username=username spring.datasource.password=password spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver  ","version":"Next","tagName":"h2"},{"title":"3. 在 application.properties 中添加 Hibernate 屬性​","type":1,"pageTitle":"👩‍💻 Spring Boot Hibernate 連接 MSSQL","url":"/en/docs/daylily/javaDaylily/javaConnentMSSQL#3-在-applicationproperties-中添加-hibernate-屬性","content":"spring.jpa.hibernate.ddl-auto=update spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.SQLServer2012Dialect  ","version":"Next","tagName":"h2"},{"title":"4. 在配置類中添加 @EnableTransactionManagement 註解​","type":1,"pageTitle":"👩‍💻 Spring Boot Hibernate 連接 MSSQL","url":"/en/docs/daylily/javaDaylily/javaConnentMSSQL#4-在配置類中添加-enabletransactionmanagement-註解","content":"@Configuration @EnableTransactionManagement public class DatabaseConfig { // ... }  ","version":"Next","tagName":"h2"},{"title":"5. 在配置類中添加 EntityManagerFactory 和 TransactionManager 的 Bean​","type":1,"pageTitle":"👩‍💻 Spring Boot Hibernate 連接 MSSQL","url":"/en/docs/daylily/javaDaylily/javaConnentMSSQL#5-在配置類中添加-entitymanagerfactory-和-transactionmanager-的-bean","content":" @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(dataSource()); em.setPackagesToScan(new String[] { &quot;com.example.domain&quot; }); JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); em.setJpaProperties(additionalProperties()); return em; } @Bean public DataSource dataSource(){ DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); dataSource.setUrl(&quot;jdbc:sqlserver://localhost:1433;databaseName=mydb&quot;); dataSource.setUsername( &quot;username&quot; ); dataSource.setPassword( &quot;password&quot; ); return dataSource; } @Bean public PlatformTransactionManager transactionManager(EntityManagerFactory emf){ JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(emf); return transactionManager; } Properties additionalProperties() { Properties propertie }  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 tag","type":0,"sectionRef":"#","url":"/en/docs/daylily/gitDaylily/gitTag","content":"","keywords":"","version":"Next"},{"title":"annotated tag​","type":1,"pageTitle":"👩‍💻 tag","url":"/en/docs/daylily/gitDaylily/gitTag#annotated-tag","content":"而 annotated tag 跟 lightweight tag 最大的差異就是 annotated tag 可以添加訊息作為註解，而創建的方式和 lightweight tag 也只差一點點而已。 git tag &lt;tag_name&gt; &lt;commit_SHA-1&gt; -a -m &quot;message&quot;  ","version":"Next","tagName":"h2"},{"title":"查看 tag​","type":1,"pageTitle":"👩‍💻 tag","url":"/en/docs/daylily/gitDaylily/gitTag#查看-tag","content":"創建完成後，想要查看已經存在的 tag 該怎麼做呢？ 只要直接輸入以下指令，就會一次列出所有 tag 囉！ git tag  ","version":"Next","tagName":"h2"},{"title":"倘若只想看到 1.8.5 系列的標籤，你可以執行以下指令​","type":1,"pageTitle":"👩‍💻 tag","url":"/en/docs/daylily/gitDaylily/gitTag#倘若只想看到-185-系列的標籤你可以執行以下指令","content":"git tag -l &quot;v1.8.5*&quot;  ","version":"Next","tagName":"h2"},{"title":"将tag同步到遠端​","type":1,"pageTitle":"👩‍💻 tag","url":"/en/docs/daylily/gitDaylily/gitTag#将tag同步到遠端","content":"同提交代码后，使用git push来推送到远程服务器一样，tag 也需要进行推送才能到远端服务器。 使用 git push origin [tagName]推送单个分支。 git push origin v1.0  ref: 给指定的某个commit号加tag并推送 转 - 腾讯云开发者社区-腾讯云【Day20】Git 版本控制 - git tag - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Spring Data JPA與Hibernate的關係","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/javaDataJPAWithHibernate","content":"👩‍💻 Spring Data JPA與Hibernate的關係 Spring Data JPA 是一個專門用於訪問關聯資料庫的框架 它是建立在 Hibernate 之上的，可以讓開發者更容易地操作資料庫 Spring Data JPA 封裝了 Hibernate 的技術，使開發者可以更容易地使用 Hibernate 的功能，而不需要為每個操作編寫 Hibernate 的程式碼 Spring Data JPA 也提供了一些額外的功能，例如支援 JPA 的查詢語言，以及支援自定義查詢","keywords":"","version":"Next"},{"title":"👩‍💻 搜尋 class 來自哪個 jar","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/javaFindJar","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"👩‍💻 搜尋 class 來自哪個 jar","url":"/en/docs/daylily/javaDaylily/javaFindJar#環境","content":"OS: windows11 power shell ","version":"Next","tagName":"h2"},{"title":"用途​","type":1,"pageTitle":"👩‍💻 搜尋 class 來自哪個 jar","url":"/en/docs/daylily/javaDaylily/javaFindJar#用途","content":"使用 class name 搜尋這個 class 來自目錄底下哪個 jar 先移動到目錄 cd [目錄]  Get-ChildItem -Recurse -Filter &quot;*.jar&quot; | ForEach-Object { $jarFile = $_.FullName $result = jar tf $jarFile 2&gt;&amp;1 | Select-String -Pattern &quot;[class name].class&quot; if ($result) { Write-Host &quot;Found in $jarFile&quot; } }  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Spring Boot 修改啟動 port","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/javaStartPort","content":"👩‍💻 Spring Boot 修改啟動 port 於 application.properties 加入 # debug mode port set server.port=8090 ","keywords":"","version":"Next"},{"title":"👩‍💻 Spring Boot 安裝 Hibernate","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/javaSpringBootSetHibernate","content":"","keywords":"","version":"Next"},{"title":"Spring Boot 集成 Hibernate 的步驟如下​","type":1,"pageTitle":"👩‍💻 Spring Boot 安裝 Hibernate","url":"/en/docs/daylily/javaDaylily/javaSpringBootSetHibernate#spring-boot-集成-hibernate-的步驟如下","content":"","version":"Next","tagName":"h2"},{"title":"1. 在 pom.xml 文件中添加 Hibernate 依賴​","type":1,"pageTitle":"👩‍💻 Spring Boot 安裝 Hibernate","url":"/en/docs/daylily/javaDaylily/javaSpringBootSetHibernate#1-在-pomxml-文件中添加-hibernate-依賴","content":"&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.4.2.Final&lt;/version&gt; &lt;/dependency&gt;  ","version":"Next","tagName":"h3"},{"title":"2. 在 application.properties 文件中添加 Hibernate 相關配置​","type":1,"pageTitle":"👩‍💻 Spring Boot 安裝 Hibernate","url":"/en/docs/daylily/javaDaylily/javaSpringBootSetHibernate#2-在-applicationproperties-文件中添加-hibernate-相關配置","content":"spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect  ","version":"Next","tagName":"h3"},{"title":"3. 在 Spring Boot 主類中添加 @EnableTransactionManagement 注解​","type":1,"pageTitle":"👩‍💻 Spring Boot 安裝 Hibernate","url":"/en/docs/daylily/javaDaylily/javaSpringBootSetHibernate#3-在-spring-boot-主類中添加-enabletransactionmanagement-注解","content":"@SpringBootApplication @EnableTransactionManagement public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }  ","version":"Next","tagName":"h3"},{"title":"4. 在需要使用 Hibernate 的類中添加 @Transactional 注解​","type":1,"pageTitle":"👩‍💻 Spring Boot 安裝 Hibernate","url":"/en/docs/daylily/javaDaylily/javaSpringBootSetHibernate#4-在需要使用-hibernate-的類中添加-transactional-注解","content":"@Service public class UserService { @Transactional public void saveUser(User user) { // ... } }  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 使用 Maven 打包 spring boot","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/mvnPackage","content":"👩‍💻 使用 Maven 打包 spring boot pom.xml 中指定 application.properties &lt;!--開發環境--&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;!--默認開啟開發環境--&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!--profile.active對應application.properties中的@profile.active@--&gt; &lt;profile.active&gt;dev&lt;/profile.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!--測試環境--&gt; &lt;profile&gt; &lt;!--不同環境的唯一id--&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profile.active&gt;test&lt;/profile.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!--正式環境--&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profile.active&gt;prod&lt;/profile.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 指令 mvn clean package -P [指定的設定檔] ","keywords":"","version":"Next"},{"title":"👩‍💻 JDK與環境變數安裝","type":0,"sectionRef":"#","url":"/en/docs/daylily/javaDaylily/setJava","content":"","keywords":"","version":"Next"},{"title":"JAVA 優點​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#java-優點","content":"跨平台物件導向特性廣泛應用於企業及 Web 應用開發和行動應用開發。 ","version":"Next","tagName":"h2"},{"title":"編譯語言轉譯過程​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#編譯語言轉譯過程","content":"原始碼（Source code）-&gt; 編譯器（Compiler）-&gt; 機器碼（Machine code） ","version":"Next","tagName":"h2"},{"title":"環境安裝​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#環境安裝","content":"","version":"Next","tagName":"h2"},{"title":"使用 scoop 安裝 JDK​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#使用-scoop-安裝-jdk","content":"可以直接省略步驟1與步驟2 ","version":"Next","tagName":"h3"},{"title":"1.JDK下載 官網載點​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#1jdk下載-官網載點","content":" ","version":"Next","tagName":"h3"},{"title":"2.設定環境變數​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#2設定環境變數","content":"• 進入環境變數設定介面  • 點選環境變數  • 點選Path  • 將JDK的bin路徑加入 • 預設路徑為:C:\\Program Files\\Java\\jdk-17.0.1\\bin • 開啟CMD • 輸入 javac• 跑出許多JAVA資訊表示新增成功 ","version":"Next","tagName":"h3"},{"title":"IDE​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#ide","content":"VS Code 官方載點eclipse 官方載點IntelliJ IDEA 官方載點 ","version":"Next","tagName":"h3"},{"title":"VS Code​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#vs-code","content":"• 安裝java extension pack，安裝完重啟  ","version":"Next","tagName":"h3"},{"title":"gitignore​","type":1,"pageTitle":"👩‍💻 JDK與環境變數安裝","url":"/en/docs/daylily/javaDaylily/setJava#gitignore","content":"• 用來過濾不需要上傳的檔案/.settings/  /target/ # built application files *.apk *.ap_ # files for the dex VM *.dex # Java class files *.class *.jar # generated files bin/ gen/ # Eclipse project files .classpath .project .DS_Store  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 字串包含","type":0,"sectionRef":"#","url":"/en/docs/daylily/jsDaylily/jsStringIncludes","content":"👩‍💻 字串包含 string.includes(&quot;&quot;) ","keywords":"","version":"Next"},{"title":"👩‍💻 filter","type":0,"sectionRef":"#","url":"/en/docs/daylily/jsDaylily/jsFilter","content":"👩‍💻 filter let data = viewData.filter(v =&gt; v.id.includes(id)); ","keywords":"","version":"Next"},{"title":"👩‍💻 設定 Proxy","type":0,"sectionRef":"#","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy","content":"","keywords":"","version":"Next"},{"title":"步驟​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#步驟","content":"","version":"Next","tagName":"h2"},{"title":"登入主機​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#登入主機","content":"ssh [username]@IP [password]  ","version":"Next","tagName":"h3"},{"title":"查看目錄​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#查看目錄","content":"ls -i ls -ial  ","version":"Next","tagName":"h3"},{"title":"進入/etc/httpd/conf.d​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#進入etchttpdconfd","content":"cd /etc/httpd/conf.d  ","version":"Next","tagName":"h3"},{"title":"備份檔案vhost​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#備份檔案vhost","content":"sudo cp vhosts.conf vhost.conf.[datetime]  ","version":"Next","tagName":"h3"},{"title":"開始編輯檔案內容 - 使用 vim 編輯器​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#開始編輯檔案內容---使用-vim-編輯器","content":"sudo vim vhosts.conf  ","version":"Next","tagName":"h3"},{"title":"內容​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#內容","content":"[外網port] : 80(http), 443(https) &lt;VirtualHost *:[外網port]&gt; ServerName [proxy] # Redirect permanent / [proxy] ProxyRequests off ProxyPreserveHost on ProxyPass / http://[內網IP]:[內網Port]/ flushpackets=on keepalive=on ProxyPassReverse / http://[內網IP]:[內網Port]/ &lt;/VirtualHost&gt;  ","version":"Next","tagName":"h3"},{"title":"vim指令​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#vim指令","content":"複製多行 (nyy) 在命令模式下使用複製單行則使用(yy)n為行數從游標開始往下數n行ex: 5yy -&gt; 從游標往下複製5行 nyy yy  貼上(p) 在命令模式下使用將游標移動到要貼上的位置 p  切換編輯模式 進入-&gt; i離開 -&gt; esc 存檔 :w 離開 存檔並離開 -&gt; :wq不存檔離開 -&gt; :!q無修改離開 &gt; :q ","version":"Next","tagName":"h3"},{"title":"重啟阿帕契​","type":1,"pageTitle":"👩‍💻 設定 Proxy","url":"/en/docs/daylily/linuxDaylily/linuxSetProxy#重啟阿帕契","content":"sudo systemctl restart httpd  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 查詢所有Table筆數","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlAllTableCount","content":"👩‍💻 查詢所有Table筆數 USE [DB] GO SELECT O.NAME '資料表名稱', P.ROWS '總數' FROM SYS.OBJECTS O INNER JOIN SYS.SCHEMAS S ON O.SCHEMA_ID = S.SCHEMA_ID INNER JOIN SYS.PARTITIONS P ON O.OBJECT_ID = P.OBJECT_ID WHERE (O.TYPE = 'U') AND (P.INDEX_ID IN (0,1)) ORDER BY S.NAME, O.NAME ASC; GO ","keywords":"","version":"Next"},{"title":"👩‍💻 Docker 中安裝 MongoDB","type":0,"sectionRef":"#","url":"/en/docs/daylily/mongoDBDaylily/setIndocker","content":"","keywords":"","version":"Next"},{"title":"安裝版本​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MongoDB","url":"/en/docs/daylily/mongoDBDaylily/setIndocker#安裝版本","content":"MongoDB: 4.1Image: mongo:4.1OS: Windows11 caution 如果需要與 Mongo Express 的容器做集成，直接跳至 Docker 中安裝 MongoDB ","version":"Next","tagName":"h2"},{"title":"安裝步驟​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MongoDB","url":"/en/docs/daylily/mongoDBDaylily/setIndocker#安裝步驟","content":"","version":"Next","tagName":"h2"},{"title":"1. 下載 Image​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MongoDB","url":"/en/docs/daylily/mongoDBDaylily/setIndocker#1-下載-image","content":"下載 docker pull mongo:4.1  ","version":"Next","tagName":"h3"},{"title":"2. 啟動容器​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MongoDB","url":"/en/docs/daylily/mongoDBDaylily/setIndocker#2-啟動容器","content":"建立容器，並將 port 做對應 docker run -itd --name mongo4 -p 27017:27017 mongo:4.1 --auth  確認版本 docker exec mongo4 mongo --eval &quot;print(version())&quot;  ","version":"Next","tagName":"h3"},{"title":"3. 設定 MongoDB 帳號密碼​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MongoDB","url":"/en/docs/daylily/mongoDBDaylily/setIndocker#3-設定-mongodb-帳號密碼","content":"進入容器 docker exec -it mongo4 mongo admin  MongoDB 6.0 及以上版本使用以下命令 docker exec -it mongo mongosh admin  建立帳號 db.createUser({ user:'admin',pwd:'[pwd]',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},&quot;readWriteAnyDatabase&quot;]});  連線測試  db.auth('admin', '[pwd]')  實際畫面 docker exec -it mongo4 mongo admin MongoDB shell version v4.1.13 connecting to: mongodb://127.0.0.1:27017/admin?compressors=disabled&amp;gssapiServiceName=mongodb Implicit session: session { &quot;id&quot; : UUID(&quot;b5414ff1-513c-4c4c-b533-b1bfb76f2acd&quot;) } MongoDB server version: 4.1.13 Welcome to the MongoDB shell. For interactive help, type &quot;help&quot;. For more comprehensive documentation, see http://docs.mongodb.org/ Questions? Try the support group http://groups.google.com/group/mongodb-user &gt; db.createUser({ user:'admin',pwd:'test123',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},&quot;readWriteAnyDatabase&quot;]}); Successfully added user: { &quot;user&quot; : &quot;admin&quot;, &quot;roles&quot; : [ { &quot;role&quot; : &quot;userAdminAnyDatabase&quot;, &quot;db&quot; : &quot;admin&quot; }, &quot;readWriteAnyDatabase&quot; ] } &gt; db.auth('admin', 'test123') 1 &gt;  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 Docker 中安裝 Mongo Express","type":0,"sectionRef":"#","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress","content":"","keywords":"","version":"Next"},{"title":"關於 Mongo Express​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#關於-mongo-express","content":"Mongo Express 是 Mongo 的 GUI ","version":"Next","tagName":"h2"},{"title":"安裝版本​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#安裝版本","content":"MongoDB: 4.1MongoDB Image: mongo:4.1Mongo Express: latestMongo Express Image: mongo-express:latestOS: Windows11 ","version":"Next","tagName":"h3"},{"title":"安裝步驟 (MongoDB)​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#安裝步驟-mongodb","content":"","version":"Next","tagName":"h2"},{"title":"環境準備​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#環境準備","content":"建立 Network 使用 bridge 模式 docker network create -d bridge mongo-net  確認是否建立成功 docker network ls  有看到 mongo-net 表示建立成功 NETWORK ID NAME DRIVER SCOPE 004c88130dc3 bridge bridge local 48b2a44fc084 host host local a5b985174541 mongo-net bridge local  ","version":"Next","tagName":"h3"},{"title":"1. 下載 Image​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#1-下載-image","content":"下載 MongoDB docker pull mongo:4.1  下載 Mongo Express docker pull mongo-express:latest  ","version":"Next","tagName":"h3"},{"title":"2. 啟動 MongoDB 容器​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#2-啟動-mongodb-容器","content":"建立容器，並將 port 做對應，並使用 mongo-net 網路 docker run -itd --name mongo4 --network mongo-net -p 27017:27017 mongo:4.1  確認版本 docker exec mongo4 mongo --eval &quot;print(version())&quot;  ","version":"Next","tagName":"h3"},{"title":"3. 設定 MongoDB 帳號密碼​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#3-設定-mongodb-帳號密碼","content":"進入容器 docker exec -it mongo4 mongo admin  MongoDB 6.0 及以上版本使用以下命令 docker exec -it mongo mongosh admin  建立帳號 db.createUser({ user:'admin',pwd:'[pwd]',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},&quot;readWriteAnyDatabase&quot;]});  連線測試  db.auth('admin', '[pwd]')  實際畫面 docker exec -it mongo4 mongo admin MongoDB shell version v4.1.13 connecting to: mongodb://127.0.0.1:27017/admin?compressors=disabled&amp;gssapiServiceName=mongodb Implicit session: session { &quot;id&quot; : UUID(&quot;b5414ff1-513c-4c4c-b533-b1bfb76f2acd&quot;) } MongoDB server version: 4.1.13 Welcome to the MongoDB shell. For interactive help, type &quot;help&quot;. For more comprehensive documentation, see http://docs.mongodb.org/ Questions? Try the support group http://groups.google.com/group/mongodb-user &gt; db.createUser({ user:'admin',pwd:'test123',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},&quot;readWriteAnyDatabase&quot;]}); Successfully added user: { &quot;user&quot; : &quot;admin&quot;, &quot;roles&quot; : [ { &quot;role&quot; : &quot;userAdminAnyDatabase&quot;, &quot;db&quot; : &quot;admin&quot; }, &quot;readWriteAnyDatabase&quot; ] } &gt; db.auth('admin', 'test123') 1 &gt;  ","version":"Next","tagName":"h3"},{"title":"4. 啟動 Mongo Express 容器​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Mongo Express","url":"/en/docs/daylily/mongoDBDaylily/setMongoExpress#4-啟動-mongo-express-容器","content":"ME_CONFIG_MONGODB_SERVER: MongoDB container的名稱ME_CONFIG_MONGODB_ADMINUSERNAME: MongoDB 的最高使用者帳號ME_CONFIG_MONGODB_ADMINPASSWORD: MongoDB 的最高使用者密碼ME_CONFIG_BASICAUTH_USERNAME: 連線至 Mongo Express 網頁時所需的登入帳號ME_CONFIG_BASICAUTH_PASSWORD: 連線至 Mongo Express 網頁時所需的登入密碼 docker run --name mongo_express \\ --network mongo-net \\ -e ME_CONFIG_MONGODB_SERVER=mongo4 \\ -e ME_CONFIG_MONGODB_ADMINUSERNAME=admin \\ -e ME_CONFIG_MONGODB_ADMINPASSWORD=test123 \\ -e ME_CONFIG_BASICAUTH_USERNAME=admin \\ -e ME_CONFIG_BASICAUTH_PASSWORD=test123 \\ -p 8081:8081 mongo-express:latest  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 查詢所有index","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlFindAllIndex","content":"👩‍💻 查詢所有index SELECT TableName = t.name, IndexName = ind.name, IndexType = CASE ind.index_id WHEN 1 THEN 'Clustered' ELSE 'Nonclustered' END, ColumnName = col.name FROM sys.indexes ind INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id INNER JOIN sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id INNER JOIN sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 AND ind.is_unique = 0 AND ind.is_unique_constraint = 0 ORDER BY t.name, ind.name, ind.index_id, ic.key_ordinal; ","keywords":"","version":"Next"},{"title":"👩‍💻 字串轉型","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlCast","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"👩‍💻 字串轉型","url":"/en/docs/daylily/mssqlDaylily/mssqlCast#說明","content":"在資料庫欄位中，如果想要做 SUM() ，但資料型別是 nvarchar 等等字串型別， 執行加總時會有錯誤訊息 ","version":"Next","tagName":"h2"},{"title":"解決辦法​","type":1,"pageTitle":"👩‍💻 字串轉型","url":"/en/docs/daylily/mssqlDaylily/mssqlCast#解決辦法","content":"情境: 訂單中想要加總訂單金額， 訂單金額卻被定義成 nvarchar ","version":"Next","tagName":"h2"},{"title":"1. 使用 CAST​","type":1,"pageTitle":"👩‍💻 字串轉型","url":"/en/docs/daylily/mssqlDaylily/mssqlCast#1-使用-cast","content":"SELECT SUM( CAST ( [TotalAmount] AS int)) AS [總額] FROM [dbo].[OrdersMain]  結果 總額100 ","version":"Next","tagName":"h3"},{"title":"2. 使用 CONVERT​","type":1,"pageTitle":"👩‍💻 字串轉型","url":"/en/docs/daylily/mssqlDaylily/mssqlCast#2-使用-convert","content":"SELECT SUM( CONVERT(int ,[TotalAmount])) AS [總額] FROM [dbo].[OrdersMain]  結果 總額100 ","version":"Next","tagName":"h3"},{"title":"👩‍💻 增刪查詢 FK (Foreign Key)","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlFK","content":"","keywords":"","version":"Next"},{"title":"查詢目前所有 Table 的 FK​","type":1,"pageTitle":"👩‍💻 增刪查詢 FK (Foreign Key)","url":"/en/docs/daylily/mssqlDaylily/mssqlFK#查詢目前所有-table-的-fk","content":"SELECT FK.name AS 'FK Name', t.name AS 'Table Name', c1.name AS 'FK List', t2.name AS 'FK Table', c2.name AS 'FK Table List' FROM sys.foreign_keys FK INNER JOIN sys.tables t ON FK.parent_object_id = t.object_id INNER JOIN sys.tables t2 ON FK.referenced_object_id = t2.object_id INNER JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = FK.object_id INNER JOIN sys.columns c1 ON fkc.parent_column_id = c1.column_id AND c1.object_id = t.object_id INNER JOIN sys.columns c2 ON fkc.referenced_column_id = c2.column_id AND c2.object_id = t2.object_id GO  ","version":"Next","tagName":"h2"},{"title":"建立 FK​","type":1,"pageTitle":"👩‍💻 增刪查詢 FK (Foreign Key)","url":"/en/docs/daylily/mssqlDaylily/mssqlFK#建立-fk","content":"ALTER TABLE [dbo].[TableName] WITH CHECK ADD CONSTRAINT [FK_ForeignKeyName] FOREIGN KEY([TableKey]) REFERENCES [dbo].[FKTableName] ([FKTableNameId]) GO  ","version":"Next","tagName":"h2"},{"title":"刪除 FK​","type":1,"pageTitle":"👩‍💻 增刪查詢 FK (Foreign Key)","url":"/en/docs/daylily/mssqlDaylily/mssqlFK#刪除-fk","content":"ALTER TABLE [dbo].[TableName] DROP CONSTRAINT [FK_ForeignKeyName] GO  ","version":"Next","tagName":"h2"},{"title":"一次解除所有 FK​","type":1,"pageTitle":"👩‍💻 增刪查詢 FK (Foreign Key)","url":"/en/docs/daylily/mssqlDaylily/mssqlFK#一次解除所有-fk","content":"SELECT 'IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N''' + DC.Name + ''') and Type = ''D'') ALTER TABLE [' + OBJECT_SCHEMA_NAME(SO.ID) + '].[' + SO.Name + '] DROP CONSTRAINT [' + DC.Name + ']' FROM SysObjects SO INNER JOIN SysColumns SC ON SO.ID = SC.ID INNER JOIN sys.default_constraints DC ON SO.ID = DC.Parent_object_id AND SC.colid = DC.Parent_column_id WHERE SO.XTYPE = 'U' AND SC.Name = 'msrepl_tran_version' UNION SELECT 'IF EXISTS (SELECT * FROM dbo.syscolumns where id = OBJECT_ID(N''' + SO.Name + ''') and Name = ''msrepl_tran_version'') ALTER TABLE [' + OBJECT_SCHEMA_NAME(SO.ID) + '].[' + SO.Name + '] DROP COLUMN [msrepl_tran_version] ' FROM SysObjects SO INNER JOIN SysColumns SC ON SO.ID = SC.ID INNER JOIN sys.default_constraints DC ON SO.ID = DC.Parent_object_id AND SC.colid = DC.Parent_column_id WHERE SO.XTYPE = 'U' AND SC.Name = 'msrepl_tran_version' ORDER BY 1   ","version":"Next","tagName":"h2"},{"title":"REF​","type":1,"pageTitle":"👩‍💻 增刪查詢 FK (Foreign Key)","url":"/en/docs/daylily/mssqlDaylily/mssqlFK#ref","content":"SQL Server 中，移除資料庫中所有的關聯限制 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 查詢所有 Table","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlSelectAllTableName","content":"","keywords":"","version":"Next"},{"title":"查出所有 Table​","type":1,"pageTitle":"👩‍💻 查詢所有 Table","url":"/en/docs/daylily/mssqlDaylily/mssqlSelectAllTableName#查出所有-table","content":"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';  ","version":"Next","tagName":"h2"},{"title":"刪除所有 Table​","type":1,"pageTitle":"👩‍💻 查詢所有 Table","url":"/en/docs/daylily/mssqlDaylily/mssqlSelectAllTableName#刪除所有-table","content":"DECLARE @table_schema varchar(100) ,@table_name varchar(100) ,@constraint_schema varchar(100) ,@constraint_name varchar(100) ,@cmd nvarchar(200) DECLARE table_cursor CURSOR FOR select TABLE_SCHEMA, TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_NAME != 'sysdiagrams' OPEN table_cursor FETCH NEXT FROM table_cursor INTO @table_schema, @table_name WHILE @@FETCH_STATUS = 0 BEGIN SELECT @cmd = 'DROP TABLE [' + @table_schema + '].[' + @table_name + ']' --select @cmd EXEC sp_executesql @cmd FETCH NEXT FROM table_cursor INTO @table_schema, @table_name END CLOSE table_cursor DEALLOCATE table_cursor  caution 刪除前必須先 移除所有 FK  ","version":"Next","tagName":"h2"},{"title":"REF​","type":1,"pageTitle":"👩‍💻 查詢所有 Table","url":"/en/docs/daylily/mssqlDaylily/mssqlSelectAllTableName#ref","content":"SQL Server 刪除資料庫中所有資料表 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 查詢占用硬碟","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlSpSpaceused","content":"👩‍💻 查詢占用硬碟 -- 檢視目前資料庫所用的空間，但不一定能反映實際可用的磁碟空間。 EXEC sp_spaceused GO -- 要求掃描資料庫中的全部的資料頁後，再檢視目前資料庫所用的空間 EXEC sp_spaceused @updateusage = N'TRUE'; GO SET NOCOUNT ON DECLARE @tDBSize TABLE (DBName SYSNAME DEFAULT(DB_NAME()), Fileid INT, FileGroup INT, TotalExtents INT, UsedExtents INT, Name SYSNAME, FileName NVARCHAR(4000)) INSERT @tDBSize(Fileid,FileGroup,TotalExtents,UsedExtents,Name,FileName) EXEC ('DBCC showfilestats') SELECT DBName N'資料庫',Name N'資料檔案', TotalExtents*64.0/1024 N'資料檔案使用硬碟空間(MB)', UsedExtents*64.0/1024 N'資料實際使用空間(MB)', FileName N'實體檔案路徑' FROM @tDBSize GO ","keywords":"","version":"Next"},{"title":"👩‍💻 使用 sqlcmd 匯入 sql 指令","type":0,"sectionRef":"#","url":"/en/docs/daylily/mssqlDaylily/mssqlSqlImportData","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"👩‍💻 使用 sqlcmd 匯入 sql 指令","url":"/en/docs/daylily/mssqlDaylily/mssqlSqlImportData#說明","content":"如果 sql 指令內容過多時，使用 SSMS 執行會跑出 記憶體不足 的錯誤訊息 這時候可以使用 sqlcmd 來解決此問題 ","version":"Next","tagName":"h2"},{"title":"流程​","type":1,"pageTitle":"👩‍💻 使用 sqlcmd 匯入 sql 指令","url":"/en/docs/daylily/mssqlDaylily/mssqlSqlImportData#流程","content":"","version":"Next","tagName":"h2"},{"title":"1. 建立新的 Database​","type":1,"pageTitle":"👩‍💻 使用 sqlcmd 匯入 sql 指令","url":"/en/docs/daylily/mssqlDaylily/mssqlSqlImportData#1-建立新的-database","content":"可使用 SSMS 建立⚠️ Database 需與 sqlcmd 中的 USE [DataBase] 相同 ","version":"Next","tagName":"h3"},{"title":"2. 執行指令​","type":1,"pageTitle":"👩‍💻 使用 sqlcmd 匯入 sql 指令","url":"/en/docs/daylily/mssqlDaylily/mssqlSqlImportData#2-執行指令","content":"sqlcmd -S [Server Name] -U [User Name] -P [Password] -d [DataBase Name] -i [C:\\&lt;filePath&gt;\\script.sql]  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 MySQL 匯出資料庫腳本","type":0,"sectionRef":"#","url":"/en/docs/daylily/mysqlDaylily/exportSql","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"👩‍💻 MySQL 匯出資料庫腳本","url":"/en/docs/daylily/mysqlDaylily/exportSql#環境","content":"DB GUI: MySQL Workbench 8.0 CEMySQL: 8OS: Windows11 ","version":"Next","tagName":"h2"},{"title":"步驟​","type":1,"pageTitle":"👩‍💻 MySQL 匯出資料庫腳本","url":"/en/docs/daylily/mysqlDaylily/exportSql#步驟","content":"選單的 &gt; SeverData ExportTables to Export 勾選要匯出的資料庫Export to Self-Contained File &gt; 選擇匯出路徑Include Create SchemaStart Export ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Docker 中安裝 MySQL","type":0,"sectionRef":"#","url":"/en/docs/daylily/mysqlDaylily/setIndocker","content":"","keywords":"","version":"Next"},{"title":"安裝版本​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MySQL","url":"/en/docs/daylily/mysqlDaylily/setIndocker#安裝版本","content":"MySQL: mysql:8.0.18Image: library/mysql:8.0.18 (docker 官方)OS: Windows11 ","version":"Next","tagName":"h2"},{"title":"安裝步驟​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MySQL","url":"/en/docs/daylily/mysqlDaylily/setIndocker#安裝步驟","content":"","version":"Next","tagName":"h2"},{"title":"1. 下載 Image​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MySQL","url":"/en/docs/daylily/mysqlDaylily/setIndocker#1-下載-image","content":"下載 docker image pull library/mysql:8.0.18  ","version":"Next","tagName":"h3"},{"title":"2. 啟動容器​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MySQL","url":"/en/docs/daylily/mysqlDaylily/setIndocker#2-啟動容器","content":"建立容器，並將 port 做對應  docker run --name mysql8 \\ -p 3308:3306 \\ -e MYSQL_ROOT_PASSWORD=[password] \\ -d mysql:8.0.18 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci  ","version":"Next","tagName":"h3"},{"title":"3. 設定 MySQL 帳號密碼​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 MySQL","url":"/en/docs/daylily/mysqlDaylily/setIndocker#3-設定-mysql-帳號密碼","content":"進入容器 docker exec -it mysql8 mysql -u root -p  開放遠端連線 CREATE USER 'root'@'127.0.0.1' IDENTIFIED BY '[your_password]';  開放連線權限 GRANT ALL PRIVILEGES ON *.* TO 'root'@'127.0.0.1';  更新狀態 FLUSH PRIVILEGES;  caution 如果使用 DBeaver 連線，需進行以下設定 Connection settings &gt; Edit Driver SettingsDriver properties將 useSSL 改為 false將 allowPublicKeyRetrieval 改為 true ","version":"Next","tagName":"h3"},{"title":"👩‍💻 關於 NestJS","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/aboutNest","content":"","keywords":"","version":"Next"},{"title":"語言​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#語言","content":"在 NestJS 框架底下，我們將使用 TypeScript 來做為主要編寫的語言 ","version":"Next","tagName":"h2"},{"title":"環境​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#環境","content":"安裝 Node (&gt;= 16) nvm 安裝NestJS CLI # 安裝 CLI npm i -g @nestjs/cli  ","version":"Next","tagName":"h2"},{"title":"建立專案​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#建立專案","content":"","version":"Next","tagName":"h2"},{"title":"建立​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#建立","content":"# 建立專案 nest new [project-name]  ","version":"Next","tagName":"h3"},{"title":"使用 TypeScript 功能​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#使用-typescript-功能","content":"# 建立專案 nest new [project-name] --strict  ","version":"Next","tagName":"h3"},{"title":"建立公用 lib​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#建立公用-lib","content":"# 建立專案 cd [project-name]; nest g lib ${library-name}  ","version":"Next","tagName":"h3"},{"title":"專案架構​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#專案架構","content":"","version":"Next","tagName":"h2"},{"title":"目錄結構​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#目錄結構","content":"src └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"檔案說明​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#檔案說明","content":"檔案\t描述app.controller.ts\t具有單一路由的基本控制器 app.controller.spec.ts\t控制器的單元測試 app.module.ts\t應用程式的根模組 app.service.ts\t具有單一方法的基本服務 main.ts\t應用程式的入口檔案，使用核心函數 NestFactory 創建一個 Nest 應用程式實例 ","version":"Next","tagName":"h3"},{"title":"main.ts​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#maints","content":"import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000); } bootstrap();  可切換底層框架為 express 或 fastify 切換為 express import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule); await app.listen(3000); } bootstrap();  切換為 fastify import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create&lt;NestFastifyApplication&gt;(AppModule); await app.listen(3000); } bootstrap();   ","version":"Next","tagName":"h3"},{"title":"REF​","type":1,"pageTitle":"👩‍💻 關於 NestJS","url":"/en/docs/daylily/nestDaylily/aboutNest#ref","content":"NestJS 官網 梁大哥 教學 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 安裝 Swagger","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/addSwagger","content":"","keywords":"","version":"Next"},{"title":"步驟​","type":1,"pageTitle":"👩‍💻 安裝 Swagger","url":"/en/docs/daylily/nestDaylily/addSwagger#步驟","content":"","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"👩‍💻 安裝 Swagger","url":"/en/docs/daylily/nestDaylily/addSwagger#安裝","content":"pnpm install --save @nestjs/swagger  ","version":"Next","tagName":"h3"},{"title":"Bootstrap 設定​","type":1,"pageTitle":"👩‍💻 安裝 Swagger","url":"/en/docs/daylily/nestDaylily/addSwagger#bootstrap-設定","content":"import { NestFactory } from '@nestjs/core'; import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'; //swagger import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); // [B] swagger const config = new DocumentBuilder() .setTitle('Car API') .setDescription('The Car API description') .setVersion('1.0') .addTag('Car') .build(); const document = SwaggerModule.createDocument(app, config); SwaggerModule.setup('api', app, document); // [E] swagger await app.listen(3050); } bootstrap();  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"👩‍💻 安裝 Swagger","url":"/en/docs/daylily/nestDaylily/addSwagger#啟動","content":"pnpm start  http://localhost:3050/api ","version":"Next","tagName":"h3"},{"title":"👩‍💻 將 Service 抽象化","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface","content":"","keywords":"","version":"Next"},{"title":"關於抽象化​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#關於抽象化","content":"會進行抽象化的幾個主要原因 進行單元測試前，需要做資料隔離符合介面隔離原則讓模組之間的耦合度降低，確保後續的維護與修改可以更容易的進行符合依賴反轉原則讓其他呼叫者，依賴抽象，而不要依賴細節 通常開發過程會先定義interface，在實作細節 ","version":"Next","tagName":"h2"},{"title":"Service 抽象化​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#service-抽象化","content":"目前專案結構 src └─user │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"建立 interface​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#建立-interface","content":"在 user 資料夾底下，建立一個 interfaces 的資料夾並在裡面建立一個 user.service.interface.ts 的檔案 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  定義 user.service 所要開放的介面 import { UpdateUserDto, CreateUserDto, UserDto } from '../dto'; export interface UserServiceInterface { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ getUserByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ getUserById(id: string): Promise&lt;UserDto&gt;; /** 新增使用者 * * @param newUser new user * @param userId update user id * @returns new user list */ createUser(newUser: CreateUserDto, userId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /**更新使用者 * * @param id user id * @param oldUser edit user * @param userId update user id * @returns user list */ updaterUser( id: string, oldUser: UpdateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt;; /**刪除使用者 * * @param id user id * @returns user list */ deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt;; }  ","version":"Next","tagName":"h3"},{"title":"繼承並實作介面​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#繼承並實作介面","content":"於 user.service.ts 繼承介面，並且實作細節 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  export class UserService implements UserServiceInterface 使用implements來繼承介面並實作 import { Injectable } from '@nestjs/common'; import { UserServiceInterface } from './interfaces/user.service.interface'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; @Injectable() export class UserService implements UserServiceInterface { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ async getUserByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ async getUserById(id: string): Promise&lt;UserDto&gt; { let user: UserDto = { id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }; return user; } /** 新增使用者 * * @param newUser new user * @param userId update user id * @returns new user list */ async createUser( newUser: CreateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '591afd77-32d0-44c2-a487-b6bd8850a0fe', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**更新使用者 * * @param id user id * @param oldUser edit user * @param userId update user id * @returns user list */ async updaterUser( id: string, oldUser: UpdateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: oldUser.fullName, email: oldUser.email, phoneNumber: oldUser.phoneNumber, userName: oldUser.fullName, }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**刪除使用者 * * @param id user id * @returns user list */ async deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } }  ","version":"Next","tagName":"h3"},{"title":"將服務註冊到 module​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#將服務註冊到-module","content":"到 user.module.ts 註冊服務 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; @Module({ controllers: [UserController], providers: [ { provide: 'UserServiceInterface', // 注入時 tag 的標籤 useClass: UserService, // 服務的實體 }, ], }) export class UserModule {}  ","version":"Next","tagName":"h3"},{"title":"依賴反轉​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#依賴反轉","content":"","version":"Next","tagName":"h2"},{"title":"在 Controller 依賴抽象​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#在-controller-依賴抽象","content":"以下是修改前的程式碼， controller 是直接依賴 UserService 的實體 @Controller('user') export class UserController { constructor(private readonly userService: UserService) {} }  修改後，會變成 controller 依賴的是 UserServiceInterface 這介面 在透過注入時，module 來告訴 controller 真正應該使用哪個實體 @Controller('user') export class UserController { constructor( @Inject('UserServiceInterface') private readonly userService: UserServiceInterface, ) {} }   ","version":"Next","tagName":"h3"},{"title":"完整 controller 程式碼​","type":1,"pageTitle":"👩‍💻 將 Service 抽象化","url":"/en/docs/daylily/nestDaylily/cerateServiceInterface#完整-controller-程式碼","content":"import { Controller, Get, Post, Body, Put, Param, Delete, Inject, } from '@nestjs/common'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; import { UserServiceInterface } from './interfaces/user.service.interface'; @Controller('user') export class UserController { constructor( @Inject('UserServiceInterface') private readonly userService: UserServiceInterface, ) {} @Get(':storeId') async findAll(@Param('id') storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { return await this.userService.getUserByStoreId(storeId); } @Get(':id') async findOne(@Param('id') id: string): Promise&lt;UserDto&gt; { return await this.userService.getUserById(id); } @Post() async create(@Body() createCatDto: CreateUserDto) { return await this.userService.createUser(createCatDto, ''); } @Put(':id') async update(@Param('id') id: string, @Body() updateCatDto: UpdateUserDto) { return await this.userService.updaterUser(id, updateCatDto, ''); } @Delete(':id') async remove(@Param('id') id: string) { return await this.userService.deleteUser(id); } }   Ref 梁大哥 github ","version":"Next","tagName":"h3"},{"title":"👩‍💻 建立一個新的模組","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/createModul","content":"","keywords":"","version":"Next"},{"title":"目錄結構​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#目錄結構","content":"","version":"Next","tagName":"h2"},{"title":"新專案目錄結構​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#新專案目錄結構","content":"src └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"建立資料夾​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#建立資料夾","content":"先建立一個 user 的資料夾 src └─user │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"建立 Dto​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#建立-dto","content":"Dto 的全名為 data transfer object 定義資料傳輸時會使用的物件 注意: Dto != Entity 先定義一個使用者的 Dto 需將每個屬性加上 @ApiProperty() 這樣 swagger 才會顯示 並且可以針對 data 進行描述與限制 建立一個 dto 的目錄，並且建立一個 create-user.dto.ts 的檔案 user └─dto └─create-user.dto.ts  import { ApiProperty } from '@nestjs/swagger'; export class CreateUserDto { @ApiProperty({ description: '使用者全名', }) fullName: string; @ApiProperty({ description: 'user email', }) email: string; @ApiProperty({ description: 'user password', }) password: string; @ApiProperty({ description: '電話號碼', }) phoneNumber: string; @ApiProperty({ description: '使用者名稱', }) userName: string; }  建立一個 update-user.dto.ts 的檔案 user └─dto └─create-user.dto.ts │ └─update-user.dto.ts  import { ApiProperty } from '@nestjs/swagger'; export class UpdateUserDto { @ApiProperty({ description: 'user id', }) id: string; @ApiProperty({ description: '使用者全名', }) fullName: string; @ApiProperty({ description: 'user email', }) email: string; @ApiProperty({ description: '電話號碼', }) phoneNumber: string; @ApiProperty({ description: '使用者名稱', }) userName: string; }  建立一個 user.dto.ts user └─dto └─create-user.dto.ts │ └─update-user.dto.ts │ └─user.dto.ts │ └─index.ts  import { ApiProperty } from &quot;@nestjs/swagger&quot;; export class UserDto { @ApiProperty({ description: 'user id', }) id: string; @ApiProperty({ description: '使用者全名', }) fullName: string; @ApiProperty({ description: 'user email', }) email: string; @ApiProperty({ description: '電話號碼', }) phoneNumber: string; @ApiProperty({ description: '使用者名稱', }) userName: string; }  建立一個 index.ts 統一將 class 往上層拋 user └─dto └─create-user.dto.ts │ └─update-user.dto.ts │ └─user.dto.ts │ └─index.ts  export * from &quot;./create-user.dto&quot; export * from &quot;./update-user.dto&quot; export * from &quot;./user.dto&quot;  ","version":"Next","tagName":"h3"},{"title":"建立 Service​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#建立-service","content":"主要為商業邏輯層 所有的業務邏輯都應該集中在這一層 建立 user.service.ts user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─uer.dto.ts │ │ │ └─index.ts │ └─user.service.ts  import { Injectable } from '@nestjs/common'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; @Injectable() export class UserService { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ async getUserByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ async getUserById(id: string): Promise&lt;UserDto&gt; { let user: UserDto = { id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }; return user; } /** 新增使用者 * * @param newUser new user * @returns new user list */ async createUser(newUser: CreateUserDto): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '591afd77-32d0-44c2-a487-b6bd8850a0fe', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**更新使用者 * * @param id user id * @param oldUser edit user * @returns user list */ async updaterUser( id: string, oldUser: UpdateUserDto, ): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: oldUser.fullName, email: oldUser.email, phoneNumber: oldUser.phoneNumber, userName: oldUser.fullName, }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**刪除使用者 * * @param id user id * @returns user list */ async deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } }  ","version":"Next","tagName":"h3"},{"title":"建立 controller​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#建立-controller","content":"這邊採用 RESTful API 風格 並且作了增刪查改的功能 在 user 資料夾底下建立 user.controller.ts 檔案 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─user.controller.ts │ └─user.service.ts  服務注入  constructor(private readonly userService: UserService) {}  整體程式碼 import { Controller, Get, Post, Body, Put, Param, Delete, } from '@nestjs/common'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; import { UserService } from './user.service'; @Controller('user') export class UserController { constructor(private readonly userService: UserService) {} @Get(':storeId') async findAll(@Param('id') storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { return await this.userService.getUserByStoreId(storeId); } @Get(':id') async findOne(@Param('id') id: string): Promise&lt;UserDto&gt; { return await this.userService.getUserById(id); } @Post() async create(@Body() createCatDto: CreateUserDto) { return await this.userService.createUser(createCatDto); } @Put(':id') async update(@Param('id') id: string, @Body() updateCatDto: UpdateUserDto) { return await this.userService.updaterUser(id, updateCatDto); } @Delete(':id') async remove(@Param('id') id: string) { return await this.userService.deleteUser(id); } }  ","version":"Next","tagName":"h3"},{"title":"建置 module​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#建置-module","content":"主要來管理 controller, service 的生週期 建立 user.module.ts user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; @Module({ controllers: [UserController], providers: [UserService], }) export class UserModule {}  ","version":"Next","tagName":"h3"},{"title":"將 Module 註冊於 app​","type":1,"pageTitle":"👩‍💻 建立一個新的模組","url":"/en/docs/daylily/nestDaylily/createModul#將-module-註冊於-app","content":"到 app.module.ts 加入 user.module.ts import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; @Module({ imports: [UserModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 單元測試實作","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/createUnitTest","content":"","keywords":"","version":"Next"},{"title":"需求​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#需求","content":"我需要一個檢查物件的服務如果物件是字串，就需要檢查它是否為空字串如果物件是數字，就要檢查它是不是 NaN如果有錯誤的話都要上拋例外 ","version":"Next","tagName":"h2"},{"title":"實作單元測試​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#實作單元測試","content":"src └─user │ └─uuid │ └─error-check │ └─clock │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"定義服務會提供的介面​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#定義服務會提供的介面","content":"建立一個 error-check.service.interface.ts先想好要提供什麼要的 input 與 output error-check └─error-check.service.interface.ts  export interface ErrorCheckServiceInterface { /** * 檢查字串是否為空 * @param str */ isNullOrEmpty(str: string): boolean; /** * 檢查資料是否為空 * @param dataName 資料名稱 * @param data 需要被檢查的資料 */ checkOneValue&lt;T&gt;(dataName: string, data: T): void; }  ","version":"Next","tagName":"h3"},{"title":"建立服務檔案​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#建立服務檔案","content":"建立服務與測試 nest generate service error-check  error-check └─error-check.service.interface.ts | └─error-check.service.ts | └─error-check.service.spec.ts  ","version":"Next","tagName":"h3"},{"title":"先寫測試​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#先寫測試","content":"測試的檔案為 error-check.service.spec.ts先做好測試的前置準備 import { Test, TestingModule } from '@nestjs/testing'; import { ErrorCheckService } from './error-check.service'; describe('ErrorCheckService', () =&gt; { let errorCheckService: ErrorCheckService; beforeEach(async () =&gt; { // 在容器中註冊我要做測試的服務 const module: TestingModule = await Test.createTestingModule({ providers: [ErrorCheckService], }).compile(); // 從容器中取出我要測試的服務 errorCheckService = module.get&lt;ErrorCheckService&gt;(ErrorCheckService); }); });  ","version":"Next","tagName":"h2"},{"title":"需求1: 如果物件是字串，就需要檢查它是否為空字串​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#需求1-如果物件是字串就需要檢查它是否為空字串","content":"這邊測試兩個劇情 劇情1: 資料為空的話，我應該會收到一個例外 劇情2: 資料是正常的字串，應該要正常運作  it('should throw an error when given an empty string', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', '')).toThrowError('data,資料不能為空或未定義'); }); it('should not throw an error when given a valid string', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 'valid')).not.toThrow(); });  ","version":"Next","tagName":"h3"},{"title":"需求2: 如果物件是數字，就要檢查它是不是 NaN​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#需求2-如果物件是數字就要檢查它是不是-nan","content":"這邊測試兩個劇情 劇情1: 資料為 NaN 的話，我應該會收到一個例外 劇情2: 資料是正常的數字，應該要正常運作  it('should throw an error when given NaN', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', NaN)).toThrowError('data,資料不能為 NaN'); }); it('should not throw an error when given a valid number', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 42)).not.toThrow(); });  ","version":"Next","tagName":"h3"},{"title":"需求3: 如果有錯誤的話都要上拋例外​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#需求3-如果有錯誤的話都要上拋例外","content":"這邊測試兩個劇情 劇情1: 如果資料是 undefined，就要跳出 data,資料未定義 的例外 劇情2: 如果資料是沒有要檢查的型別，就要跳出 不支援的資料型別 的例外  it('should throw an error when given undefined data', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', undefined)).toThrowError('data,資料未定義'); }); it('should throw an error for unsupported data type', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', {})).toThrowError('不支援的資料型別'); });  ","version":"Next","tagName":"h3"},{"title":"完整的測試程式碼​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#完整的測試程式碼","content":"import { Test, TestingModule } from '@nestjs/testing'; import { ErrorCheckService } from './error-check.service'; describe('ErrorCheckService', () =&gt; { let errorCheckService: ErrorCheckService; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ providers: [ErrorCheckService], }).compile(); errorCheckService = module.get&lt;ErrorCheckService&gt;(ErrorCheckService); }); it('should throw an error when given an empty string', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', '')).toThrowError('data,資料不能為空或未定義'); }); it('should throw an error when given undefined data', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', undefined)).toThrowError('data,資料未定義'); }); it('should throw an error when given NaN', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', NaN)).toThrowError('data,資料不能為 NaN'); }); it('should throw an error for unsupported data type', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', {})).toThrowError('不支援的資料型別'); }); it('should not throw an error when given a valid string', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 'valid')).not.toThrow(); }); it('should not throw an error when given a valid number', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 42)).not.toThrow(); }); });  ","version":"Next","tagName":"h3"},{"title":"開始寫服務​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#開始寫服務","content":"","version":"Next","tagName":"h2"},{"title":"error-check.service.ts​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#error-checkservicets","content":"import { Injectable } from '@nestjs/common'; import { ErrorCheckServiceInterface } from './error-check.service.interface'; @Injectable() export class ErrorCheckService implements ErrorCheckServiceInterface { /** * 檢查字串是否為空 * @param str */ isNullOrEmpty(str: string): boolean { return !str || str == undefined || str == '' || str.length == 0; } /** * 檢查資料是否為空 * @param dataName 資料名稱 * @param data 需要被檢查的資料 */ checkOneValue&lt;T&gt;(dataName: string, data: T): void { switch (typeof data) { case 'string': if (this.isNullOrEmpty(data)) throw new Error(`${dataName},資料不能為空或未定義`); break; case 'number': if (isNaN(data)) throw new Error(`${dataName},資料不能為 NaN`); break; case 'undefined': throw new Error(`${dataName},資料未定義`); default: throw new Error('不支援的資料型別'); } } }  ","version":"Next","tagName":"h3"},{"title":"註冊服務​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#註冊服務","content":"先建立一個 module nest generate module error-check  import { Global, Module } from '@nestjs/common'; import { ErrorCheckService } from './error-check.service'; @Global() @Module({ providers: [ { provide: 'ErrorCheckServiceInterface', useClass: ErrorCheckService, }, ], exports: [ { provide: 'ErrorCheckServiceInterface', useClass: ErrorCheckService, }, ], }) export class ErrorCheckModule {}  app.module.ts import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; import { UuidModule } from './uuid/uuid.module'; import { ClockModule } from './clock/clock.module'; import { ErrorCheckModule } from './error-check/error-check.module'; @Module({ imports: [UserModule, UuidModule, ClockModule, ErrorCheckModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}  ","version":"Next","tagName":"h3"},{"title":"進行測試​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#進行測試","content":"","version":"Next","tagName":"h2"},{"title":"測試指令​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#測試指令","content":"進行所有測試 pnpm test  針對某個測試執行 pnpm test:watch src/error-check/error-check.service.spec.ts  測試過程中可以下中斷點 debug pnpm test:debug  ","version":"Next","tagName":"h3"},{"title":"執行​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#執行","content":"這邊執行 pnpm test:watch src/error-check/error-check.service.spec.ts  ","version":"Next","tagName":"h3"},{"title":"測試結果​","type":1,"pageTitle":"👩‍💻 單元測試實作","url":"/en/docs/daylily/nestDaylily/createUnitTest#測試結果","content":" PASS src/error-check/error-check.service.spec.ts ErrorCheckService √ should throw an error when given an empty string (35 ms) √ should throw an error when given undefined data (5 ms) √ should throw an error when given NaN (3 ms) √ should throw an error for unsupported data type (4 ms) √ should not throw an error when given a valid string (5 ms) √ should not throw an error when given a valid number (3 ms) Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Test Suites: 1 passed, 1 total Tests: 6 passed, 6 total Snapshots: 0 total Time: 6.617 s  可以看到測試後的數據與結果 ","version":"Next","tagName":"h3"},{"title":"👩‍💻 全域工具包 UUID","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/createUtail","content":"","keywords":"","version":"Next"},{"title":"關於全域工具包 UUID​","type":1,"pageTitle":"👩‍💻 全域工具包 UUID","url":"/en/docs/daylily/nestDaylily/createUtail#關於全域工具包-uuid","content":"為甚麼要特地提供一個 UUID 服務呢? 為了做測試隔離會有好幾個模組需要使用到這個功能 ","version":"Next","tagName":"h2"},{"title":"製作全域工具包 UUID​","type":1,"pageTitle":"👩‍💻 全域工具包 UUID","url":"/en/docs/daylily/nestDaylily/createUtail#製作全域工具包-uuid","content":"先建立一個 uuid 的資料夾 src └─user │ └─uuid │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"建立 interface​","type":1,"pageTitle":"👩‍💻 全域工具包 UUID","url":"/en/docs/daylily/nestDaylily/createUtail#建立-interface","content":"在 uuid 資料夾底下，建立一個 uuid.service.interface.ts uuid └─uuid.service.interface.ts  export interface UUIDServiceInterface { /** * 回傳 uuid */ getUUID(): string; }  ","version":"Next","tagName":"h3"},{"title":"建立 service​","type":1,"pageTitle":"👩‍💻 全域工具包 UUID","url":"/en/docs/daylily/nestDaylily/createUtail#建立-service","content":"此處可以使用 nest cli 來建立一個 service nest generate service uuid  uuid └─uuid.service.interface.ts | └─uuid.service.ts | └─uuid.service.spec.ts  uuid.service.spec.ts 是在進行測試使用的 import { Injectable } from '@nestjs/common'; import { UUIDServiceInterface } from './uuid.service.interface'; import { v4 as uuidv4 } from 'uuid'; @Injectable() export class UUIDService implements UUIDServiceInterface { /** * 取得 uuid */ async getUUID(): Promise&lt;string&gt; { const uuid = uuidv4(); return uuid; } }  ","version":"Next","tagName":"h3"},{"title":"註冊模組​","type":1,"pageTitle":"👩‍💻 全域工具包 UUID","url":"/en/docs/daylily/nestDaylily/createUtail#註冊模組","content":"先使用 nest cli 建立一個 uuid.module.ts nest generate module uuid  uuid └─uuid.service.interface.ts | └─uuid.service.ts | └─uuid.module.ts | └─uuid.service.spec.ts  註冊 uuid 服務並且需要做 exports 來上匯出模組使用 @Global() 來表示他是全域的模組 import { Module ,Global } from '@nestjs/common'; import { UUIDService } from './uuid.service'; @Global() @Module({ providers: [ { provide: 'UUIDServiceInterface', useClass: UUIDService, }, ], exports: [ { provide: 'UUIDServiceInterface', useClass: UUIDService, }, ], }) export class UuidModule {}  到 app.module.ts 底下註冊 UuidModule import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; import { UuidModule } from './uuid/uuid.module'; @Module({ imports: [UserModule, UuidModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}   ref 梁大哥 github ","version":"Next","tagName":"h3"},{"title":"👩‍💻 全域工具包 TimeZone","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/dateTimeUtail","content":"","keywords":"","version":"Next"},{"title":"關於全域工具包 TimeZone​","type":1,"pageTitle":"👩‍💻 全域工具包 TimeZone","url":"/en/docs/daylily/nestDaylily/dateTimeUtail#關於全域工具包-timezone","content":"為甚麼要特地提供一個 UUID 服務呢? 為了做測試隔離會有好幾個模組需要使用到這個功能在雲端服務中，直接取 local time 會取到伺服器當地的時間，造成時間不準確的問題 ","version":"Next","tagName":"h2"},{"title":"製作全域工具包 TimeZone​","type":1,"pageTitle":"👩‍💻 全域工具包 TimeZone","url":"/en/docs/daylily/nestDaylily/dateTimeUtail#製作全域工具包-timezone","content":"先建立一個 clock 的資料夾 src └─user │ └─uuid │ └─clock │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"建立 interface​","type":1,"pageTitle":"👩‍💻 全域工具包 TimeZone","url":"/en/docs/daylily/nestDaylily/dateTimeUtail#建立-interface","content":"在 uuid 資料夾底下，建立一個 clock.service.interface.ts clock └─clock.service.interface.ts  export interface ClockServiceInterface{ /** * 取得 +8 時間 */ getTime():string; }  ","version":"Next","tagName":"h3"},{"title":"建立 service​","type":1,"pageTitle":"👩‍💻 全域工具包 TimeZone","url":"/en/docs/daylily/nestDaylily/dateTimeUtail#建立-service","content":"此處可以使用 nest cli 來建立一個 service nest generate service clock  clock └─clock.service.interface.ts | └─clock.service.ts | └─clock.service.spec.ts  clock.service.spec.ts 是在進行測試使用的 import { Injectable } from '@nestjs/common'; import { ClockServiceInterface } from './clock.service.interface'; @Injectable() export class ClockService implements ClockServiceInterface { /** * 取得標準時間 * @returns */ private getTimeZone(): Date { const utcTime = new Date().getTime() + new Date().getTimezoneOffset() * 60 * 1000; return new Date(utcTime); } /** * 取得 +8 時間 */ getTime(): string { const offset = 8 * 60; // 8小時的分鐘數 const utcTime = this.getTimeZone().getTime(); // 使用 getTimeZone() 取得標準時間 const localTime = new Date(utcTime + offset * 60 * 1000); return localTime.toISOString(); } }  ","version":"Next","tagName":"h3"},{"title":"註冊模組​","type":1,"pageTitle":"👩‍💻 全域工具包 TimeZone","url":"/en/docs/daylily/nestDaylily/dateTimeUtail#註冊模組","content":"先使用 nest cli 建立一個 clock.module.ts nest generate module clock  clock └─clock.service.interface.ts | └─clock.service.ts | └─clock.module.ts | └─clock.service.spec.ts  註冊 clock 服務並且需要做 exports 來上匯出模組使用 @Global() 來表示他是全域的模組 import { Global, Module } from '@nestjs/common'; import { ClockService } from './clock.service'; @Global() @Module({ providers: [ { provide: 'ClockServiceInterface', useClass: ClockService, }, ], exports: [ { provide: 'ClockServiceInterface', useClass: ClockService, }, ], }) export class ClockModule {}  到 app.module.ts 底下註冊 UuidModule import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; import { UuidModule } from './uuid/uuid.module'; import { ClockModule } from './clock/clock.module'; @Module({ imports: [UserModule, UuidModule, ClockModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}  ","version":"Next","tagName":"h3"},{"title":"注意事項​","type":1,"pageTitle":"👩‍💻 全域工具包 TimeZone","url":"/en/docs/daylily/nestDaylily/dateTimeUtail#注意事項","content":"caution 如果直接將 Date 物件，透過 controller 帶給客戶端，那麼客戶端拿到的會是格林威治時間， 所以必須將時間轉換成ISO string或是time stamp ","version":"Next","tagName":"h3"},{"title":"👩‍💻 Exception filter","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/exceptionFilter","content":"","keywords":"","version":"Next"},{"title":"定義​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#定義","content":"","version":"Next","tagName":"h2"},{"title":"關於 Exception​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#關於-exception","content":"exception 指的是程式執行過程中，發生的例外狀況 導致程式沒辦法正確的執行 ","version":"Next","tagName":"h3"},{"title":"關於 filter​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#關於-filter","content":"filter 的生命週期會是，在客戶端 API 發送後，先抵達 controller，接下來才會回到 filter ","version":"Next","tagName":"h3"},{"title":"關於 Exception filter​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#關於-exception-filter","content":"將前面的名詞合併 Exception + filter 這邊的用途是全域例外攔截器，整個系統的例外都會被這邊攔截，並且進行處理 ","version":"Next","tagName":"h3"},{"title":"實作 Exception filter​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#實作-exception-filter","content":"","version":"Next","tagName":"h2"},{"title":"建立目檔案​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#建立目檔案","content":"建立 all-exceptions.filter.ts src └─user │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─all-exceptions.filter.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"建立全域過濾器​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#建立全域過濾器","content":"在全域過濾器中，也自定義了例外拾回傳的格式 import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus, } from '@nestjs/common'; import { HttpAdapterHost } from '@nestjs/core'; @Catch() export class AllExceptionsFilter implements ExceptionFilter { constructor(private readonly httpAdapterHost: HttpAdapterHost) { } catch(exception: unknown, host: ArgumentsHost): void { // In certain situations `httpAdapter` might not be available in the // constructor method, thus we should resolve it here. const { httpAdapter } = this.httpAdapterHost; const ctx = host.switchToHttp(); const msg = exception instanceof Error ? exception.message : 'unknown message'; const httpStatus = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; const responseBody = { statusCode: httpStatus, msg: msg, timestamp: new Date().toISOString(), path: httpAdapter.getRequestUrl(ctx.getRequest()), }; httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus); } }  ","version":"Next","tagName":"h3"},{"title":"註冊全域的過濾器​","type":1,"pageTitle":"👩‍💻 Exception filter","url":"/en/docs/daylily/nestDaylily/exceptionFilter#註冊全域的過濾器","content":"於 app.module.ts 註冊 @Module({ imports: [ InhabitantModule, ], controllers: [AppController], providers: [AppService, { provide: APP_FILTER, useClass: AllExceptionsFilter, } ], }) export class AppModule { }  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 Multi-stage Build","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/multiStageBuild","content":"","keywords":"","version":"Next"},{"title":"為何要使用 Multi-stage Build​","type":1,"pageTitle":"👩‍💻 Multi-stage Build","url":"/en/docs/daylily/nestDaylily/multiStageBuild#為何要使用-multi-stage-build","content":"在直接建立 nest 的 docker image 時， image 至少會 400 多 mb，如果要進行瘦身打包那勢必需要執行此動作 ","version":"Next","tagName":"h2"},{"title":"試做 nest Multi-stage Build​","type":1,"pageTitle":"👩‍💻 Multi-stage Build","url":"/en/docs/daylily/nestDaylily/multiStageBuild#試做-nest-multi-stage-build","content":"","version":"Next","tagName":"h2"},{"title":"dockerfile​","type":1,"pageTitle":"👩‍💻 Multi-stage Build","url":"/en/docs/daylily/nestDaylily/multiStageBuild#dockerfile","content":"此步驟是先使用開發環境進行打包，接下來依靠 pnpm 來安裝生產環境所需要用到的依賴 # development image FROM node:alpine AS development # 建立app目錄 WORKDIR /usr/src/app # 複製依賴檔 COPY package*.json ./ COPY tsconfig*.json ./ # 下載 pnpm RUN npm i -g pnpm # 複製程式碼 COPY . . /usr/src/app/ # 下載依賴 RUN pnpm install -r # 部屬專案 RUN pnpm run build # production image FROM node:alpine AS production # 建立app目錄 WORKDIR /usr/src/app # 複製依賴檔 COPY package.json ./ COPY pnpm-lock.yaml ./ # 下載 pnpm RUN npm i -g pnpm # 下載依賴(只下載需使用的依賴) RUN pnpm install --prod # 複製剛剛打包的檔案 COPY --from=development /usr/src/app/dist ./dist # 啟動服務 CMD [ &quot;node&quot;, &quot;dist/main.js&quot; ]   ref: Multi-stage Build, Miles 梁大哥 github ","version":"Next","tagName":"h3"},{"title":"👩‍💻 Nest CLI 常用指令","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/nestCliCmd","content":"","keywords":"","version":"Next"},{"title":"建立 project​","type":1,"pageTitle":"👩‍💻 Nest CLI 常用指令","url":"/en/docs/daylily/nestDaylily/nestCliCmd#建立-project","content":"nest new [project-name]  ","version":"Next","tagName":"h2"},{"title":"建立 controller​","type":1,"pageTitle":"👩‍💻 Nest CLI 常用指令","url":"/en/docs/daylily/nestDaylily/nestCliCmd#建立-controller","content":"nest generate controller [module name]  ","version":"Next","tagName":"h2"},{"title":"建立 service​","type":1,"pageTitle":"👩‍💻 Nest CLI 常用指令","url":"/en/docs/daylily/nestDaylily/nestCliCmd#建立-service","content":"nest generate service [module name]  ","version":"Next","tagName":"h2"},{"title":"建立 module​","type":1,"pageTitle":"👩‍💻 Nest CLI 常用指令","url":"/en/docs/daylily/nestDaylily/nestCliCmd#建立-module","content":"nest generate module [module name]  ","version":"Next","tagName":"h2"},{"title":"縮寫​","type":1,"pageTitle":"👩‍💻 Nest CLI 常用指令","url":"/en/docs/daylily/nestDaylily/nestCliCmd#縮寫","content":"nest generate 縮寫 nest g  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 NestJS 設定啟動 Port","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/nestStartPort","content":"👩‍💻 NestJS 設定啟動 Port 於檔案 src/main.ts import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3050); } bootstrap(); ","keywords":"","version":"Next"},{"title":"👩‍💻 理解 Nest 的單元測試","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/unitTest","content":"","keywords":"","version":"Next"},{"title":"關於單元測試​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#關於單元測試","content":"在 Nest js 中，預設的測試框架為 Jest 其中提供了 斷言、mock 等等測試功能 ","version":"Next","tagName":"h2"},{"title":"從官網範例理解測試生命週期​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#從官網範例理解測試生命週期","content":"","version":"Next","tagName":"h2"},{"title":"範例程式​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#範例程式","content":"import { CatsController } from './cats.controller'; import { CatsService } from './cats.service'; describe('CatsController', () =&gt; { let catsController: CatsController; let catsService: CatsService; beforeEach(() =&gt; { catsService = new CatsService(); catsController = new CatsController(catsService); }); describe('findAll', () =&gt; { it('should return an array of cats', async () =&gt; { const result = ['test']; jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result); expect(await catsController.findAll()).toBe(result); }); }); });  ","version":"Next","tagName":"h3"},{"title":"生命週期-import​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-import","content":"CatsController 和 CatsService 的匯入：程式碼開頭匯入是被測試的控制器和服務 import { CatsController } from './cats.controller'; import { CatsService } from './cats.service';  ","version":"Next","tagName":"h3"},{"title":"生命週期-describe for class​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-describe-for-class","content":"describe：這是 Jest 測試框架中的函式，用來定義一個測試套件，這個套件專門用來測試 CatsController 類別 describe('CatsController', () =&gt; { });  ","version":"Next","tagName":"h3"},{"title":"生命週期-beforeEach​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-beforeeach","content":"beforeEach：在每個測試案例執行之前，beforeEach 函式會被執行 在這個區塊中，我們建立了一個新的 CatsService 實例，並注入到一個新的 CatsController 實例中  let catsController: CatsController; let catsService: CatsService; beforeEach(() =&gt; { catsService = new CatsService(); catsController = new CatsController(catsService); });  ","version":"Next","tagName":"h3"},{"title":"生命週期-describe for function​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-describe-for-function","content":"describe('findAll', ...)：用它來定義我要測試的函式  describe('findAll', () =&gt; { });  ","version":"Next","tagName":"h3"},{"title":"生命週期-it​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-it","content":"it：他的單位為一個測試案例(test case) it('should return an array of cats', async () =&gt; { });  ","version":"Next","tagName":"h3"},{"title":"生命週期-jest.spyOn​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-jestspyon","content":"jest.spyOn：這是一個 mock，用來做假物件，離掉真實物件的相依性(只專注在該內部邏輯，外部都做隔離) 在這邊預設，catsService 的 findAll 會回傳 ['test'] const result = ['test']; jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result);  ","version":"Next","tagName":"h3"},{"title":"生命週期-expect​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#生命週期-expect","content":"expect：這是斷言語句，它驗證呼叫 catsController.findAll() 方法的結果是否等於我們預期的 result const result = ['test']; jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result); expect(await catsController.findAll()).toBe(result);  經過以上步驟就完成一個單元測試的程式 ","version":"Next","tagName":"h3"},{"title":"名詞回顧​","type":1,"pageTitle":"👩‍💻 理解 Nest 的單元測試","url":"/en/docs/daylily/nestDaylily/unitTest#名詞回顧","content":"名詞\tNUnit 名詞對照\t說明describe (for class)\tTestFixture\t標示為測試類別 beforeEach\tSetUp\t標示為初始化 describe (for function)\tTest or TestCase\t標示測試的函式 it\tTest or TestCase\t測試案例 jest.spyOn\tNSubstitute.Substitute\tmock，用來做假物件，離掉真實物件的相依性 expect\tAssert\t斷言  ref 梁大哥解說 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 NestJS 的 Docker Compose","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/useDockerCompose","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"👩‍💻 NestJS 的 Docker Compose","url":"/en/docs/daylily/nestDaylily/useDockerCompose#環境","content":"NestJsPostgresql ","version":"Next","tagName":"h2"},{"title":"Docker Compose 準備​","type":1,"pageTitle":"👩‍💻 NestJS 的 Docker Compose","url":"/en/docs/daylily/nestDaylily/useDockerCompose#docker-compose-準備","content":"","version":"Next","tagName":"h2"},{"title":"撰寫 dockerfile​","type":1,"pageTitle":"👩‍💻 NestJS 的 Docker Compose","url":"/en/docs/daylily/nestDaylily/useDockerCompose#撰寫-dockerfile","content":"參考 👩‍💻 NestJS 的 dockerfile 撰寫 dockerfile ","version":"Next","tagName":"h3"},{"title":"撰寫 docker-compose.yml​","type":1,"pageTitle":"👩‍💻 NestJS 的 Docker Compose","url":"/en/docs/daylily/nestDaylily/useDockerCompose#撰寫-docker-composeyml","content":"在專案底下建立 docker-compose.yml version: '3.8' services: nest-app: container_name: nest-app build: context: . dockerfile: Dockerfile ports: - &quot;80:3050&quot; depends_on: - postgres environment: POSTGRES_HOST: postgres POSTGRES_PORT: 5432 POSTGRES_USER: postgres POSTGRES_PASSWORD: test123 POSTGRES_DB: [your_database_name] postgres: container_name: postgres12 image: postgres:12.3 environment: POSTGRES_PASSWORD: test123 ports: - &quot;5432:5432&quot;  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"👩‍💻 NestJS 的 Docker Compose","url":"/en/docs/daylily/nestDaylily/useDockerCompose#啟動","content":"docker-compose up  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 NestJS 的 dockerfile","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/writeDockerfile","content":"","keywords":"","version":"Next"},{"title":"建立檔案​","type":1,"pageTitle":"👩‍💻 NestJS 的 dockerfile","url":"/en/docs/daylily/nestDaylily/writeDockerfile#建立檔案","content":"在專案底下建立一個檔案 dockerfile # node image FROM node:18-alpine # 建立app目錄 WORKDIR /usr/src/app # 複製依賴檔 COPY package*.json ./ COPY tsconfig*.json ./ # 複製程式碼 COPY . . # 下載依賴 RUN npm install # 部屬專案 RUN npm run build # 啟動服務 CMD [ &quot;node&quot;, &quot;dist/main.js&quot; ]  在專案底下建立一個檔案 .dockerignore，來過濾用不到的檔案 dockerfile .dockerignore node_modules npm-debug.log dist  ","version":"Next","tagName":"h2"},{"title":"建立 image​","type":1,"pageTitle":"👩‍💻 NestJS 的 dockerfile","url":"/en/docs/daylily/nestDaylily/writeDockerfile#建立-image","content":"docker build -t nest-app .  ","version":"Next","tagName":"h2"},{"title":"啟動 nest 容器​","type":1,"pageTitle":"👩‍💻 NestJS 的 dockerfile","url":"/en/docs/daylily/nestDaylily/writeDockerfile#啟動-nest-容器","content":"docker run -p 80:3050 nest-app  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 使用 sqldeveloper 連接","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/connectBydev","content":"","keywords":"","version":"Next"},{"title":"下載與預先準備​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#下載與預先準備","content":"","version":"Next","tagName":"h2"},{"title":"SQL Developer​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#sql-developer","content":"連結 ","version":"Next","tagName":"h3"},{"title":"oracle11g​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#oracle11g","content":"安裝步驟 ","version":"Next","tagName":"h3"},{"title":"連線​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#連線","content":"","version":"Next","tagName":"h2"},{"title":"1. 新增連線​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#1-新增連線","content":"點選 UI 左側選單的 +填寫以下資訊 Name: oracle11g-docker (可自行定義) 使用者名稱: system 使用者密碼: **** 主機名稱: localhost (或是其他主機ID) 連接埠: 1521 SID: xe ","version":"Next","tagName":"h3"},{"title":"2. 測試連線​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#2-測試連線","content":"點選測試按鈕 畫面顯示連線成功即可 ","version":"Next","tagName":"h3"},{"title":"3. 連線​","type":1,"pageTitle":"👩‍💻 使用 sqldeveloper 連接","url":"/en/docs/daylily/oracleDaylily/connectBydev#3-連線","content":"點選連線按鈕 即可連上資料庫  ref: Docker中安装Oracle-12c ","version":"Next","tagName":"h3"},{"title":"👩‍💻 建立 user","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/createUser","content":"","keywords":"","version":"Next"},{"title":"查詢使用者​","type":1,"pageTitle":"👩‍💻 建立 user","url":"/en/docs/daylily/oracleDaylily/createUser#查詢使用者","content":"SELECT * FROM all_users WHERE username = 'user';  ","version":"Next","tagName":"h2"},{"title":"建立使用者​","type":1,"pageTitle":"👩‍💻 建立 user","url":"/en/docs/daylily/oracleDaylily/createUser#建立使用者","content":"CREATE USER user IDENTIFIED BY [user password];  ","version":"Next","tagName":"h2"},{"title":"授權使用者​","type":1,"pageTitle":"👩‍💻 建立 user","url":"/en/docs/daylily/oracleDaylily/createUser#授權使用者","content":"GRANT CREATE TABLE TO user;  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 刪除資料表","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/dropTable","content":"","keywords":"","version":"Next"},{"title":"刪除​","type":1,"pageTitle":"👩‍💻 刪除資料表","url":"/en/docs/daylily/oracleDaylily/dropTable#刪除","content":"DROP TABLE [schema].[table];  ","version":"Next","tagName":"h2"},{"title":"完全刪除​","type":1,"pageTitle":"👩‍💻 刪除資料表","url":"/en/docs/daylily/oracleDaylily/dropTable#完全刪除","content":"使用 PURGE 完全刪除 table 無法進行 rollback DROP TABLE [schema].[table] PURGE;  ","version":"Next","tagName":"h2"},{"title":"移除約束​","type":1,"pageTitle":"👩‍💻 刪除資料表","url":"/en/docs/daylily/oracleDaylily/dropTable#移除約束","content":"如果 Table 有約束條件時，直接執行 DROP 會跳出錯誤 加了 CASCADE CONSTRAINTS 才能正常移除 DROP TABLE [schema].[table] CASCADE CONSTRAINTS;  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 使用 TypeORM","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/useTypeorm","content":"","keywords":"","version":"Next"},{"title":"關於​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#關於","content":"TypeORM: 支援 Typescript 型別宣告的 Nodejs ORM 框架 ","version":"Next","tagName":"h2"},{"title":"DataSource​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#datasource","content":"是一個用來管理與資料庫連線的重要元件，在應用程式啟動時建立連線池，在關閉應用程式時關閉連線池 在 Nestjs 應用程式中，這些工作都可以由元件管理器自動處理，無需手動設定 ","version":"Next","tagName":"h3"},{"title":"Migration​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#migration","content":"Migration 預設如果 synchronized 設定成 true，就會自動更新資料表為當下 Entity 格式，適合用來做資料庫遷移 ","version":"Next","tagName":"h3"},{"title":"使用 TypeORM​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#使用-typeorm","content":"","version":"Next","tagName":"h2"},{"title":"安裝套件​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#安裝套件","content":"pnpm add @nestjs/config pnpm add @nestjs/typeorm typeorm pg pnpm add joi pnpm add dotenv  ","version":"Next","tagName":"h3"},{"title":"設定資料庫連線​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#設定資料庫連線","content":"先 import 需要的依賴 import { ConfigModule, ConfigService } from '@nestjs/config'; import { TypeOrmModule } from '@nestjs/typeorm'; import * as Joi from 'joi';  於 app.module.ts 設定連線 import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { ConfigModule, ConfigService } from '@nestjs/config'; import { TypeOrmModule } from '@nestjs/typeorm'; import * as Joi from 'joi'; @Module({ imports: [ ConfigModule.forRoot({ isGlobal: true, validationSchema: Joi.object({ DB_URI: Joi.string().required(), IS_DB_SSL_MODE: Joi.boolean().required(), }), }), TypeOrmModule.forRootAsync({ useFactory(configService: ConfigService) { const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); return { ssl: IS_DB_SSL_MODE, // 是否要使用 ssl 連線，一般正式連線會啟用 extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, poolSize: 5, idleTimeoutMillis: 3600000, }, type: 'postgres',//連線資料庫的類型 url: configService.getOrThrow('DB_URI', ''), synchronize: false,//否自動同步 entity 到資料庫 table autoLoadEntity: true//是否自動載入 Entity 到 forRoot TypeORM }; }, inject: [ConfigService], }), ], controllers: [AppController], providers: [AppService], }) export class AppModule { }  ","version":"Next","tagName":"h3"},{"title":"加入 Entity​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#加入-entity","content":"於 inhabitant 目錄底下，建立一個檔案為 inhabitant.entity.ts src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn, } from 'typeorm'; @Entity('inhabitant', { schema: 'public' }) export class InhabitantEntity { @PrimaryGeneratedColumn('uuid') id: string; @Column({ name: 'idCard', type: 'nvarchar', length: 128 }) idCard: string; @Column({ name: 'name', type: 'nvarchar', length: 20 }) name: string; @Column({ name: 'hungry', type: 'int' }) hungry: number; @Column({ name: 'occupation', type: 'nvarchar', length: 10 }) occupation: string; @Column({ name: 'age', type: 'int' }) age: number; @Column({ name: 'money', type: 'int' }) money: number; @Column({ name: 'ban', type: 'boolean' }) ban: boolean; @CreateDateColumn({ name: 'create_time', type: 'datetime' }) create_time: Date; @UpdateDateColumn({ name: 'update_time', type: 'timestamp without time zone' }) update_time: Date; @Column({ name: 'update_user_id', type: 'nvarchar', length: 128 }) update_user_id: string; }  註冊 Entity nest generate module inhabitant  ","version":"Next","tagName":"h3"},{"title":"設定資料庫轉移​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#設定資料庫轉移","content":"新增 typeorm.migration.ts src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─main.ts  import { ConfigService } from '@nestjs/config'; import { config } from 'dotenv'; import { DataSource } from 'typeorm'; config(); const configService = new ConfigService(); const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); export default new DataSource({ type: 'postgres', url: configService.get&lt;string&gt;('DB_URI', ''), ssl: IS_DB_SSL_MODE, extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, }, migrations: ['src/migrations/*.ts'], migrationsRun: true, entities: ['**/*.entity.ts'], });  新增 .env src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─.env │ └─main.ts  DB_URI=postgresql://${db_username}:${db_password}@${db_hostname}:${db_port}/${db_name}  ","version":"Next","tagName":"h3"},{"title":"新增 script​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#新增-script","content":"於 package.js 新增 script &quot;typeorm&quot;: &quot;ts-node ./node_modules/typeorm/cli&quot;, &quot;schema:sync&quot;: &quot;pnpm run typeorm schema:sync -d src/typeorm.migration.ts&quot;, &quot;schema:drop&quot;: &quot;pnpm run typeorm schema:drop -d src/typeorm.migration.ts&quot;, &quot;schema:log&quot;: &quot;pnpm run typeorm schema:log -d src/typeorm.migration.ts&quot;, &quot;typeorm:show&quot;: &quot;pnpm run typeorm migration:show -d src/typeorm.migration.ts&quot;, &quot;typeorm:run-migrations&quot;: &quot;pnpm run typeorm -- migration:run -d src/typeorm.migration.ts&quot;, &quot;typeorm:create-migration&quot;: &quot;npm run typeorm -- migration:create src/migrations/$npm_config_name&quot;, &quot;typeorm:generate-migration&quot;: &quot;npm run typeorm -- migration:generate -d src/typeorm.migration.ts src/migrations/$npm_config_name&quot;, &quot;typeorm:revert-migration&quot;: &quot;pnpm run typeorm migration:revert -d src/typeorm.migration.ts&quot;  在 windows 底下 &quot;typeorm:create-migration&quot;: &quot;npm run typeorm -- migration:create src/migrations/$npm_config_name&quot;,  需換成 &quot;typeorm:create-migration&quot;: &quot;npm run typeorm -- migration:create src/migrations/%npm_config_name%&quot;,  ","version":"Next","tagName":"h3"},{"title":"新增 migration​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#新增-migration","content":"npm run typeorm:create-migration --name=INHABITANT  import { MigrationInterface, QueryRunner, Table, TableColumn, TableForeignKey } from &quot;typeorm&quot;; export class INHABITANT1695957121944 implements MigrationInterface { public async up(queryRunner: QueryRunner): Promise&lt;void&gt; { await queryRunner.createTable(new Table({ name: &quot;inhabitant&quot;, schema: &quot;public&quot;, columns: [ { name: &quot;id&quot;, type: &quot;uuid&quot;, isPrimary: true, generationStrategy: &quot;uuid&quot;, default: &quot;uuid_generate_v4()&quot;, }, { name: &quot;idCard&quot;, type: &quot;nvarchar&quot;, length: &quot;128&quot;, }, { name: &quot;name&quot;, type: &quot;nvarchar&quot;, length: &quot;20&quot;, }, { name: &quot;hungry&quot;, type: &quot;int&quot;, }, { name: &quot;occupation&quot;, type: &quot;nvarchar&quot;, length: &quot;10&quot;, }, { name: &quot;age&quot;, type: &quot;int&quot;, }, { name: &quot;money&quot;, type: &quot;int&quot;, }, { name: &quot;ban&quot;, type: &quot;boolean&quot;, }, { name: &quot;create_time&quot;, type: &quot;datetime&quot;, }, { name: &quot;update_time&quot;, type: &quot;timestamp without time zone&quot;, }, { name: &quot;update_user_id&quot;, type: &quot;nvarchar&quot;, length: &quot;128&quot;, }, ], }), true); } public async down(queryRunner: QueryRunner): Promise&lt;void&gt; { await queryRunner.dropTable(&quot;inhabitant&quot;, true, true, true); } }  ","version":"Next","tagName":"h3"},{"title":"新增 schema​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#新增-schema","content":"pnpm run typeorm:run-migrations  此時就能看到資料庫長出表格了 ","version":"Next","tagName":"h3"},{"title":"REF​","type":1,"pageTitle":"👩‍💻 使用 TypeORM","url":"/en/docs/daylily/nestDaylily/useTypeorm#ref","content":"副鎮長-梁迪哥 教學 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 資料表授權","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/grantUser","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"👩‍💻 資料表授權","url":"/en/docs/daylily/oracleDaylily/grantUser#說明","content":"將資料表授權給某個使用者，可由此指令進行 ","version":"Next","tagName":"h2"},{"title":"流程​","type":1,"pageTitle":"👩‍💻 資料表授權","url":"/en/docs/daylily/oracleDaylily/grantUser#流程","content":"","version":"Next","tagName":"h2"},{"title":"1. 授權​","type":1,"pageTitle":"👩‍💻 資料表授權","url":"/en/docs/daylily/oracleDaylily/grantUser#1-授權","content":"此處將 Order 資料表授權給 AP_User 使用 GRANT SELECT ON [schema].Order TO AP_User;  ","version":"Next","tagName":"h3"},{"title":"2. 確認​","type":1,"pageTitle":"👩‍💻 資料表授權","url":"/en/docs/daylily/oracleDaylily/grantUser#2-確認","content":"使用 AP_User 進行連線，確認是否可以連線成功 SELECT * FROM [schema].Order  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 單元測試 mock","type":0,"sectionRef":"#","url":"/en/docs/daylily/nestDaylily/unitTestMock","content":"","keywords":"","version":"Next"},{"title":"關於 mock​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#關於-mock","content":"單元測試中難免需要做到資料隔離，確保我每次執行都保持一致的結果 mock 就是不屬於這個測試範圍外的服務，進行虛擬化 ","version":"Next","tagName":"h2"},{"title":"進行邏輯測試​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#進行邏輯測試","content":"目前目錄結構 src └─user │ └─uuid │ └─error-check │ └─clock │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  目前 user 資料夾目錄結構 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  ","version":"Next","tagName":"h2"},{"title":"拆分邏輯層與資料層​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#拆分邏輯層與資料層","content":"新增 user.repository.ts 與 user.repository.interface.ts user └─dto │ └─interface │ └─user.service.interface.ts │ │ │ └─user.repository.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.repository.ts │ └─user.module.ts  先定義 介面 import { UpdateUserDto, CreateUserDto, UserDto } from '../dto'; export interface UserRepositoryInterface { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ getByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ getById(id: string): Promise&lt;UserDto&gt;; /** 新增使用者 * * @param newUser new user * @param userId update user id * @returns new user list */ createUser(newUser: CreateUserDto, userId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /**更新使用者 * * @param id user id * @param oldUser edit user * @param userId update user id * @returns user list */ updaterUser( id: string, oldUser: UpdateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt;; /**刪除使用者 * * @param id user id * @returns user list */ deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt;; }  ","version":"Next","tagName":"h3"},{"title":"註冊 repository​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#註冊-repository","content":"user.module.ts import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; import { UserRepository } from './user.repository'; @Module({ controllers: [UserController], providers: [ { provide: 'UserServiceInterface', useClass: UserService, }, { provide: 'UserRepositoryInterface', useClass: UserRepository, }, ], }) export class UserModule {}  ","version":"Next","tagName":"h3"},{"title":"先寫測試​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#先寫測試","content":"","version":"Next","tagName":"h2"},{"title":"測試前置​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#測試前置","content":"宣告會用到的服務 caution import { ErrorCheckModule } from '../error-check/error-check.module'; 由於路徑並沒有跟 user.service.spec.ts 同一層，因此需要使用 ../ 否則測試運行時會吃不到檔案 import { Test, TestingModule } from '@nestjs/testing'; import { UserService } from './user.service'; import { UserDto } from './dto'; import { ErrorCheckModule } from '../error-check/error-check.module'; describe('UserService', () =&gt; { let userService: UserService; let users: Array&lt;UserDto&gt;; });  ","version":"Next","tagName":"h3"},{"title":"進行模組註冊​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#進行模組註冊","content":"將有用到的外部服務 ErrorCheckModule, UserRepository 進行註冊 caution UserRepositoryInterface 需要使用 useValue 來為這個介面提供假物件 /** 上略 */ describe('UserService', () =&gt; { let userService: UserService; let userRepository: UserRepositoryInterface; let errorCheckService: ErrorCheckServiceInterface; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ imports:[ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn(), getById: jest.fn(), createUser: jest.fn(), updaterUser: jest.fn(), deleteUser: jest.fn(), }, } ], }).compile(); }); });  ","version":"Next","tagName":"h3"},{"title":"實例化服務​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#實例化服務","content":"將服務從 IOC 中取出，並賦值給物件 /** 上略 */ describe('UserService', () =&gt; { let userService: UserService; let userRepository: UserRepositoryInterface; let errorCheckService: ErrorCheckServiceInterface; let users: Array&lt;UserDto&gt;; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ imports:[ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn(), getById: jest.fn(), createUser: jest.fn(), updaterUser: jest.fn(), deleteUser: jest.fn(), }, } ], }).compile(); userService = module.get&lt;UserService&gt;(UserService); }); });  ","version":"Next","tagName":"h3"},{"title":"傳寫測試用假物件與資料​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#傳寫測試用假物件與資料","content":"將服務從 IOC 中取出，並賦值給物件 /** 上略 */ describe('UserService', () =&gt; { let userService: UserService; let users: Array&lt;UserDto&gt;; beforeEach(async () =&gt; { users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); const module: TestingModule = await Test.createTestingModule({ imports:[ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn((storeId) =&gt; { // 在這裡模擬 getByStoreId 方法的行為 if (storeId === 'validStoreId') { return Promise.resolve(users); } else { return Promise.resolve([]); // 返回一個空陣列作為模擬 } }), getById: jest.fn((id) =&gt; { return Promise.resolve(users.find((x) =&gt; x.id === id)); }), createUser: jest.fn((newUser, userId) =&gt; { users.push({ id: '99999999-37b5-4977-bffc-5afc5db99123', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); return Promise.resolve(users); }), updaterUser: jest.fn((id, oldUser, userId) =&gt; { let data = users.find((x) =&gt; x.id === id); data.fullName = oldUser.fullName; data.email = oldUser.email; data.phoneNumber = oldUser.phoneNumber; data.userName = oldUser.userName; return Promise.resolve(users); }), deleteUser: jest.fn((id) =&gt; { users = users.filter((x) =&gt; x, id !== id); return Promise.resolve(users); }), }, } ], }).compile(); userService = module.get&lt;UserService&gt;(UserService); }); });  ","version":"Next","tagName":"h3"},{"title":"撰寫測試劇情​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#撰寫測試劇情","content":"","version":"Next","tagName":"h2"},{"title":"需求: 取得商店使用者​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#需求-取得商店使用者","content":"需求: 我需要透過商店 id 來取得，屬於這家店的使用者 測試劇情1 : 傳入正確的商店 id，就可以得到屬於這家店的使用者 測試劇情2 : 傳入不存在的商店 id，會得到一個空陣列 測試劇情3 : 傳入空的字串，會跳出例外 測試劇情4 : 傳入空的字串，會跳出例外  describe('getUserByStoreId', () =&gt; { // case1 it('store id is validStoreId, return users list', async () =&gt; { const storeId = 'validStoreId'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual(users); }); // case2 it('store id is store123, return []', async () =&gt; { const storeId = 'store123'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual([]); }); // case3 it(&quot;store id is '', throw exception data cant not empty&quot;, async () =&gt; { const storeId = ''; const expectedError = new Error('storeId,資料不能為空或未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); // case4 it('store id is undefined, throw exception data is undefined', async () =&gt; { const storeId = undefined; const expectedError = new Error('storeId,資料未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); });  ","version":"Next","tagName":"h3"},{"title":"測試細節​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#測試細節","content":"toStrictEqual : 用來比對陣列，是否符合預期測試例外 先定義例外的訊息會回傳什麼接下來執行斷言toThrow : 用來比對例外訊息是否為預期結果 caution 測試過程要注意非同步的問題，如果是非同步執行，需要進行 await  const expectedError = new Error('storeId,資料不能為空或未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError);  caution 為什麼測試例外的 expect(async () =&gt;{...}) 需要用到箭頭函式呢? 主要的原因在於，會需要用到物件本身的 ref ，才不會導致 this 指向 caller ","version":"Next","tagName":"h3"},{"title":"執行測試​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#執行測試","content":"pnpm test:watch src/user/user.service.spec.ts  ","version":"Next","tagName":"h3"},{"title":"測試結果​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#測試結果","content":" PASS src/user/user.service.spec.ts UserService √ should be defined (28 ms) getUserByStoreId √ store id is validStoreId, return users list (8 ms) √ store id is store123, return [] (3 ms) √ store id is '', throw exception data cant not empty (15 ms) √ store id is undefined, throw exception data is undefined (4 ms) Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Test Suites: 1 passed, 1 total Tests: 5 passed, 5 total Snapshots: 0 total Time: 5.932 s, estimated 11 s   ","version":"Next","tagName":"h3"},{"title":"完整測試程式碼​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#完整測試程式碼","content":"import { Test, TestingModule } from '@nestjs/testing'; import { UserService } from './user.service'; import { UserDto } from './dto'; import { ErrorCheckModule } from '../error-check/error-check.module'; describe('UserService', () =&gt; { let userService: UserService; let users: Array&lt;UserDto&gt;; beforeEach(async () =&gt; { users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); const module: TestingModule = await Test.createTestingModule({ imports: [ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn((storeId) =&gt; { // 在這裡模擬 getByStoreId 方法的行為 if (storeId === 'validStoreId') { return Promise.resolve(users); } else { return Promise.resolve([]); // 返回一個空陣列作為模擬 } }), getById: jest.fn((id) =&gt; { return Promise.resolve(users.find((x) =&gt; x.id === id)); }), createUser: jest.fn((newUser, userId) =&gt; { users.push({ id: '99999999-37b5-4977-bffc-5afc5db99123', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); return Promise.resolve(users); }), updaterUser: jest.fn((id, oldUser, userId) =&gt; { const data = users.find((x) =&gt; x.id === id); data.fullName = oldUser.fullName; data.email = oldUser.email; data.phoneNumber = oldUser.phoneNumber; data.userName = oldUser.userName; return Promise.resolve(users); }), deleteUser: jest.fn((id) =&gt; { users = users.filter((x) =&gt; x, id !== id); return Promise.resolve(users); }), }, }, ], }).compile(); userService = module.get&lt;UserService&gt;(UserService); }); it('should be defined', () =&gt; { expect(userService).toBeDefined(); }); describe('getUserByStoreId', () =&gt; { // case1 it('store id is validStoreId, return users list', async () =&gt; { const storeId = 'validStoreId'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual(users); }); // case2 it('store id is store123, return []', async () =&gt; { const storeId = 'store123'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual([]); }); // case3 it(&quot;store id is '', throw exception data cant not empty&quot;, async () =&gt; { const storeId = ''; const expectedError = new Error('storeId,資料不能為空或未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); // case4 it('store id is undefined, throw exception data is undefined', async () =&gt; { const storeId = undefined; const expectedError = new Error('storeId,資料未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); }); });   ","version":"Next","tagName":"h2"},{"title":"REF​","type":1,"pageTitle":"👩‍💻 單元測試 mock","url":"/en/docs/daylily/nestDaylily/unitTestMock#ref","content":"梁大哥教學 ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Insert Into","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/insertInto","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"👩‍💻 Insert Into","url":"/en/docs/daylily/oracleDaylily/insertInto#說明","content":"如果需要將某個資料表格，從 schemaA 抄寫到 schemaB ，就可用到這個語法 ","version":"Next","tagName":"h2"},{"title":"流程​","type":1,"pageTitle":"👩‍💻 Insert Into","url":"/en/docs/daylily/oracleDaylily/insertInto#流程","content":"","version":"Next","tagName":"h2"},{"title":"1. 於 schemaB 建立表格​","type":1,"pageTitle":"👩‍💻 Insert Into","url":"/en/docs/daylily/oracleDaylily/insertInto#1-於-schemab-建立表格","content":"需要建立一張與 schemaA 一模一樣的表格此處以 User 為例 create table User ( NAME VARCHAR(10), LM_USER VARCHAR(10), LM_TIME TIMESTAMP ) tablespace schemaB_T  ","version":"Next","tagName":"h3"},{"title":"2. 進行抄寫​","type":1,"pageTitle":"👩‍💻 Insert Into","url":"/en/docs/daylily/oracleDaylily/insertInto#2-進行抄寫","content":"insert into schemaB.User (select * from schemaA.User);  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 Docker 中安裝 Oracle","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/setIndocker","content":"","keywords":"","version":"Next"},{"title":"安裝版本​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Oracle","url":"/en/docs/daylily/oracleDaylily/setIndocker#安裝版本","content":"Oracle: 11gImage: oracleinanutshell/oracle-xe-11gOS: Windows11 ","version":"Next","tagName":"h2"},{"title":"安裝步驟​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Oracle","url":"/en/docs/daylily/oracleDaylily/setIndocker#安裝步驟","content":"","version":"Next","tagName":"h2"},{"title":"1. 下載Image​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Oracle","url":"/en/docs/daylily/oracleDaylily/setIndocker#1-下載image","content":"搜尋 Oracle Image docker search oracle  可以看到以下資訊 NAME DESCRIPTION STARS OFFICIAL AUTOMATED oraclelinux Official Docker builds of Oracle Linux. 1009 [OK] kasmweb/oracle-8-desktop Oracle Linux 8 desktop for Kasm Workspaces 3 kasmweb/oracle-7-desktop Oracle Linux 7 desktop for Kasm Workspaces 1 kasmweb/oracle-9-desktop Oracle 9 desktop for Kasm Workspaces 0 dokken/oraclelinux-7 Oracle Linux 7 image for kitchen-dokken 1 dokken/oraclelinux-6 Oracle Linux 6 image for kitchen-dokken 0 dokken/oraclelinux-9 Oracle Linux 9 image for use with Test Kitch… 0 paketobuildpacks/oracle 0 dokken/oraclelinux-8 1 vulhub/oracle 0 kasmweb/core-oracle-8 Oracle Linux 8 base image for Kasm Workspace… 1 kasmweb/core-oracle-7 Oracle Linux 7 base image for Kasm Workspace… 1 kasmweb/core-oracle-9 Oracle Linux 9 base image for Kasm Workspace… 0 dockette/adminer My most tiniest (10mb) Adminer image with su… 20 [OK] dockette/mvn My MVN 3 based on Oracle Java Dockerfile 4 [OK] redislabs/redis-connect-oracle Redis Connect Oracle Connector for Continuou… 1 dockette/jdk8 My Oracle Java 8 Dockerfile 4 [OK] sismics/debian-java Debian Jessy + Oracle JDK 1 oracleinanutshell/oracle-xe-11g 277 oraclecoherence/coherence-ce Coherence Community Edition 5 oracledb19c/oracle.19.3.0-ee 31 oracledemo1/hello-world Test docker build from github 0 [OK] gvenzl/oracle-xe Oracle Database XE (21c, 18c, 11g) for every… 232 iamseth/oracledb_exporter A Prometheus exporter for Oracle modeled aft… 7 18fgsa/oracle-client Hosted version of the Oracle Container Image… 2  下載 docker pull oracleinanutshell/oracle-xe-11g  ","version":"Next","tagName":"h3"},{"title":"2. 啟動容器​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Oracle","url":"/en/docs/daylily/oracleDaylily/setIndocker#2-啟動容器","content":"建立容器，並將 port 做對應 docker run -d -p 2122:22 -p 9090:8080 -p 1521:1521 --name oracle-11g oracleinanutshell/oracle-xe-11g  ","version":"Next","tagName":"h3"},{"title":"3. 設定 oracle 帳號密碼​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Oracle","url":"/en/docs/daylily/oracleDaylily/setIndocker#3-設定-oracle-帳號密碼","content":"進入容器 docker exec -it oracle-11g /bin/bash  切換權限 su oracle  開啟 sqlplus $ORACLE_HOME/bin/sqlplus / as sysdba  將密碼期限調整為永不過期 ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;  解鎖 system 權限 alter user SYSTEM account unlock;  ","version":"Next","tagName":"h3"},{"title":"預設帳號密碼​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Oracle","url":"/en/docs/daylily/oracleDaylily/setIndocker#預設帳號密碼","content":"使用者名稱: system 使用者密碼: oracle  ref: Docker中安装Oracle-12c ","version":"Next","tagName":"h2"},{"title":"👩‍💻 建立 tablespace","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/tableSpace","content":"","keywords":"","version":"Next"},{"title":"檢查 table space 是否存在​","type":1,"pageTitle":"👩‍💻 建立 tablespace","url":"/en/docs/daylily/oracleDaylily/tableSpace#檢查-table-space-是否存在","content":"SELECT [tablespace_name] FROM dba_tablespaces WHERE tablespace_name = '[tablespace name]';  ","version":"Next","tagName":"h2"},{"title":"新增 table space​","type":1,"pageTitle":"👩‍💻 建立 tablespace","url":"/en/docs/daylily/oracleDaylily/tableSpace#新增-table-space","content":"CREATE TABLESPACE tablespace_name DATAFILE 'path_to_datafile.dbf' SIZE 100M;  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 日期查詢","type":0,"sectionRef":"#","url":"/en/docs/daylily/oracleDaylily/whereDateTime","content":"","keywords":"","version":"Next"},{"title":"大於某個時間點​","type":1,"pageTitle":"👩‍💻 日期查詢","url":"/en/docs/daylily/oracleDaylily/whereDateTime#大於某個時間點","content":"SELECT * FROM MY_TABLE WHERE CREATE_TIME &gt; TO_DATE('2023-08-09 16:32', 'YYYY-MM-DD HH24:MI');  ","version":"Next","tagName":"h2"},{"title":"兩個時間點之間​","type":1,"pageTitle":"👩‍💻 日期查詢","url":"/en/docs/daylily/oracleDaylily/whereDateTime#兩個時間點之間","content":"SELECT * FROM MY_TABLE WHERE CREATE_TIME BETWEEN TO_DATE('2023-08-01', 'YYYY-MM-DD') AND TO_DATE('2023-08-09', 'YYYY-MM-DD');  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 使用 DBeaver 連接","type":0,"sectionRef":"#","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver","content":"","keywords":"","version":"Next"},{"title":"下載與預先準備​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#下載與預先準備","content":"","version":"Next","tagName":"h2"},{"title":"DBeaver​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#dbeaver","content":"連結 ","version":"Next","tagName":"h3"},{"title":"Postgresql​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#postgresql","content":"安裝步驟 ","version":"Next","tagName":"h3"},{"title":"連線​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#連線","content":"","version":"Next","tagName":"h2"},{"title":"1. 新增連線​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#1-新增連線","content":"Ctrl + Shift + NPostgresql下載相關 jar Host: localhost Port: 5432 Database: postgres UserName: postgres ","version":"Next","tagName":"h3"},{"title":"2. 測試連線​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#2-測試連線","content":"點選測試按鈕 畫面顯示連線成功即可 ","version":"Next","tagName":"h3"},{"title":"3. 連線​","type":1,"pageTitle":"👩‍💻 使用 DBeaver 連接","url":"/en/docs/daylily/postgreDaylily/connectByDBeaver#3-連線","content":"點選連線按鈕 即可連上資料庫 ","version":"Next","tagName":"h3"},{"title":"👩‍💻 生命週期","type":0,"sectionRef":"#","url":"/en/docs/daylily/vueDaylily/compositionAPI/compositionAPILife","content":"","keywords":"","version":"Next"},{"title":"關於​","type":1,"pageTitle":"👩‍💻 生命週期","url":"/en/docs/daylily/vueDaylily/compositionAPI/compositionAPILife#關於","content":"當談到 Vue.js 的 Composition API 生命週期時，我們需要理解在使用 Composition API 時，如何管理組件的生命週期事件， Composition API 是 Vue 3 中引入的一個新的 API，它允許我們更靈活地組織和重用代碼，但它的生命週期管理方式與以前的選項 API 有所不同 ","version":"Next","tagName":"h2"},{"title":"生命週期​","type":1,"pageTitle":"👩‍💻 生命週期","url":"/en/docs/daylily/vueDaylily/compositionAPI/compositionAPILife#生命週期","content":"","version":"Next","tagName":"h2"},{"title":"起始點​","type":1,"pageTitle":"👩‍💻 生命週期","url":"/en/docs/daylily/vueDaylily/compositionAPI/compositionAPILife#起始點","content":"程式的進入點會從 setup 開始執行 export default { setup() { return {}; }, };  ","version":"Next","tagName":"h3"},{"title":"props​","type":1,"pageTitle":"👩‍💻 生命週期","url":"/en/docs/daylily/vueDaylily/compositionAPI/compositionAPILife#props","content":"在 Composition API 中，可以使用 props 開始處理從父級組件 (上層組件) 傳遞過來的屬性， 這是通過 setup 函數的第一個參數來實現的 例如，如果組件接收一個名為 title 的 prop export default { props: { title: String, }, setup(props) { // 進行解構 const {title} = props; return { title }; }, };  ","version":"Next","tagName":"h3"},{"title":"data 與 ref​","type":1,"pageTitle":"👩‍💻 生命週期","url":"/en/docs/daylily/vueDaylily/compositionAPI/compositionAPILife#data-與-ref","content":"Composition API 引入了 ref 函數，用於創建具有響應式能力的數據 可以將 ref 函數用於組件內部的數據 import { ref } from 'vue'; export default { setup() { const count = ref(0); // 在模板中使用 count.value 來訪問數據 return { count, }; }, };  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 Lifecycle Hooks","type":0,"sectionRef":"#","url":"/en/docs/daylily/vueDaylily/compositionAPI/lifecycleHooks","content":"","keywords":"","version":"Next"},{"title":"生命週期 Hooks（Lifecycle Hooks）​","type":1,"pageTitle":"👩‍💻 Lifecycle Hooks","url":"/en/docs/daylily/vueDaylily/compositionAPI/lifecycleHooks#生命週期-hookslifecycle-hooks","content":"在 Composition API 中，我們可以使用 onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount 等生命週期鉤子，來執行組件生命週期中的操作 這些鉤子允許我們在不同階段的生命週期中添加自定義邏輯 ","version":"Next","tagName":"h2"},{"title":"常見的 Lifecycle Hooks​","type":1,"pageTitle":"👩‍💻 Lifecycle Hooks","url":"/en/docs/daylily/vueDaylily/compositionAPI/lifecycleHooks#常見的-lifecycle-hooks","content":"onBeforeMount：在組件即將被掛載到 DOM 前執行onMounted：在組件被掛載到 DOM 後執行onBeforeUpdate：在組件即將更新前執行onUpdated：在組件更新完成後執行onBeforeUnmount：在組件即將被卸載前執行 這些生命週期鉤子可以通過 import 的方式引入，然後在組件中使用 import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount } from 'vue'; export default { setup() { onBeforeMount(() =&gt; { // 在組件即將被掛載到 DOM 前執行的邏輯 }); onMounted(() =&gt; { // 在組件被掛載到 DOM 後執行的邏輯 }); onBeforeUpdate(() =&gt; { // 在組件即將更新前執行的邏輯 }); onUpdated(() =&gt; { // 在組件更新完成後執行的邏輯 }); onBeforeUnmount(() =&gt; { // 在組件即將被卸載前執行的邏輯 }); // 其他 Composition API 邏輯 return {}; }, };  ","version":"Next","tagName":"h2"},{"title":"👩‍💻 Docker 中安裝 Postgresql","type":0,"sectionRef":"#","url":"/en/docs/daylily/postgreDaylily/setIndocker","content":"","keywords":"","version":"Next"},{"title":"安裝版本​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Postgresql","url":"/en/docs/daylily/postgreDaylily/setIndocker#安裝版本","content":"Postgresql: 12.3Image: postgres:12.3OS: Windows11 ","version":"Next","tagName":"h2"},{"title":"安裝步驟​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Postgresql","url":"/en/docs/daylily/postgreDaylily/setIndocker#安裝步驟","content":"","version":"Next","tagName":"h2"},{"title":"1. 下載Image​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Postgresql","url":"/en/docs/daylily/postgreDaylily/setIndocker#1-下載image","content":"下載 docker pull postgres:12.3  ","version":"Next","tagName":"h3"},{"title":"2. 啟動容器​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Postgresql","url":"/en/docs/daylily/postgreDaylily/setIndocker#2-啟動容器","content":"建立容器，並將 port 做對應 docker run --name postgres12 -e POSTGRES_PASSWORD=[password] -p 5432:5432 -d postgres:12.3  ","version":"Next","tagName":"h3"},{"title":"3. 設定 Postgresql 帳號密碼​","type":1,"pageTitle":"👩‍💻 Docker 中安裝 Postgresql","url":"/en/docs/daylily/postgreDaylily/setIndocker#3-設定-postgresql-帳號密碼","content":"進入容器 docker exec -it postgres12 /bin/bash  切換權限 su postgres  建立角色 createuser -P -s -e [user]  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 FastAPI + Tortoise ORM","type":0,"sectionRef":"#","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#說明","content":"FastAPI: python 的 webAPI 框架Tortoise ORM: python 的 ORMDatabase: 使用SQLite部屬: docker ","version":"Next","tagName":"h2"},{"title":"建置​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#建置","content":"","version":"Next","tagName":"h2"},{"title":"1. 建置FastAPI​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#1-建置fastapi","content":" pip install fastapi  ","version":"Next","tagName":"h3"},{"title":"2. 建置虛擬機​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#2-建置虛擬機","content":" pip install uvicorn  3. 建置 tortoise-orm​  pip install tortoise-orm  ","version":"Next","tagName":"h3"},{"title":"4. 主程式​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#4-主程式","content":"程式路徑 app/main.py from fastapi import FastAPI from tortoise import fields from tortoise.models import Model from tortoise.contrib.fastapi import register_tortoise from pydantic import BaseModel app = FastAPI() class User(Model): id = fields.IntField(pk=True) name = fields.CharField(max_length=100) email = fields.CharField(max_length=100) class Meta: table = &quot;users&quot; class UserCreateRequest(BaseModel): name: str email: str @app.get(&quot;/users&quot;) async def get_users(): users = await User.all().values() return {&quot;users&quot;: users} @app.post(&quot;/users&quot;) async def create_user(user_data: UserCreateRequest): user = await User.create(name=user_data.name, email=user_data.email) return {&quot;message&quot;: &quot;User created successfully&quot;, &quot;user&quot;: user} register_tortoise( app, db_url=&quot;sqlite://database//db.sqlite3&quot;, modules={&quot;models&quot;: [&quot;main&quot;]}, generate_schemas=True, add_exception_handlers=True, ) if __name__ == &quot;__main__&quot;: import uvicorn uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8099)  ","version":"Next","tagName":"h3"},{"title":"5. 建立資料夾​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#5-建立資料夾","content":"由於這邊將資料庫指向 sqlite://database//db.sqlite3需要到 app/ 底下建立 database 資料夾 ","version":"Next","tagName":"h3"},{"title":"6. 依賴管理​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#6-依賴管理","content":"新增檔案 app/requirements.txt標註各套件的版本 fastapi==0.99.1 uvicorn==0.22.0 tortoise-orm==0.19.3  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#啟動","content":"","version":"Next","tagName":"h2"},{"title":"1. 安裝依賴包​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#1-安裝依賴包","content":"如果在不同環境，從 git 上拉取下來才需要執行此步驟  pip install -r requirements.txt  ","version":"Next","tagName":"h3"},{"title":"2. 執行​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#2-執行","content":" uvicorn main:app --reload  ","version":"Next","tagName":"h3"},{"title":"Docker​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#docker","content":"","version":"Next","tagName":"h2"},{"title":"1. dockerfile​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#1-dockerfile","content":"新增檔案 app/.dockerfile  FROM python:3.11.3 WORKDIR /app COPY requirements.txt . RUN pip install -r requirements.txt COPY . . CMD [&quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8099&quot;]  ","version":"Next","tagName":"h3"},{"title":"2. build image​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#2-build-image","content":" docker build -t my-fast-app .  ","version":"Next","tagName":"h3"},{"title":"3. run container​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#3-run-container","content":" docker run -p 8099:8099 my-fast-app   ","version":"Next","tagName":"h3"},{"title":"GitHub連結​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#github連結","content":"","version":"Next","tagName":"h2"},{"title":"連結​","type":1,"pageTitle":"👩‍💻 FastAPI + Tortoise ORM","url":"/en/docs/daylily/pyDaylily/fastapiTortoiseORM#連結","content":"","version":"Next","tagName":"h3"},{"title":"👩‍💻 element ui plus 暗黑模式","type":0,"sectionRef":"#","url":"/en/docs/daylily/vueDaylily/elementDark","content":"","keywords":"","version":"Next"},{"title":"版本​","type":1,"pageTitle":"👩‍💻 element ui plus 暗黑模式","url":"/en/docs/daylily/vueDaylily/elementDark#版本","content":"vue: 3.2.41vite: 3.2.0typescript: 4.6.4element-plus: 2.3.12 ","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"👩‍💻 element ui plus 暗黑模式","url":"/en/docs/daylily/vueDaylily/elementDark#安裝","content":"","version":"Next","tagName":"h2"},{"title":"先安裝 vueUse​","type":1,"pageTitle":"👩‍💻 element ui plus 暗黑模式","url":"/en/docs/daylily/vueDaylily/elementDark#先安裝-vueuse","content":"vueUse 類似 react 中的 hooks yarn add @vueuse/core  ","version":"Next","tagName":"h3"},{"title":"加入開關​","type":1,"pageTitle":"👩‍💻 element ui plus 暗黑模式","url":"/en/docs/daylily/vueDaylily/elementDark#加入開關","content":"於 App.vue &lt;script setup lang=&quot;ts&quot;&gt; import { useDark } from &quot;@vueuse/core&quot;; const isDark = useDark(); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;toggleDark()&quot;&gt; 是否為暗黑模式: {{ isDark }} &lt;/button&gt; &lt;/div&gt; &lt;main&gt; &lt;router-view /&gt; &lt;/main&gt; &lt;/template&gt;  ","version":"Next","tagName":"h3"},{"title":"加入 css​","type":1,"pageTitle":"👩‍💻 element ui plus 暗黑模式","url":"/en/docs/daylily/vueDaylily/elementDark#加入-css","content":"於 style.css html.dark { /* 背景顏色 */ --af-bg-color: #000000; }  ","version":"Next","tagName":"h3"},{"title":"加入深色主題​","type":1,"pageTitle":"👩‍💻 element ui plus 暗黑模式","url":"/en/docs/daylily/vueDaylily/elementDark#加入深色主題","content":"import { createApp } from &quot;vue&quot;; import { createPinia } from &quot;pinia&quot;; import './style.css' import 'element-plus/theme-chalk/dark/css-vars.css' import ElementPlus from 'element-plus' import router from &quot;./router/index&quot;; import App from &quot;./App.vue&quot;; const app = createApp(App); app.use(router).use(createPinia()).use(ElementPlus, { size: 'small', zIndex: 3000 }).mount(&quot;#app&quot;);  ","version":"Next","tagName":"h3"},{"title":"👩‍💻 element ui plus 建置","type":0,"sectionRef":"#","url":"/en/docs/daylily/vueDaylily/elementUi","content":"","keywords":"","version":"Next"},{"title":"版本​","type":1,"pageTitle":"👩‍💻 element ui plus 建置","url":"/en/docs/daylily/vueDaylily/elementUi#版本","content":"vue: 3.2.41vite: 3.2.0typescript: 4.6.4element-plus: 2.3.12 ","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"👩‍💻 element ui plus 建置","url":"/en/docs/daylily/vueDaylily/elementUi#安裝","content":"","version":"Next","tagName":"h2"},{"title":"安裝 element-plus​","type":1,"pageTitle":"👩‍💻 element ui plus 建置","url":"/en/docs/daylily/vueDaylily/elementUi#安裝-element-plus","content":"yarn add element-plus  ","version":"Next","tagName":"h3"},{"title":"安裝套件​","type":1,"pageTitle":"👩‍💻 element ui plus 建置","url":"/en/docs/daylily/vueDaylily/elementUi#安裝套件","content":"unplugin-vue-components 和 unplugin-auto-import 可以在需要時在導入UI，降低專案的大小 yarn add unplugin-vue-components unplugin-auto-import  於 vite.config.ts 加入設定 import { defineConfig } from 'vite' import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite' import { ElementPlusResolver } from 'unplugin-vue-components/resolvers' import vue from '@vitejs/plugin-vue' export default defineConfig({ plugins: [vue(), AutoImport({ resolvers: [ElementPlusResolver()], }), Components({ resolvers: [ElementPlusResolver()], }),] })  ","version":"Next","tagName":"h3"},{"title":"加入到全域​","type":1,"pageTitle":"👩‍💻 element ui plus 建置","url":"/en/docs/daylily/vueDaylily/elementUi#加入到全域","content":"import { createApp } from &quot;vue&quot;; import { createPinia } from &quot;pinia&quot;; import ElementPlus from 'element-plus' import router from &quot;./router/index&quot;; import App from &quot;./App.vue&quot;; import './style.css' const app = createApp(App); app.use(router).use(createPinia()).use(ElementPlus, { size: 'small', zIndex: 3000 }).mount(&quot;#app&quot;);  ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 單機建立多組","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolActiveMQ/createMoreActiveMQ","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/daylilyTool/toolActiveMQ/createMoreActiveMQ#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"在 windows 底下安裝多組​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/daylilyTool/toolActiveMQ/createMoreActiveMQ#在-windows-底下安裝多組","content":"","version":"Next","tagName":"h2"},{"title":"設定後台 port​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/daylilyTool/toolActiveMQ/createMoreActiveMQ#設定後台-port","content":"檔案: /conf/jetty.xmlport 不可重複 &lt;bean id=&quot;jettyPort&quot; class=&quot;org.apache.activemq.web.WebConsolePort&quot; init-method=&quot;start&quot;&gt; &lt;!-- the default port number for the web console --&gt; &lt;property name=&quot;host&quot; value=&quot;127.0.0.1&quot;/&gt; &lt;property name=&quot;port&quot; value=&quot;8161&quot;/&gt; &lt;/bean&gt;  ","version":"Next","tagName":"h3"},{"title":"設定通訊協議 port​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/daylilyTool/toolActiveMQ/createMoreActiveMQ#設定通訊協議-port","content":"檔案: /conf/activemq.xml所有通訊協議的 port 必須不重複 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"修改服務名稱​","type":1,"pageTitle":"🧣 ActiveMQ 單機建立多組","url":"/en/docs/daylilyTool/toolActiveMQ/createMoreActiveMQ#修改服務名稱","content":"檔案: /bin/win64/wrapper.conf console 啟動時 CMD 的標題 # Title to use when running as a console wrapper.console.title=ActiveMQ_1895  服務的名稱 # Name of the service wrapper.ntservice.name=ActiveMQ_1895  服務管理器看到的名稱 # Display name of the service wrapper.ntservice.displayname=ActiveMQ_1895  服務管理器的敘述 # Description of the service wrapper.ntservice.description=ActiveMQ_1895 Broker  ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 安裝 - windows","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWin","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWin#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"安裝流程​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWin#安裝流程","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWin#下載","content":"選擇 apache-activemq-5.16.6-bin.zip 點擊下載 解壓縮 copy Apache24 to C:\\apache-activemq-5.16.6 ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - windows","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWin#啟動","content":"檔案: /bin/win64/activemq.bat 右鍵 以系統管理員身分執行 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 安裝 - Artemis","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#環境","content":"windows10 ~ 11 (win64)ActiveMQ Artemis 2.31.2 (注意版本與 JDK 的相容性)OpenJDK 17.0.2 ","version":"Next","tagName":"h2"},{"title":"安裝流程​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#安裝流程","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#下載","content":"點擊下載 解壓縮 copy Apache24 to C:\\apache-artemis-2.31.2 ","version":"Next","tagName":"h3"},{"title":"建立 Broker​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#建立-broker","content":"檔案: /apache-artemis-2.31.2/bin/ 右鍵 在終端機開啟 ","version":"Next","tagName":"h2"},{"title":"建立新的 Broker​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#建立新的-broker","content":".\\artemis create MyBroker  終端機顯示 PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username?  ","version":"Next","tagName":"h3"},{"title":"輸入帳戶名稱​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#輸入帳戶名稱","content":"admin  終端機顯示 PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username? admin --password: is mandatory with this configuration: What is the default password?  ","version":"Next","tagName":"h3"},{"title":"輸入密碼​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#輸入密碼","content":"test123  終端機顯示 PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username? admin --password: is mandatory with this configuration: What is the default password? --allow-anonymous | --require-login: Allow anonymous access?, valid values are Y, N, True, False  ","version":"Next","tagName":"h3"},{"title":"匿名模式​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#匿名模式","content":"caution 如果設定成 Y 隨意連線都可以連進來訂閱與推播 所以一律要設定成 N N  PS C:\\app\\apache-artemis-2.31.2\\bin&gt; .\\artemis create MyBroker Creating ActiveMQ Artemis instance at: C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker --user: What is the default username? admin --password: is mandatory with this configuration: What is the default password? --allow-anonymous | --require-login: Allow anonymous access?, valid values are Y, N, True, False N Auto tuning journal ... done! Your system can make 0.45 writes per millisecond, your journal-buffer-timeout will be 2236000 You can now start the broker by executing: &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis&quot; run Or you can setup the broker as Windows service and run it in the background: &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; install &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; start To stop the windows service: &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; stop To uninstall the windows service &quot;C:\\app\\apache-artemis-2.31.2\\bin\\MyBroker\\bin\\artemis-service.exe&quot; uninstall  到這邊可以看到目錄底下長出一個 Broker ","version":"Next","tagName":"h3"},{"title":"目錄位置​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#目錄位置","content":"","version":"Next","tagName":"h2"},{"title":"設定​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#設定","content":"位於 /apache-artemis-2.31.2/bin/MyBroker/etc/ ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🧣 ActiveMQ 安裝 - Artemis","url":"/en/docs/daylilyTool/toolActiveMQ/inatallInWinArtemis#啟動","content":"位於 /apache-artemis-2.31.2/bin/MyBroker/bin/ .\\artemis run  後台 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 通訊協議","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolActiveMQ/protocol","content":"","keywords":"","version":"Next"},{"title":"官方預設通訊協議​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#官方預設通訊協議","content":"檔案: /conf/activemq.xml &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h2"},{"title":"傳輸協議​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#傳輸協議","content":"","version":"Next","tagName":"h2"},{"title":"TCP​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#tcp","content":"TCP (Transmission Control Protocol) 預設 port 為 61616在預設的情況下，被命名為 openwire連線字串的組成為 tcp://ip:port?key=valueTCP 優點 TPC 協議為保證連線效率高，socket 本身有 retry 機制 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"AMQP​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#amqp","content":"AMQP (Advanced Message Queuing Protocol) 預設 port 為 5672在預設的情況下，AMQP 連線被命名為 amqp連線字串的組成為 amqp://ip:port?key=valueAMQP 優點 支援多種客戶端和伺服器，使其成為一個極具靈活性的協議提供高度可靠的訊息交付機制，適合需要確保訊息不會丟失的應用程序能夠處理大量訊息，使其適用於高流量環境 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"STORM​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#storm","content":"STORM (STOMP - Streaming Text Oriented Messaging Protocol) 預設 port 為 61613在預設的情況下，STORM 連線被命名為 stomp連線字串的組成為 stomp://ip:port?key=valueSTORM 優點 提供輕量級的訊息傳遞協議，適合實時通訊和流數據處理易於實現並與多種客戶端和伺服器庫兼容 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"MQTT​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#mqtt","content":"MQTT (Message Queuing Telemetry Transport) 預設 port 為 1883在預設的情況下，MQTT 連線被命名為 mqtt連線字串的組成為 mqtt://ip:port?key=valueMQTT 優點 非常適合 IOT 設備，因為它是一個輕量級協議，節省網路和資源提供發布/訂閱和請求/回應訊息傳遞模式 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"WebSocket​","type":1,"pageTitle":"🧣 ActiveMQ 通訊協議","url":"/en/docs/daylilyTool/toolActiveMQ/protocol#websocket","content":"預設 port 為 61614在預設的情況下，WebSocket 連線被命名為 ws連線字串的組成為 ws://ip:port?key=valueWebSocket 優點 允許伺服器和客戶端之間的即時雙向通信適用於互動性應用程序，如即時聊天、在線遊戲等 &lt;transportConnectors&gt; &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB--&gt; &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; &lt;/transportConnectors&gt;  ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 自動回收","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolActiveMQ/setGC","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"訂閱者回收​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#訂閱者回收","content":"","version":"Next","tagName":"h2"},{"title":"訂閱者回收 - 設定​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#訂閱者回收---設定","content":"檔案: /conf/activemq.xml &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot; offlineDurableSubscriberTimeout=&quot;86400000&quot; offlineDurableSubscriberTaskSchedule=&quot;30000&quot;&gt; &lt;!-- 其他設定 --&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"訂閱者回收 - 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#訂閱者回收---屬性","content":"offlineDurableSubscriberTimeout: 此屬性設定了離線持久訂閱者的超時時間如果一個持久訂閱者在指定的超時時間內沒有任何活動，系統可能會將其視為離線狀態，並進行相應的處理超時時間設定為 86400000 毫秒，即 24 小時。 offlineDurableSubscriberTaskSchedule: 此屬性設定了執行離線持久訂閱者任務的排程間隔系統將以指定的間隔執行任務，以確保離線持久訂閱者的狀態得以更新排程間隔設定為 30000 毫秒，即 30 秒 ","version":"Next","tagName":"h3"},{"title":"Topic 回收​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#topic-回收","content":"","version":"Next","tagName":"h2"},{"title":"Topic 回收 - 設定​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#topic-回收---設定","content":"&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot; offlineDurableSubscriberTimeout=&quot;86400000&quot; offlineDurableSubscriberTaskSchedule=&quot;30000&quot;&gt; &lt;destinationPolicy&gt; &lt;policyMap&gt; &lt;policyEntries&gt; &lt;policyEntry topic=&quot;&gt;&quot;&gt; &lt;pendingMessageLimitStrategy&gt; &lt;constantPendingMessageLimitStrategy limit=&quot;1000&quot;/&gt; &lt;/pendingMessageLimitStrategy&gt; &lt;/policyEntry&gt; &lt;/policyEntries&gt; &lt;/policyMap&gt; &lt;/destinationPolicy&gt; &lt;!-- 其他設定 --&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"Topic 回收 - 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#topic-回收---屬性","content":"topic: 此屬性指定了 Topic 的名稱，這裡使用了 &gt;，表示所有的 Topic回收策略將應用於所有的 Topic pendingMessageLimitStrategy: 此屬性設定了待處理訊息數的限制策略，即當一個 Topic 上的待處理訊息數超過指定限制時，將採取相應的處理策略在這個例子中，使用了常數限制策略，設定的限制為每個 Topic 最多允許 1000 則待處理訊息 ","version":"Next","tagName":"h3"},{"title":"Queue 回收​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#queue-回收","content":"","version":"Next","tagName":"h2"},{"title":"Queue 回收 - 設定​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#queue-回收---設定","content":"&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot; offlineDurableSubscriberTimeout=&quot;86400000&quot; offlineDurableSubscriberTaskSchedule=&quot;30000&quot;&gt; &lt;destinationPolicy&gt; &lt;policyMap&gt; &lt;policyEntries&gt; &lt;policyEntry queue=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimoutBeforeGC=&quot;30000&quot;/&gt; &lt;/policyEntries&gt; &lt;/policyMap&gt; &lt;/destinationPolicy&gt; &lt;!-- 其他設定 --&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"Queue 回收 - 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 自動回收","url":"/en/docs/daylilyTool/toolActiveMQ/setGC#queue-回收---屬性","content":"gcInactiveDestinations: 此屬性用於啟用或禁用對閒置目的地的垃圾回收（Garbage Collection）如果設定為 true，系統將對閒置的 Queue 進行垃圾回收 inactiveTimoutBeforeGC: 此屬性設定了在執行垃圾回收之前，目的地可以保持閒置的時間閾值設定為 30000 毫秒，即 30 秒如果一個 Queue 在 30 秒內沒有活動，系統將視其為閒置目的地，並在啟用垃圾回收的情況下將其回收 ","version":"Next","tagName":"h3"},{"title":"🧣 ActiveMQ 權限控管","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolActiveMQ/setUser","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#環境","content":"windows10 ~ 11 (win64)ActiveMQ 5.16.6 (注意版本與 JDK 的相容性)JDK 1.8 ","version":"Next","tagName":"h2"},{"title":"Web 權限控管​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#web-權限控管","content":"","version":"Next","tagName":"h2"},{"title":"Web - 後台登入帳號資訊​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#web---後台登入帳號資訊","content":"檔案: /conf/jetty-realm.properties規則: 帳號: 密碼, 角色 # Defines users that can access the web (console, demo, etc.) # username: password [,rolename ...] admin: [密碼], admin user: [密碼], user  ","version":"Next","tagName":"h3"},{"title":"Simple Authentication​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#simple-authentication","content":"Client 端連線時需要使用的帳號密碼 設定完需重啟服務 ","version":"Next","tagName":"h2"},{"title":"簡單驗證 - 身分認證​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#簡單驗證---身分認證","content":"檔案: /conf/activemq.xml 屬性\t說明username\t使用者帳號 password\t使用者密碼 groups\t使用者所屬的群組 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; &lt;plugins&gt; &lt;simpleAuthenticationPlugin&gt; &lt;users&gt; &lt;authenticationUser username=&quot;admin&quot; password=&quot;admin1pwd&quot; groups=&quot;admins&quot;/&gt; &lt;authenticationUser username=&quot;user&quot; password=&quot;user-pw&quot; groups=&quot;users&quot;/&gt; &lt;/users&gt; &lt;/simpleAuthenticationPlugin&gt; &lt;/plugins&gt; &lt;/broker&gt;  ","version":"Next","tagName":"h3"},{"title":"簡單驗證 - 角色授權​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#簡單驗證---角色授權","content":"檔案: /conf/activemq.xml 屬性\t說明topic\t要授權的主題， &gt; 表示所有 read\t使用者密碼 groups\t使用者所屬的群組 簡單驗證 - 授權所有 Topic &lt;!-- 授權所有 Topic --&gt; &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; &lt;plugins&gt; &lt;simpleAuthenticationPlugin&gt; &lt;users&gt; &lt;authenticationUser username=&quot;admin&quot; password=&quot;admin1pwd&quot; groups=&quot;admins&quot;/&gt; &lt;authenticationUser username=&quot;user&quot; password=&quot;user-pw&quot; groups=&quot;users&quot;/&gt; &lt;/users&gt; &lt;/simpleAuthenticationPlugin&gt; &lt;authorizationPlugin&gt; &lt;map&gt; &lt;authorizationMap&gt; &lt;authorizationEntries&gt; &lt;authorizationEntry topic=&quot;&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users, admins&quot;/&gt; &lt;!-- 如果没有設定 topic=&quot;&gt;&quot; 需要設定以下內容 &lt;authorizationEntry topic=&quot;ActiveMQ.Advisory.&gt;&quot; read=&quot;guests, users&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot;/&gt; --&gt; &lt;/authorizationEntries&gt; &lt;/authorizationMap&gt; &lt;/map&gt; &lt;/authorizationPlugin&gt; &lt;/plugins&gt; &lt;/broker&gt;  簡單驗證 - 授權 Topic 進行授權需要特別設定 ActiveMQ.Advisory.&gt; 讓服務使用 &lt;!-- 授權所有 Topic --&gt; &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; &lt;plugins&gt; &lt;simpleAuthenticationPlugin&gt; &lt;users&gt; &lt;authenticationUser username=&quot;admin&quot; password=&quot;admin1pwd&quot; groups=&quot;admins&quot;/&gt; &lt;authenticationUser username=&quot;user&quot; password=&quot;user-pw&quot; groups=&quot;users&quot;/&gt; &lt;/users&gt; &lt;/simpleAuthenticationPlugin&gt; &lt;authorizationPlugin&gt; &lt;map&gt; &lt;authorizationMap&gt; &lt;authorizationEntries&gt; &lt;authorizationEntry topic=&quot;MyTopic&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users, admins&quot;/&gt; &lt;authorizationEntry topic=&quot;TestTopic&quot; read=&quot;admins&quot; write=&quot;users&quot; admin=&quot;users, admins&quot;/&gt; &lt;!-- 如果没有設定 topic=&quot;&gt;&quot; 需要設定以下內容 --&gt; &lt;authorizationEntry topic=&quot;ActiveMQ.Advisory.&gt;&quot; read=&quot;users, admins&quot; write=&quot;anonymous, users, admins&quot; admin=&quot;anonymous, users, admins&quot;/&gt; &lt;/authorizationEntries&gt; &lt;/authorizationMap&gt; &lt;/map&gt; &lt;/authorizationPlugin&gt; &lt;/plugins&gt; &lt;/broker&gt;  caution topic=&quot;ActiveMQ.Advisory.&gt;&quot; 這邊特地使用了 anonymous， 在 5.4 版之後， 簡單驗證提供了匿名訪問的功能，anonymous 則表示匿名的群組 ","version":"Next","tagName":"h3"},{"title":"JAAS Authentication​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#jaas-authentication","content":"JAAS 認證可以透過三份文件來設定 並且不需要重啟服務 ","version":"Next","tagName":"h2"},{"title":"JAAS - 使用者設定​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#jaas---使用者設定","content":"檔案: /conf/users.properties儲存帳號與密碼密碼至少要大於四位規則: 帳號=密碼 ## username=password admin=admin user1=pwd123 user2=pwd456  ","version":"Next","tagName":"h3"},{"title":"JAAS - 角色群組​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#jaas---角色群組","content":"檔案: /conf/groups.properties設定角色群組規則: 群組名稱=帳號1,帳號2 ## group-name=username1,username2 admins=admin,user1 users=user1,user2  ","version":"Next","tagName":"h3"},{"title":"JAAS - 屬性設定​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#jaas---屬性設定","content":"檔案: /conf/login.config 屬性\t說明debug\t發生錯誤或例外時，可以看到詳細的錯誤訊息 reload\t在修改 users.properties, groups.properties 後不需要重啟服務 org.apache.activemq.jaas.properties.user\t指定使用 users.properties org.apache.activemq.jaas.properties.group\t指定使用 groups.properties activemq { org.apache.activemq.jaas.PropertiesLoginModule required debug=true reload=true org.apache.activemq.jaas.properties.user=&quot;users.properties&quot; org.apache.activemq.jaas.properties.group=&quot;groups.properties&quot;; };  ","version":"Next","tagName":"h3"},{"title":"JAAS - 啟用 JAAS​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#jaas---啟用-jaas","content":"檔案: /conf/activemq.xml &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; &lt;plugins&gt; &lt;jaasAuthenticationPlugin configuration=&quot;activemq&quot; /&gt; &lt;authorizationPlugin&gt; &lt;map&gt; &lt;authorizationMap&gt; &lt;authorizationEntries&gt; &lt;authorizationEntry topic=&quot;TestTopic&quot; read=&quot;users, admins&quot; write=&quot;users, admins&quot; admin=&quot;users, admins&quot;/&gt; &lt;authorizationEntry topic=&quot;ActiveMQ.Advisory.&gt;&quot; read=&quot;users, admins&quot; write=&quot;users, admins&quot; admin=&quot;users, admins&quot;/&gt; &lt;/authorizationEntries&gt; &lt;/authorizationMap&gt; &lt;/map&gt; &lt;/authorizationPlugin&gt; &lt;/plugins&gt; &lt;/broker&gt;  caution 此模式無法使用 anonymous ","version":"Next","tagName":"h3"},{"title":"關於 ActiveMQ 屬性​","type":1,"pageTitle":"🧣 ActiveMQ 權限控管","url":"/en/docs/daylilyTool/toolActiveMQ/setUser#關於-activemq-屬性","content":"屬性\t值（示例）\t描述&lt;authorizationEntry&gt;\t-\t定義授權規則的元素 topic\t&gt;\t授權的主題，這裡是通配符，表示所有主題 read\tmb\t對該主題的讀取權限，mb 角色具有讀取權限 write\tusers\t對該主題的寫入權限，users 角色具有寫入權限 admin\tadmins,users,mb\t對該主題的管理權限，admins、users 和 mb 角色都有管理權限 ","version":"Next","tagName":"h2"},{"title":"🍂 Apache24 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolApache/install","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🍂 Apache24 安裝","url":"/en/docs/daylilyTool/toolApache/install#環境","content":"windows10 ~ 11Apache24 ","version":"Next","tagName":"h2"},{"title":"安裝流程​","type":1,"pageTitle":"🍂 Apache24 安裝","url":"/en/docs/daylilyTool/toolApache/install#安裝流程","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🍂 Apache24 安裝","url":"/en/docs/daylilyTool/toolApache/install#下載","content":"選擇 64 bit Redistributable Package (x64) 點擊下載 copy Apache24 to C:\\Apache24 caution 如果需要換路徑，需要 /Apache24/conf/httpd.conf， 修改 Define SRVROOT &quot;c:/Apache24&quot; ","version":"Next","tagName":"h3"},{"title":"安裝依賴​","type":1,"pageTitle":"🍂 Apache24 安裝","url":"/en/docs/daylilyTool/toolApache/install#安裝依賴","content":"caution 如果啟動後跳出以下錯誤訊息 installing apache: no VCRUNTIME140.dll 需安裝 C++ Redistributable for Visual Studio 2015 RC 下載 ","version":"Next","tagName":"h3"},{"title":"🍂 Apache24 加入服務","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolApache/setInService","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🍂 Apache24 加入服務","url":"/en/docs/daylilyTool/toolApache/setInService#環境","content":"windows10 ~ 11Apache24 ","version":"Next","tagName":"h2"},{"title":"設為服務​","type":1,"pageTitle":"🍂 Apache24 加入服務","url":"/en/docs/daylilyTool/toolApache/setInService#設為服務","content":"","version":"Next","tagName":"h2"},{"title":"使用管理員啟用CMD​","type":1,"pageTitle":"🍂 Apache24 加入服務","url":"/en/docs/daylilyTool/toolApache/setInService#使用管理員啟用cmd","content":" C:\\Apache24\\bin\\httpd.exe -k install  ","version":"Next","tagName":"h3"},{"title":"🍂 Apache24 設定 proxy","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolApache/setProxy","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#環境","content":"windows10 ~ 11Apache24 ","version":"Next","tagName":"h2"},{"title":"設定 proxy​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#設定-proxy","content":"檔案: /Apache24/conf/httpd.conf ","version":"Next","tagName":"h2"},{"title":"啟用模組​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#啟用模組","content":" LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so  ","version":"Next","tagName":"h3"},{"title":"引用設定檔​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#引用設定檔","content":" Include conf/extra/httpd-vhosts.conf  ","version":"Next","tagName":"h3"},{"title":"proxy 規則​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#proxy-規則","content":"檔案: /Apache24/conf/extra/httpd-vhosts.conf ","version":"Next","tagName":"h2"},{"title":"httpd-vhosts 範例​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#httpd-vhosts-範例","content":"如果外部透過 443 port 會將他轉到 localhost:8080 如果外部透過 443 port 會將他轉到 https://blog.lychicken.com/ &lt;VirtualHost *:443&gt; ServerName blog.lychicken.com ProxyRequests off ProxyPreserveHost on ProxyPass /chicken http://localhost:8080/chicken flushpackets=on keepalive=on ProxyPassReverse /chicken http://localhost:8080/chicken &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName blog.lychicken.com Redirect permanent / https://blog.lychicken.com/ &lt;/VirtualHost&gt;  ","version":"Next","tagName":"h3"},{"title":"proxy log​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#proxy-log","content":"檔案: /Apache24/conf/httpd.conf ","version":"Next","tagName":"h2"},{"title":"修改 log 等級​","type":1,"pageTitle":"🍂 Apache24 設定 proxy","url":"/en/docs/daylilyTool/toolApache/setProxy#修改-log-等級","content":" LogLevel warn  ","version":"Next","tagName":"h3"},{"title":"🦫 DBeaver 開啟行號","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDBeaver/showLineNum","content":"🦫 DBeaver 開啟行號 Window &gt;&gt; Preferences &gt;&gt; Text Editors &gt;&gt; Show line numbers","keywords":"","version":"Next"},{"title":"🍂 Apache24 設定 SSL","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolApache/setSSL","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#環境","content":"windows10 ~ 11Apache24 ","version":"Next","tagName":"h2"},{"title":"設定 SSL​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#設定-ssl","content":"檔案: /Apache24/conf/httpd.conf ","version":"Next","tagName":"h2"},{"title":"啟用模組​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#啟用模組","content":" LoadModule ssl_module modules/mod_ssl.so LoadModule socache_shmcb_module modules/mod_socache_shmcb.so  ","version":"Next","tagName":"h3"},{"title":"引用設定檔​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#引用設定檔","content":" Include conf/extra/httpd-ssl.conf  ","version":"Next","tagName":"h3"},{"title":"建立目錄​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#建立目錄","content":"/Apache24/pki ","version":"Next","tagName":"h3"},{"title":"放入憑證​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#放入憑證","content":"總共有三個檔案 STAR_lychicken_com.crtlychicken.keySTAR_lychicken_com.ca-bundle ","version":"Next","tagName":"h3"},{"title":"SSL 規則​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#ssl-規則","content":"檔案: conf/extra/httpd-ssl.conf ","version":"Next","tagName":"h2"},{"title":"修改憑證路徑​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#修改憑證路徑","content":" SSLCertificateFile &quot;${SRVROOT}/pki/STAR_lychicken_com.crt&quot; SSLCertificateKeyFile &quot;${SRVROOT}/pki/lychicken.key&quot; SSLCertificateChainFile &quot;${SRVROOT}/pki/STAR_lychicken_com.ca-bundle  ","version":"Next","tagName":"h3"},{"title":"新增 https 規則​","type":1,"pageTitle":"🍂 Apache24 設定 SSL","url":"/en/docs/daylilyTool/toolApache/setSSL#新增-https-規則","content":"Listen 443 https SSLCipherSuite HIGH:MEDIUM:!aNULL:!MD5:!SEED:!IDEA SSLProxyCipherSuite HIGH:MEDIUM:!aNULL:!MD5:!SEED:!IDEA SSLProtocol all -SSLv2 -SSLv3 # SSLProxyProtocol all -SSLv3  ","version":"Next","tagName":"h3"},{"title":"🐳 清空快取","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDocker/clearData","content":"","keywords":"","version":"Next"},{"title":"查詢整體緩存狀況​","type":1,"pageTitle":"🐳 清空快取","url":"/en/docs/daylilyTool/toolDocker/clearData#查詢整體緩存狀況","content":"docker system df  ","version":"Next","tagName":"h2"},{"title":"清除 Build Cache​","type":1,"pageTitle":"🐳 清空快取","url":"/en/docs/daylilyTool/toolDocker/clearData#清除-build-cache","content":"docker builder prune  ","version":"Next","tagName":"h2"},{"title":"🐳 建立 Image","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDocker/commitContainer","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🐳 建立 Image","url":"/en/docs/daylilyTool/toolDocker/commitContainer#說明","content":"將容器建立成一個新的 Image ","version":"Next","tagName":"h2"},{"title":"指令​","type":1,"pageTitle":"🐳 建立 Image","url":"/en/docs/daylilyTool/toolDocker/commitContainer#指令","content":"","version":"Next","tagName":"h2"},{"title":"docker commit​","type":1,"pageTitle":"🐳 建立 Image","url":"/en/docs/daylilyTool/toolDocker/commitContainer#docker-commit","content":"docker commit [動作(選填)] [容器] [Image Name:tag]  ","version":"Next","tagName":"h3"},{"title":"動作​","type":1,"pageTitle":"🐳 建立 Image","url":"/en/docs/daylilyTool/toolDocker/commitContainer#動作","content":"-a : Image 作者-c : 使用 Dockerfile 指令來建立 Image-m : 加入文字說明-p : 建立過程先將容器暫停 ","version":"Next","tagName":"h3"},{"title":"🐳 Docker 常用指令","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDocker/commonDirectives","content":"","keywords":"","version":"Next"},{"title":"1. 檢視 image​","type":1,"pageTitle":"🐳 Docker 常用指令","url":"/en/docs/daylilyTool/toolDocker/commonDirectives#1-檢視-image","content":"sudo docker &lt;images&gt;  ","version":"Next","tagName":"h2"},{"title":"2. 啟動指定的image​","type":1,"pageTitle":"🐳 Docker 常用指令","url":"/en/docs/daylilyTool/toolDocker/commonDirectives#2-啟動指定的image","content":"sudo docker run &lt;imageID&gt;  ","version":"Next","tagName":"h2"},{"title":"3. 進入容器​","type":1,"pageTitle":"🐳 Docker 常用指令","url":"/en/docs/daylilyTool/toolDocker/commonDirectives#3-進入容器","content":"sudo docker exec -it &lt;Container名稱&gt; bash  ","version":"Next","tagName":"h2"},{"title":"🐳 建立 bridge","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDocker/createbridge","content":"","keywords":"","version":"Next"},{"title":"關於 docker bridge​","type":1,"pageTitle":"🐳 建立 bridge","url":"/en/docs/daylilyTool/toolDocker/createbridge#關於-docker-bridge","content":"Docker Bridge 網絡是 Docker 默認使用的網絡模式 它提供了一種方式，讓 Docker 容器可以在主機上創建一個虛擬網絡，容器可以相互通訊， 但通常不會直接暴露給外部網絡。這對於構建內部微服務架構或多容器應用程序非常有用 ","version":"Next","tagName":"h2"},{"title":"docker bridge 指令​","type":1,"pageTitle":"🐳 建立 bridge","url":"/en/docs/daylilyTool/toolDocker/createbridge#docker-bridge-指令","content":"","version":"Next","tagName":"h2"},{"title":"建立 bridge​","type":1,"pageTitle":"🐳 建立 bridge","url":"/en/docs/daylilyTool/toolDocker/createbridge#建立-bridge","content":"docker network create -d bridge [bridge name]  ","version":"Next","tagName":"h3"},{"title":"查詢目前 bridge​","type":1,"pageTitle":"🐳 建立 bridge","url":"/en/docs/daylilyTool/toolDocker/createbridge#查詢目前-bridge","content":"docker network bridge ls  -d bridge 指定網絡驅動程式為橋接（bridge）[bridge name] 為網絡指定的名稱 ","version":"Next","tagName":"h3"},{"title":"移除 bridge​","type":1,"pageTitle":"🐳 建立 bridge","url":"/en/docs/daylilyTool/toolDocker/createbridge#移除-bridge","content":"docker network rm [bridge name]  ","version":"Next","tagName":"h3"},{"title":"🐳 匯入匯出 Image","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDocker/saveImage","content":"","keywords":"","version":"Next"},{"title":"匯出​","type":1,"pageTitle":"🐳 匯入匯出 Image","url":"/en/docs/daylilyTool/toolDocker/saveImage#匯出","content":"docker save -o &quot;[檔名.tar]&quot; [image id]  ","version":"Next","tagName":"h2"},{"title":"匯入​","type":1,"pageTitle":"🐳 匯入匯出 Image","url":"/en/docs/daylilyTool/toolDocker/saveImage#匯入","content":"cd [tar 目錄]  docker image import [檔名.tar] [image name]:[image tag]  ","version":"Next","tagName":"h2"},{"title":"🐳 Docker 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin","content":"","keywords":"","version":"Next"},{"title":"在 Windows 底下安裝 Docker​","type":1,"pageTitle":"🐳 Docker 安裝","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin#在-windows-底下安裝-docker","content":"本次安裝環境於 Windows11 ","version":"Next","tagName":"h2"},{"title":"1. 啟用虛擬機 Hyper-V​","type":1,"pageTitle":"🐳 Docker 安裝","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin#1-啟用虛擬機-hyper-v","content":"開始 &gt; 變更帳戶設定 &gt; 應用程式 &gt; 選用功能 &gt; 更多 Windows 功能 在這個地方找到 hyper-v 將他啟用 ","version":"Next","tagName":"h2"},{"title":"2. 安裝 Docker Desktop​","type":1,"pageTitle":"🐳 Docker 安裝","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin#2-安裝-docker-desktop","content":"官網連結下載後直接執行安裝檔 Docker Desktop Installer.exe ","version":"Next","tagName":"h2"},{"title":"啟動後出現 WSL 版本過低​","type":1,"pageTitle":"🐳 Docker 安裝","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin#啟動後出現-wsl-版本過低","content":"檢查 WSL 版本，於終端機中輸入以下指令  wsl.exe -l -v  如果有就直接更新  wsl --update  如果沒有任何版本就執行以下指令  wsl --install  畫面會顯示可安裝版本 NAME FRIENDLY NAME Ubuntu Ubuntu Debian Debian GNU/Linux kali-linux Kali Linux Rolling Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS Ubuntu-22.04 Ubuntu 22.04 LTS OracleLinux_7_9 Oracle Linux 7.9 OracleLinux_8_7 Oracle Linux 8.7 OracleLinux_9_1 Oracle Linux 9.1 openSUSE-Leap-15.5 openSUSE Leap 15.5 SUSE-Linux-Enterprise-Server-15-SP4 SUSE Linux Enterprise Server 15 SP4 SUSE-Linux-Enterprise-15-SP5 SUSE Linux Enterprise 15 SP5 openSUSE-Tumbleweed openSUSE Tumbleweed  本次選擇 Ubuntu-22.04  wsl --install -d Ubuntu-22.04  ","version":"Next","tagName":"h3"},{"title":"新增 wsl 記憶體限制​","type":1,"pageTitle":"🐳 Docker 安裝","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin#新增-wsl-記憶體限制","content":"於 C:\\Users\\&lt;user&gt; 底下新增文檔 .wslconfig [wsl2] memory=6GB  ","version":"Next","tagName":"h3"},{"title":"3. 啟動​","type":1,"pageTitle":"🐳 Docker 安裝","url":"/en/docs/daylilyTool/toolDocker/setDockerInWin#3-啟動","content":"開啟 Docker Desktop 畫面上沒有錯誤訊息表示安裝成功 ","version":"Next","tagName":"h2"},{"title":"🐲 蒐集 ActiveMQ Logs","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolELK/addActiveMq","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#環境","content":"Windows10 ~ 11 (win64)ActiveMQ 5.18.3Filebeat 8.11.3 ","version":"Next","tagName":"h2"},{"title":"下載與安裝​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#下載與安裝","content":"","version":"Next","tagName":"h2"},{"title":"下載 Filebeat​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#下載-filebeat","content":"下載 Windows ZIP x86_64解壓縮，並將檔名修改為 Filebeat放到 C:\\Program Files\\Filebeat 底下 ","version":"Next","tagName":"h3"},{"title":"加入服務​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#加入服務","content":"使用系統管理員啟用 power shell cd &quot;C:\\Program Files\\Filebeat&quot; .\\install-service-filebeat.ps1  caution \\install-service-filebeat.ps1 未經數位簽署。您無法在目前的系統上執行此指令碼。 先執行 Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass 看到服務中有 filebeat 表示成功 ","version":"Next","tagName":"h3"},{"title":"設定連線​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#設定連線","content":"檔案位置: C:\\Program Files\\Filebeat\\filebeat.yml output.elasticsearch: hosts: [&quot;&lt;es_url&gt;&quot;] username: &quot;elastic&quot; password: &quot;&lt;password&gt;&quot; # If using Elasticsearch's default certificate ssl.ca_trusted_fingerprint: &quot;&lt;es cert fingerprint&gt;&quot; setup.kibana: host: &quot;&lt;kibana_url&gt;&quot;  如果使用 docker-compose 的預設 output.elasticsearch: hosts: [&quot;localhost:9200&quot;] username: &quot;elastic&quot; password: &quot;changeme&quot; # If using Elasticsearch's default certificate # ssl.ca_trusted_fingerprint: &quot;&lt;es cert fingerprint&gt;&quot; setup.kibana: host: &quot;localhost:5601&quot;  ","version":"Next","tagName":"h3"},{"title":"啟用 ActiveMQ 蒐集​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#啟用-activemq-蒐集","content":".\\filebeat.exe modules enable activemq  設定 ActiveMQ log 路徑檔案: modules.d/activemq.yml - module: activemq # Audit logs audit: enabled: true var.paths: [&quot;C:\\\\apache-activemq-5.18.3\\\\data\\\\audit.log&quot;] # Application logs log: enabled: true var.paths: [&quot;C:\\\\apache-activemq-5.18.3\\\\data\\\\activemq.log&quot;]  ","version":"Next","tagName":"h3"},{"title":"載入設定​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#載入設定","content":".\\filebeat.exe setup  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#啟動","content":"","version":"Next","tagName":"h2"},{"title":"1. 未設定為服務​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#1-未設定為服務","content":"如果沒有設定成服務要直接執行 .\\filebeat.exe -e -c filebeat.yml -d &quot;*&quot;  ","version":"Next","tagName":"h3"},{"title":"2. 啟動服務​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#2-啟動服務","content":"已經設定成服務，啟動服務 Start-Service filebeat  ","version":"Next","tagName":"h3"},{"title":"觀看 log​","type":1,"pageTitle":"🐲 蒐集 ActiveMQ Logs","url":"/en/docs/daylilyTool/toolELK/addActiveMq#觀看-log","content":"可到後台 看到 log 表示設定成功 ","version":"Next","tagName":"h2"},{"title":"📗 NVM 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolNode/setNvm","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#環境","content":"OS: Windows11 ","version":"Next","tagName":"h2"},{"title":"用途​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#用途","content":"可以在本機安裝多個版本的 node， 並且快速切換版本 ","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#下載","content":"官方位址 下載 nvm-setup.zip解壓縮 caution 安裝目錄不可有中文，否則會報錯 ","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#安裝","content":"直接點擊 nvm-setup.exe 持續下一步即可 ","version":"Next","tagName":"h2"},{"title":"測試​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#測試","content":"開啟終端機 nvm  ","version":"Next","tagName":"h2"},{"title":"常用命令​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#常用命令","content":"","version":"Next","tagName":"h2"},{"title":"安裝 node​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#安裝-node","content":"最新版本的 node nvm install latest  使用特定版本的 Node.js（例如，使用版本 14.3.0） nvm use 14.3.0  在當前版本的 Node.js 環境下，重新全局安裝指定版本號的 npm 套件 nvm reinstall-packages 版本號  ","version":"Next","tagName":"h3"},{"title":"列出所有版本​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#列出所有版本","content":"列出已安裝的所有版本 nvm list  （簡化版） nvm ls  列出可用的遠端 Node.js 版本（僅適用於 macOS） nvm ls-remote  列出可用的遠端 Node.js 版本（僅適用於 Windows） nvm ls available  ","version":"Next","tagName":"h3"},{"title":"卸載 node​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#卸載-node","content":"特定版本的 Node.js（例如，卸載版本 14.3.0） nvm uninstall 14.3.0  ","version":"Next","tagName":"h3"},{"title":"顯示版本​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#顯示版本","content":"顯示當前使用的 Node.js 版本 nvm current  ","version":"Next","tagName":"h3"},{"title":"為不同版本的 Node.js 添加別名​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#為不同版本的-nodejs-添加別名","content":"nvm alias [別名] [版本號]  ","version":"Next","tagName":"h3"},{"title":"刪除已定義的別名​","type":1,"pageTitle":"📗 NVM 安裝","url":"/en/docs/daylilyTool/toolNode/setNvm#刪除已定義的別名","content":"nvm unalias 別名  ","version":"Next","tagName":"h3"},{"title":"🥣 JDK 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolScoop/setJdk","content":"","keywords":"","version":"Next"},{"title":"關於​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#關於","content":"Java 版本繁多，每次專案需要切換不同版本，是件麻煩的事情 因此可以依賴 scoop 來安裝不同的 java 版本 ","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#安裝","content":"","version":"Next","tagName":"h2"},{"title":"將 Java 加入 bucket​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#將-java-加入-bucket","content":"scoop bucket add java  ","version":"Next","tagName":"h3"},{"title":"確認現有 bucket​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#確認現有-bucket","content":"scoop bucket list  出現以下文字表示加入成功 Name Source Updated Manifests ---- ------ ------- --------- java https://github.com/ScoopInstaller/Java 2023/9/7 上午 09:02:34 253  ","version":"Next","tagName":"h3"},{"title":"搜尋可用 JDK​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#搜尋可用-jdk","content":"scoop search jdk  Name Version Source Binaries ---- ------- ------ -------- corretto-jdk 19.0.2.7.1 java corretto-lts-jdk 17.0.8.8.1 java corretto11-jdk 11.0.20.9.1 java corretto15-jdk 15.0.2.7.1 java corretto16-jdk 16.0.2.7.1 java corretto17-jdk 17.0.8.8.1 java corretto18-jdk 18.0.2.9.1 java corretto19-jdk 19.0.2.7.1 java corretto8-jdk 8.382.05.1 java dragonwell11-jdk 11.0.20.16-11.0.20 java dragonwell17-jdk 17.0.8.0.8-17.0.8 java dragonwell8-jdk 8.16.17-8.0.382 java graalvm-jdk11 22.3.2 java graalvm-jdk17 22.3.2 java  ","version":"Next","tagName":"h3"},{"title":"下載JDK​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#下載jdk","content":"下載 JDK 8 與 JDK 17 # JDK8 scoop install openjdk8-redhat # JDK17 scoop install openjdk17  ","version":"Next","tagName":"h3"},{"title":"切換JDK​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#切換jdk","content":"切 JDK 8 # JDK8 scoop reset openjdk8-redhat  切 JDK 17 scoop reset openjdk17  ","version":"Next","tagName":"h3"},{"title":"JDK 版本確認​","type":1,"pageTitle":"🥣 JDK 安裝","url":"/en/docs/daylilyTool/toolScoop/setJdk#jdk-版本確認","content":"java -version  ","version":"Next","tagName":"h3"},{"title":"🐲 Docker 中安裝 ELK","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolELK/elkInDocker","content":"","keywords":"","version":"Next"},{"title":"下載與安裝​","type":1,"pageTitle":"🐲 Docker 中安裝 ELK","url":"/en/docs/daylilyTool/toolELK/elkInDocker#下載與安裝","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🐲 Docker 中安裝 ELK","url":"/en/docs/daylilyTool/toolELK/elkInDocker#下載","content":"於官方 Github 下載本次下載 8.2305.1 版 ","version":"Next","tagName":"h3"},{"title":"安裝​","type":1,"pageTitle":"🐲 Docker 中安裝 ELK","url":"/en/docs/daylilyTool/toolELK/elkInDocker#安裝","content":"解壓縮後，到專案目錄下，開啟終端機 建立 docker-compose docker-compose up  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🐲 Docker 中安裝 ELK","url":"/en/docs/daylilyTool/toolELK/elkInDocker#啟動","content":"以下是預設的 port 5000: Logstash TCP input 9200: Elasticsearch HTTP 9300: Elasticsearch TCP transport 5601: Kibana  ","version":"Next","tagName":"h2"},{"title":"後台(kibana)​","type":1,"pageTitle":"🐲 Docker 中安裝 ELK","url":"/en/docs/daylilyTool/toolELK/elkInDocker#後台kibana","content":"後台聯結: http://localhost:5601/預設帳號: elastic預設密碼: changeme ","version":"Next","tagName":"h3"},{"title":"🥣 Maven 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolScoop/setMaven","content":"","keywords":"","version":"Next"},{"title":"安裝​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#安裝","content":"","version":"Next","tagName":"h2"},{"title":"將 Java 加入 bucket​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#將-java-加入-bucket","content":"scoop bucket add java  ","version":"Next","tagName":"h3"},{"title":"確認現有 bucket​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#確認現有-bucket","content":"scoop bucket list  出現以下文字表示加入成功 Name Source Updated Manifests ---- ------ ------- --------- java https://github.com/ScoopInstaller/Java 2023/9/7 上午 09:02:34 253  ","version":"Next","tagName":"h3"},{"title":"搜尋可用 maven​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#搜尋可用-maven","content":"scoop search maven  Name Version Source Binaries ---- ------- ------ -------- maven 3.9.4 main  ","version":"Next","tagName":"h3"},{"title":"下載 maven​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#下載-maven","content":"scoop install maven  ","version":"Next","tagName":"h3"},{"title":"切換 maven​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#切換-maven","content":"scoop reset maven  ","version":"Next","tagName":"h3"},{"title":"maven 版本確認​","type":1,"pageTitle":"🥣 Maven 安裝","url":"/en/docs/daylilyTool/toolScoop/setMaven#maven-版本確認","content":"mvn -v  ","version":"Next","tagName":"h3"},{"title":"🥣 Spring Boot CLI 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolScoop/setSpringboot","content":"","keywords":"","version":"Next"},{"title":"安裝​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#安裝","content":"","version":"Next","tagName":"h2"},{"title":"將 extras 加入 bucket​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#將-extras-加入-bucket","content":"scoop bucket add extras  ","version":"Next","tagName":"h3"},{"title":"確認現有 bucket​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#確認現有-bucket","content":"scoop bucket list  出現以下文字表示加入成功 Name Source Updated Manifests ---- ------ ------- --------- extras https://github.com/ScoopInstaller/Extras 2023/9/7 下午 01:55:59 1890 java https://github.com/ScoopInstaller/Java 2023/9/7 上午 09:02:34 253  ","version":"Next","tagName":"h3"},{"title":"搜尋可用 Spring Boot​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#搜尋可用-spring-boot","content":"scoop search springboot  Name Version Source Binaries ---- ------- ------ -------- openliberty 23.0.0.8 extras springBootUtility.bat springboot 3.1.3 extras  ","version":"Next","tagName":"h3"},{"title":"下載 Spring Boot​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#下載-spring-boot","content":"scoop install springboot  ","version":"Next","tagName":"h3"},{"title":"切換 Spring Boot​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#切換-spring-boot","content":"scoop reset springboot  ","version":"Next","tagName":"h3"},{"title":"Spring Boot 版本確認​","type":1,"pageTitle":"🥣 Spring Boot CLI 安裝","url":"/en/docs/daylilyTool/toolScoop/setSpringboot#spring-boot-版本確認","content":"spring -v  ","version":"Next","tagName":"h3"},{"title":"🥣 scoop 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolScoop/setScoop","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#環境","content":"OS: Windows11 Powershell ","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#安裝","content":"","version":"Next","tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#下載","content":"Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')  ","version":"Next","tagName":"h3"},{"title":"狀態確認​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#狀態確認","content":"scoop status  ","version":"Next","tagName":"h3"},{"title":"常用指令​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#常用指令","content":"","version":"Next","tagName":"h2"},{"title":"查詢官方現有 bucket​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#查詢官方現有-bucket","content":"scoop bucket known  ","version":"Next","tagName":"h3"},{"title":"加入 bucket​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#加入-bucket","content":"scoop bucket add [bucket name]  ","version":"Next","tagName":"h3"},{"title":"確認現有 bucket​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#確認現有-bucket","content":"scoop bucket list  ","version":"Next","tagName":"h3"},{"title":"確認現有套件​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#確認現有套件","content":"scoop list  ","version":"Next","tagName":"h3"},{"title":"更新 bucket​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#更新-bucket","content":"更新特定套件 scoop update [app name]  更新全部套件 scoop update *  ","version":"Next","tagName":"h3"},{"title":"搜尋可用的套件​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#搜尋可用的套件","content":"scoop search [app name]  ","version":"Next","tagName":"h3"},{"title":"安裝各版本套件​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#安裝各版本套件","content":"scoop install [Name]  ","version":"Next","tagName":"h3"},{"title":"切換版本​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#切換版本","content":"scoop reset [app name]@[Version]  ","version":"Next","tagName":"h3"},{"title":"卸載套件​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#卸載套件","content":"scoop uninstall [Name]  ","version":"Next","tagName":"h3"},{"title":"更新 scoop 版本​","type":1,"pageTitle":"🥣 scoop 安裝","url":"/en/docs/daylilyTool/toolScoop/setScoop#更新-scoop-版本","content":"scoop update   官方網站 ","version":"Next","tagName":"h3"},{"title":"🥣 Python 安裝","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolScoop/setPython","content":"","keywords":"","version":"Next"},{"title":"安裝​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#安裝","content":"","version":"Next","tagName":"h2"},{"title":"將 versions 加入 bucket​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#將-versions-加入-bucket","content":"scoop bucket add versions  ","version":"Next","tagName":"h3"},{"title":"確認現有 bucket​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#確認現有-bucket","content":"scoop bucket list  出現以下文字表示加入成功 Name Source Updated Manifests ---- ------ ------- --------- java https://github.com/ScoopInstaller/Java 2023/12/9 下午 12:16:42 267 main https://github.com/ScoopInstaller/Main 2023/12/9 下午 04:25:02 1265 versions https://github.com/ScoopInstaller/Versions 2024/1/7 下午 04:30:28 435  ","version":"Next","tagName":"h3"},{"title":"搜尋可用 Python​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#搜尋可用-python","content":"scoop search python  Name Version Source Binaries ---- ------- ------ -------- python 3.12.1 main winpython 3.11.6.0 main anaconda2 2019.10 versions python.exe | pythonw.exe | python.exe anaconda3-2022.05 2022.05 versions python.exe | pythonw.exe | python.exe miniconda2 4.8.3 versions python.exe | pythonw.exe | python.exe miniconda3-4.12.0 4.12.0 versions python.exe | pythonw.exe | python.exe python-alpha 3.13.0a2 versions python-beta 3.13.0a2 versions python-pre 3.13.0a2 versions python-rc 3.12.0rc3 versions python27 2.7.18 versions python310 3.10.11 versions python311 3.11.7 versions python312 3.12.1 versions python35 3.5.4 versions python36 3.6.8 versions python37 3.7.9 versions python38 3.8.10 versions python39 3.9.13 versions winpython37 3.7.7.1 versions winpython3741 3.7.4.1 versions winpython37cod 3.7.7.1 versions winpython37ps2 3.7.6.0 versions winpython38 3.8.9.0 versions winpython38cod 3.8.7.0 versions winpython38ps2 3.8.1.0 versions  ","version":"Next","tagName":"h3"},{"title":"下載 Python​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#下載-python","content":"scoop install python  ","version":"Next","tagName":"h3"},{"title":"切換 Python​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#切換-python","content":"scoop reset python  ","version":"Next","tagName":"h3"},{"title":"Python 版本確認​","type":1,"pageTitle":"🥣 Python 安裝","url":"/en/docs/daylilyTool/toolScoop/setPython#python-版本確認","content":"python --version  ","version":"Next","tagName":"h3"},{"title":"🧊 PowerShell 常用指令","type":0,"sectionRef":"#","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell","content":"","keywords":"","version":"Next"},{"title":"常見的 PowerShell 指令​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#常見的-powershell-指令","content":"","version":"Next","tagName":"h2"},{"title":"Get-Help​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#get-help","content":"獲取指令的幫助資訊，可以使用 -Name 參數指定指令名稱 Get-Help Get-Process  ","version":"Next","tagName":"h3"},{"title":"Get-Command​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#get-command","content":"獲取系統中所有可用的指令 ","version":"Next","tagName":"h3"},{"title":"Get-Process​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#get-process","content":"顯示目前系統上運行的 Process 列表 ","version":"Next","tagName":"h3"},{"title":"Get-Service​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#get-service","content":"顯示系統服務的資訊，例如啟動狀態和服務名稱 ","version":"Next","tagName":"h3"},{"title":"Get-EventLog​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#get-eventlog","content":"檢索系統事件日誌的內容 ","version":"Next","tagName":"h3"},{"title":"Set-ExecutionPolicy​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#set-executionpolicy","content":"設置 PowerShell 腳本執行策略 Set-ExecutionPolicy RemoteSigned  ","version":"Next","tagName":"h3"},{"title":"Get-Host​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#get-host","content":"顯示 PowerShell 主機資訊，包括版本號和運行環境 ","version":"Next","tagName":"h3"},{"title":"cd​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#cd","content":"切換當前目錄 cd C:\\Users  ","version":"Next","tagName":"h3"},{"title":"dir​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#dir","content":"顯示當前目錄中的文件和子目錄 ","version":"Next","tagName":"h3"},{"title":"Copy-Item​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#copy-item","content":"複製文件或文件夾 Copy-Item C:\\source\\fileTxt C:\\destination\\  ","version":"Next","tagName":"h3"},{"title":"Remove-Item​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#remove-item","content":"刪除文件或文件夾 Remove-Item C:\\path\\to\\fileTxt  ","version":"Next","tagName":"h3"},{"title":"New-Item​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#new-item","content":"建立新的文件或文件夾 New-Item -ItemType File -Path C:\\path\\to\\newFileTxt  ","version":"Next","tagName":"h3"},{"title":"Restart-Computer​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#restart-computer","content":"重新啟動電腦 ","version":"Next","tagName":"h3"},{"title":"Stop-Process​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#stop-process","content":"停止指定的 Process Stop-Process -Name notepad  ","version":"Next","tagName":"h3"},{"title":"Test-Connection​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#test-connection","content":"測試與目標主機的連接 Test-Connection google.com  ","version":"Next","tagName":"h3"},{"title":"ipconfig​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#ipconfig","content":"確認本機 ip ","version":"Next","tagName":"h3"},{"title":"ipconfig -all​","type":1,"pageTitle":"🧊 PowerShell 常用指令","url":"/en/docs/daylilyTool/toolShell/aboutPowerShell#ipconfig--all","content":"確認本機 ip 的詳細資訊 ","version":"Next","tagName":"h3"},{"title":"💡 職責鏈模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/behavioral/chainOfResponsibility","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#概述","content":"職責鏈模式是一種行為型設計模式，用於處理複雜的請求，並將請求傳遞給一個或多個處理者，直到有一個處理者能夠處理它 該模式的核心思想是將處理者組成一條鏈，每個處理者都可以決定是否處理請求，並將請求傳遞給下一個處理者 這樣可以實現請求的分離和處理者的解耦 ","version":"Next","tagName":"h2"},{"title":"職責鏈模式主要解決以下問題​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#職責鏈模式主要解決以下問題","content":"優點 分離請求和處理：職責鏈模式將請求的發起和處理者的職責分離，使系統更加靈活呼叫動態組合：可以動態組合不同的處理者，以滿足不同的需求呼叫減少耦合：處理者之間的耦合減少，每個處理者只需關心自己的處理邏輯呼叫 缺點 風險：如果職責鏈設計不當，可能會導致請求無法處理或無法終止呼叫過多的處理者：過多的處理者可能導致性能下降呼叫 ","version":"Next","tagName":"h3"},{"title":"職責鏈模式包含以下角色​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#職責鏈模式包含以下角色","content":"抽象處理者（Handler）：定義處理請求的接口，包括處理請求的方法和設置下一個處理者的方法呼叫具體處理者（Concrete Handler）：實現抽象處理者接口，決定是否處理請求，如果不處理，則將請求傳遞給下一個處理者呼叫請求（Request）：包含需要處理的信息的對象呼叫客戶端（Client）：創建職責鏈，將請求傳遞給職責鏈的第一個處理者呼叫 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義抽象處理者​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#1-定義抽象處理者","content":"// 抽象處理者 public abstract class Handler { protected Handler nextHandler; public void SetNextHandler(Handler handler) { nextHandler = handler; } public abstract void HandleRequest(Request request); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作具體處理者​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#2-實作具體處理者","content":"// 具體處理者A public class ConcreteHandlerA : Handler { public override void HandleRequest(Request request) { if (request.Type == RequestType.TypeA) { Console.WriteLine(&quot;處理 TypeA 請求&quot;); } else if (nextHandler != null) { nextHandler.HandleRequest(request); } } } // 具體處理者B public class ConcreteHandlerB : Handler { public override void HandleRequest(Request request) { if (request.Type == RequestType.TypeB) { Console.WriteLine(&quot;處理 TypeB 請求&quot;); } else if (nextHandler != null) { nextHandler.HandleRequest(request); } } }  ","version":"Next","tagName":"h3"},{"title":"3. 定義請求類型​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#3-定義請求類型","content":"// 請求類型 public enum RequestType { TypeA, TypeB } // 請求類 public class Request { public RequestType Type { get; set; } public Request(RequestType type) { Type = type; } }  ","version":"Next","tagName":"h3"},{"title":"4. 實際使用​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#4-實際使用","content":"class Program { static void Main(string[] args) { // 創建具體處理者 Handler handlerA = new ConcreteHandlerA(); Handler handlerB = new ConcreteHandlerB(); // 設置處理者之間的關係 handlerA.SetNextHandler(handlerB); // 創建請求 Request requestA = new Request(RequestType.TypeA); Request requestB = new Request(RequestType.TypeB); // 處理請求 handlerA.HandleRequest(requestA); handlerA.HandleRequest(requestB); } }  ","version":"Next","tagName":"h3"},{"title":"5. 結果​","type":1,"pageTitle":"💡 職責鏈模式","url":"/en/docs/designPattern/behavioral/chainOfResponsibility#5-結果","content":"輸出: 處理 TypeA 請求 處理 TypeB 請求   在這個範例中，職責鏈模式允許不同的處理者（ConcreteHandlerA 和 ConcreteHandlerB）根據請求的類型來處理請求 如果某個處理者無法處理請求，它會將請求傳遞給下一個處理者，直到有一個處理者能夠處理它 這樣實現了請求的分離和處理者的解耦呼叫 ","version":"Next","tagName":"h3"},{"title":"💡 創造者模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/builder","content":"","keywords":"","version":"Next"},{"title":"Builder Pattern​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#builder-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#概述","content":"它適用於各式物件都需分開建立的複雜情境優點: 容易擴充有一個統一的介面來規範複雜物件的建立分開了物件的建立過程，讓物件建立過程可以建立不同的組合 缺點: 在需求複雜度增加時，需要更多的類別來建立物件，導致開發與維護成本提高 ","version":"Next","tagName":"h2"},{"title":"創造者模式包含​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#創造者模式包含","content":"創造者介面 (Builder interface): 規範建立物件所需要的方法具體創造者 (Concrete Builder): 實作創造者介面的功能指揮者 (Director): 負責處理建立流程產品 (Product): 要被建立的物件 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#範例","content":"需求: 我需要建立一棟房子，房子要有門、有窗、有牆 ","version":"Next","tagName":"h2"},{"title":"1. 先定義產品 - 房子​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#1-先定義產品---房子","content":" internal class House { /// &lt;summary&gt; /// 門 /// &lt;/summary&gt; public string Door { get; set; } /// &lt;summary&gt; /// 牆 /// &lt;/summary&gt; public string Wall { get; set; } /// &lt;summary&gt; /// 窗戶 /// &lt;/summary&gt; public string Window { get; set; } public override string ToString() { return $&quot;房子包含: {Door}、{Wall}、{Window}&quot;; } }  ","version":"Next","tagName":"h3"},{"title":"2. 定義創造者介面​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#2-定義創造者介面","content":" internal abstract class Builder { public abstract void BuildDoor(); public abstract void BuildWall(); public abstract void BuildWindow(); public abstract House GetProduct(); }  ","version":"Next","tagName":"h3"},{"title":"3. 實作創造者介面 - 具體創造者​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#3-實作創造者介面---具體創造者","content":" internal class ConcreteBuilder : Builder { private House _product = new(); public override void BuildDoor() { _product.Door = &quot;門&quot;; } public override void BuildWall() { _product.Wall = &quot;牆壁&quot;; } public override void BuildWindow() { _product.Window = &quot;窗戶&quot;; } public override House GetProduct() { return _product; } }  ","version":"Next","tagName":"h3"},{"title":"4. 建立指揮者​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#4-建立指揮者","content":" internal class Director { public static void Construct(Builder builder) { builder.BuildDoor(); builder.BuildWall(); builder.BuildWindow(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 客戶端使用​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#5-客戶端使用","content":"Builder builder = new ConcreteBuilder(); Director.Construct(builder); var house = builder.GetProduct(); Console.WriteLine(house.ToString());  ","version":"Next","tagName":"h3"},{"title":"6.結果​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#6結果","content":"輸出: 房子包含: 門、牆壁、窗戶  ","version":"Next","tagName":"h3"},{"title":"💡 命令模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/behavioral/command","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#概述","content":"命令模式是一種行為型設計模式，旨在將請求轉換為一個包含請求的獨立物件，使得請求的參數化、排隊、操作和日誌記錄等功能成為可能 這種模式的關鍵點是將發送命令的物件和執行命令的物件進行解耦 ","version":"Next","tagName":"h2"},{"title":"命令模式主要解決以下問題​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#命令模式主要解決以下問題","content":"","version":"Next","tagName":"h2"},{"title":"優點​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#優點","content":"解耦發送者和接收者：發送者無需知道具體的接收者，只需知道如何發送命令即可 可擴展性：易於擴展新的命令和接收者，因為它們是獨立的物件呼叫 支持取消和恢復操作：命令物件可以記錄操作，支持撤銷（取消）和恢復操作 ","version":"Next","tagName":"h3"},{"title":"缺點​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#缺點","content":"額外的類別：引入了許多額外的命令類別，可能會導致類別爆炸 ","version":"Next","tagName":"h3"},{"title":"命令模式包含以下角色​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#命令模式包含以下角色","content":"命令（Command）：定義執行操作的介面，包括一個執行（execute）方法具體命令（Concrete Command）：實現命令介面，通常包括一個接收者物件和實際執行命令的操作發送者（Invoker）：要求命令的物件，將命令發送給相應的接收者接收者（Receiver）：實際執行命令的物件客戶端（Client）：創建具體命令物件，設置其接收者，並將其發送給發送者 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義命令介面​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#1-定義命令介面","content":"// 命令介面 public interface ICommand { void Execute(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作具體命令​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#2-實作具體命令","content":"// 具體命令A public class ConcreteCommandA : ICommand { private Receiver receiver; public ConcreteCommandA(Receiver receiver) { this.receiver = receiver; } public void Execute() { receiver.ActionA(); } } // 具體命令B public class ConcreteCommandB : ICommand { private Receiver receiver; public ConcreteCommandB(Receiver receiver) { this.receiver = receiver; } public void Execute() { receiver.ActionB(); } }  ","version":"Next","tagName":"h3"},{"title":"3. 定義接收者​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#3-定義接收者","content":"// 接收者 public class Receiver { public void ActionA() { Console.WriteLine(&quot;執行 ActionA&quot;); } public void ActionB() { Console.WriteLine(&quot;執行 ActionB&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"4. 實作發送者​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#4-實作發送者","content":"// 發送者 public class Invoker { private ICommand command; public void SetCommand(ICommand command) { this.command = command; } public void ExecuteCommand() { command.Execute(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 實際使用​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#5-實際使用","content":"class Program { static void Main(string[] args) { // 創建接收者 Receiver receiver = new Receiver(); // 創建具體命令 ICommand commandA = new ConcreteCommandA(receiver); ICommand commandB = new ConcreteCommandB(receiver); // 創建發送者 Invoker invoker = new Invoker(); // 設置並執行命令A invoker.SetCommand(commandA); invoker.ExecuteCommand(); // 設置並執行命令B invoker.SetCommand(commandB); invoker.ExecuteCommand(); } }  ","version":"Next","tagName":"h3"},{"title":"6. 結果​","type":1,"pageTitle":"💡 命令模式","url":"/en/docs/designPattern/behavioral/command#6-結果","content":"輸出: 執行 ActionA 執行 ActionB   在這個範例中，命令模式允許將發送者（Invoker）和接收者（Receiver）解耦，並將命令（ICommand）作為一個獨立的物件呼叫，從而實現了命令的參數化和排隊功能 具體命令（ConcreteCommandA和ConcreteCommandB）實現了命令介面，並包含對應的接收者和實際執行的操作 發送者設置具體命令，並執行命令，而不需要了解命令的內部實現這提高了系統的靈活性和可擴展性 ","version":"Next","tagName":"h3"},{"title":"💡 工廠模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/factory/fmp","content":"","keywords":"","version":"Next"},{"title":"Factory Method Pattern​","type":1,"pageTitle":"💡 工廠模式","url":"/en/docs/designPattern/creationalPattern/factory/fmp#factory-method-pattern","content":"工廠模式是最常用的一種設計模式我們通常指的工廠模式指 工廠方法模式簡單工場則是在軟體之中，使用的十分平凡 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 工廠模式","url":"/en/docs/designPattern/creationalPattern/factory/fmp#範例","content":"","version":"Next","tagName":"h2"},{"title":"將圖表功能封裝在一個 Chart 類別中​","type":1,"pageTitle":"💡 工廠模式","url":"/en/docs/designPattern/creationalPattern/factory/fmp#將圖表功能封裝在一個-chart-類別中","content":"public class Chart { private string type; public Chart(object[][] data, string type) { this.type = type; if( type == &quot;histogram&quot;) { // init 柱狀圖 } else if( type == &quot;pie&quot;) { // init 圓餅圖 } else if( type == &quot;line&quot;) { // init 折線圖 } } public void display() { if( type == &quot;histogram&quot;) { // 顯示 柱狀圖 } else if( type == &quot;pie&quot;) { // 顯示 圓餅圖 } else if( type == &quot;line&quot;) { // 顯示 折線圖 } } }  ","version":"Next","tagName":"h3"},{"title":"缺點​","type":1,"pageTitle":"💡 工廠模式","url":"/en/docs/designPattern/creationalPattern/factory/fmp#缺點","content":"Chart 裡面存在著非常多的 if - else ，code 非常的壟長、難以閱讀，並且難以維護與測試，尤其經過大量的條件句後也會對效能造成影響而且將初始化都集中在一個 class 中違反了單一原則，不利於程式碼的重用性與維護當需要新增新的 Chart 時，需要修改 Chart class，違反了開閉原則客戶端只能透過 new 關鍵字來實例化 Chart ，Chart class 與客戶端耦合度高，實例化與物件無法分離客戶端如果想要更彈性的使用 Chart 的話，比如說:顏色、高度等等，構造函數則無提供初始化的功能，那每次都得由客戶端來完成，那容易造成大量重複的程式碼 以上會成 高耦合，多職責，因此延伸出了簡單工廠設計模式，他在一定的程度上解決了以上的問題 ","version":"Next","tagName":"h2"},{"title":"💡 抽象工廠","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory","content":"","keywords":"","version":"Next"},{"title":"Abstract Factory​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#abstract-factory","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#概述","content":"他用於創建物件的類別提供一個 interface ，並且建立相關的物件在使用時不用去指定他具體的類別 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#範例","content":"首先我們有一個需求，會有一個車廠來生產各式車輛 ","version":"Next","tagName":"h2"},{"title":"1. 先建立一個汽車的 interface​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#1-先建立一個汽車的-interface","content":" internal interface ICar { /// &lt;summary&gt; /// 取得車種 /// &lt;/summary&gt; /// &lt;returns&gt;車種&lt;/returns&gt; string GetCarType(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作 跑車 與 家庭車 類別​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#2-實作-跑車-與-家庭車-類別","content":" /// &lt;summary&gt; /// 跑車 /// &lt;/summary&gt; internal class SportsCar : ICar { /// &lt;summary&gt; /// 取得車種 /// &lt;/summary&gt; /// &lt;returns&gt;跑車&lt;/returns&gt; public string GetCarType() { return &quot;Sports Car&quot;; } } /// &lt;summary&gt; /// 家庭式 /// &lt;/summary&gt; internal class FamilyCar : ICar { /// &lt;summary&gt; /// 取得車種 /// &lt;/summary&gt; /// &lt;returns&gt;家庭車&lt;/returns&gt; public string GetCarType() { return &quot;Family Car&quot;; } }  ","version":"Next","tagName":"h3"},{"title":"3. 建立抽象工廠 interface​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#3-建立抽象工廠-interface","content":" internal interface ICarFactory { /// &lt;summary&gt; /// 創建車輛實體 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; ICar CreateCar(); }  ","version":"Next","tagName":"h3"},{"title":"4. 實作 跑車工廠 與 家庭車工廠​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#4-實作-跑車工廠-與-家庭車工廠","content":" /// &lt;summary&gt; /// 跑車工廠 /// &lt;/summary&gt; internal class SportsCarFactory : ICarFactory { /// &lt;summary&gt; /// 取得車輛實體 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public ICar CreateCar() { return new SportsCar(); } } /// &lt;summary&gt; /// 家庭車工廠 /// &lt;/summary&gt; internal class FamilyCarFactory : ICarFactory { /// &lt;summary&gt; /// 取得車輛實體 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public ICar CreateCar() { return new FamilyCar(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 實際生產​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#5-實際生產","content":" ICarFactory factory; Console.WriteLine(&quot;請輸入要生產的車種代號:&quot;); Console.WriteLine(@&quot;1. 跑車 2. 家庭車&quot;); string carNo = Console.ReadLine(); switch (carNo) { case &quot;1&quot;: factory = new SportsCarFactory(); break; case &quot;2&quot;: factory = new FamilyCarFactory(); break; default: throw new Exception(&quot;無此車種&quot;); } ICar car = factory.CreateCar(); Console.WriteLine($&quot;生產 {car.GetCarType()} X 1&quot;);  ","version":"Next","tagName":"h3"},{"title":"6. 結果​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#6-結果","content":"輸入 1輸出 請輸入要生產的車種代號: 1. 跑車 2. 家庭車 1 生產 Sports Car X 1  輸入 2輸出 請輸入要生產的車種代號: 1. 跑車 2. 家庭車 2 生產 Family Car X 1  ","version":"Next","tagName":"h3"},{"title":"💡 簡單工廠","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/factory/sfp","content":"","keywords":"","version":"Next"},{"title":"Simple Factory Pattern​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#simple-factory-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#概述","content":"他不屬於 GoF 23 經典設計模式不過他常常被拿來當作學習其他工廠模式的基礎主要概念為: 傳入正確參數，就可以獲得所需要的物件，而且不需知道細節由於建立物件通常由靜態函式實現，因此又稱 靜態工廠方法 ","version":"Next","tagName":"h2"},{"title":"優缺點​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#優缺點","content":"優點: 可以將建立物件，與物件的使用分離開發者不用知道類別的名稱，只需要知道參數的代號即可，可大幅減少使用複查命名的錯誤率如果參數透過檔案傳入，那可以增加系統的靈活性 缺點: 由於它包含了所有類別的建立，因使職責極重，當他無法運作會對系統造成極大的影響如果產品很多，容易造成系統的複雜度提高與程式可讀性降低不易擴展，每當有新的產品加入，就不得不修改工廠邏輯 ","version":"Next","tagName":"h2"},{"title":"應用場景​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#應用場景","content":"需建立的產品比較少，才不會對提高工廠的複雜維度客戶端只需要知道參數即可，對如何建立物件無須知道 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 建立報表介面​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#1-建立報表介面","content":"public interface IChart { void display(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作介面​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#2-實作介面","content":"public class HistogramChart:IChart { public void display() { // 顯示 柱狀圖 } } public class PiChart:IChart { public void display() { // 顯示 圓餅圖 } } public class LineChart:IChart { public void display() { // 顯示 折線圖 } }  ","version":"Next","tagName":"h3"},{"title":"3. 建立列舉​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#3-建立列舉","content":"public enum ChartType { histogram, pie, line }  ","version":"Next","tagName":"h3"},{"title":"4. 工廠類別​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#4-工廠類別","content":"public class Factory { // 靜態工廠方法 public static IChart GetChart(ChartType chartType) { switch (chartType) { case ChartType.histogram : return new HistogramChart(); case ChartType.pie : return new PiChart(); case ChartType.line : return new LineChart(); default: throw new Exception(&quot;無此類型的報表!&quot;); } } }  ","version":"Next","tagName":"h3"},{"title":"5. 實際使用​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#5-實際使用","content":"void Main() { // 柱狀圖 Factory.GetChart(ChartType.histogram).display(); // 圓餅圖 Factory.GetChart(ChartType.pie).display(); // 折線圖 Factory.GetChart(ChartType.line).display(); }  ","version":"Next","tagName":"h3"},{"title":"簡單工廠角色​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#簡單工廠角色","content":"由簡單工廠的結構中，可以歸納出以下幾個角色 ","version":"Next","tagName":"h2"},{"title":"1. 工廠角色 Factory​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#1-工廠角色-factory","content":"他是整個模式的核心，負責實現所有產品應該為靜態方法必須回傳抽象類別 ","version":"Next","tagName":"h3"},{"title":"2. 抽象產品角色 Product​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#2-抽象產品角色-product","content":"為所有商品的父類他必須定義所有商品的規格也會是工廠回傳的對象 ","version":"Next","tagName":"h3"},{"title":"3. 實際產品角色 Concrete​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#3-實際產品角色-concrete","content":"是工廠角色實現的目標必須繼承並實作抽象產品 由於需要對抽象商品進行重構\\ 因此商品規格不可以包山包海\\ 應該為單一層次的結構 ","version":"Next","tagName":"h3"},{"title":"💡 原型模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/prototype","content":"","keywords":"","version":"Next"},{"title":"Prototype Pattern​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#prototype-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#概述","content":"可複製一個物件，並把原有的狀態都傳遞給新的物件優點: 可以降低建立物件的成本缺點: 如需要實現 ICloneable 介面, 有時會使程式碼變得複雜，也不容易控制物件的狀態 ","version":"Next","tagName":"h2"},{"title":"原型模式包含​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#原型模式包含","content":"原型介面（Prototype Interface）：定義了用於創建複製的方法原型物件 （Concrete Prototype）： 實作原型介面的類別客戶端（Client）：使用原型創建新物件 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#範例","content":"今天有一個定義 x y 的類別，我需要複製並沿用他的 x y 設定 ","version":"Next","tagName":"h2"},{"title":"1. 首先定義一個原型 interface​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#1-首先定義一個原型-interface","content":" internal interface IPrototype { IPrototype Clone(); }  ","version":"Next","tagName":"h3"},{"title":"2. 建立定義 x y 的類別​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#2-建立定義-x-y-的類別","content":" internal class ConcretePrototypeA : IPrototype { public int x; public int y; public string? Name; /// &lt;summary&gt; /// 深拷貝介面 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public IPrototype Clone() { return (IPrototype)MemberwiseClone(); } public override string ToString() { return $&quot;x = {x}, y = {y}, Name = {Name}&quot;; } }  ","version":"Next","tagName":"h3"},{"title":"3. 使用​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#3-使用","content":"ConcretePrototypeA prototypeA = new() { x = 1, y = 2, Name = &quot;ProtoTypeA&quot; }; Console.WriteLine(prototypeA.ToString()); ConcretePrototypeA prototypeAClone = (ConcretePrototypeA)prototypeA.Clone(); prototypeAClone.Name = &quot;ProtoTypeAClone&quot;; Console.WriteLine(prototypeAClone.ToString());  ","version":"Next","tagName":"h3"},{"title":"4. 結果​","type":1,"pageTitle":"💡 原型模式","url":"/en/docs/designPattern/creationalPattern/prototype#4-結果","content":"輸出: x = 1, y = 2, Name = ProtoTypeA x = 1, y = 2, Name = ProtoTypeAClone  ","version":"Next","tagName":"h3"},{"title":"💡 單例模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/singleton","content":"","keywords":"","version":"Next"},{"title":"Singleton Pattern​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#singleton-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#概述","content":"單例模式用於確保一個類別僅有一個實例存在，並提供一個全域訪問點來取得這個實例。 ","version":"Next","tagName":"h2"},{"title":"單例模式主要解決以下兩個問題​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#單例模式主要解決以下兩個問題","content":"優點 控制實例數量：單例模式確保一個類別只能有一個實例。這對於某些場景很有用，例如: 限制系統中某些資源的使用量或確保某個物件的狀態全域的提供全域訪問點：單例模式提供一個全域的方式來訪問唯一實例。這使得其他部分能夠輕鬆地取得這個實例並進行操作，而不需要知道詳細的實例創建邏輯 缺點 為了解決這兩個問題，導致單例模式違反單一原則單一職責原則強調一個類別應該只有一個變化的原因，即只有一個職責。單例模式在保護唯一實例的同時，往往也包含了該類別的創建邏輯，導致這個類別承擔了兩個職責 ","version":"Next","tagName":"h3"},{"title":"單例模式包含​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#單例模式包含","content":"單例類別（Singleton Class）：確保只有一個實例存在並提供一個全域訪問點來取得這個唯一實例，這個類別會將其構造函數設為私有（private）唯一實例（Singleton Instance）：這是單例模式中唯一存在的實例，該實例通常是由單例類別在內部自行創建並保持著創建方法（Creation Method）：通常是一個靜態（static）方法，負責在需要時創建唯一實例並返回給呼叫者 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#範例","content":"以「家」為例，房子就可以視為一個類別，而這個類別只能有一個實例，即這座房子。在這個例子中，房子的建造與拆除是由房屋公司掌管的，它們允許你透過特定的機制，只能取得這一座特定的房子實例 ","version":"Next","tagName":"h2"},{"title":"1. 唯一實例（Singleton Instance）​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#1-唯一實例singleton-instance","content":" // 宣告一個私有靜態變數來保存唯一的實例 private static House instance;  ","version":"Next","tagName":"h3"},{"title":"2. 單例類別（Singleton Class）​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#2-單例類別singleton-class","content":"public class House { // 宣告一個私有靜態變數來保存唯一的實例 private static House instance; // 宣告私有建構函式，防止外部實例化 private House() { // 在此處初始化房子的一些屬性 } public void OpenDoor() { Console.WriteLine(&quot;房子的門打開了。&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"3. 創建方法（Creation Method）​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#3-創建方法creation-method","content":"public class House { // 宣告一個私有靜態變數來保存唯一的實例 private static House instance; // 宣告私有建構函式，防止外部實例化 private House() { // 在此處初始化房子的一些屬性 } // 提供一個全域的訪問點，讓客戶端程式碼可以取得這唯一的實例 public static House GetInstance() { // 如果還沒有建立實例，則建立一個新的實例 if (instance == null) { instance = new House(); } // 回傳唯一的實例 return instance; } public void OpenDoor() { Console.WriteLine(&quot;房子的門打開了。&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"4. 實際使用​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#4-實際使用","content":"public class Program { static void Main(string[] args) { // 取得房子的實例 House myHouse = House.GetInstance(); // 嘗試取得另一個實例，但因為單例模式的限制，實際上會取得同一個實例 House anotherHouse = House.GetInstance(); // 檢查兩個實例是否相同 if (myHouse == anotherHouse) { Console.WriteLine(&quot;兩個房子實例是相同的&quot;); } else { Console.WriteLine(&quot;這裡不應該被執行，因為單例模式限制了只能有一個實例&quot;); } // 使用房子的方法 myHouse.OpenDoor(); // 輸出結果： // 兩個房子實例是相同的。 // 房子的門打開了。 } }  ","version":"Next","tagName":"h3"},{"title":"5. 結果​","type":1,"pageTitle":"💡 單例模式","url":"/en/docs/designPattern/creationalPattern/singleton#5-結果","content":"輸出:  兩個房子實例是相同的 房子的門打開了  ","version":"Next","tagName":"h3"},{"title":"💡 依賴反轉原則","type":0,"sectionRef":"#","url":"/en/docs/designPattern/oop/dip","content":"","keywords":"","version":"Next"},{"title":"dependency inversion principle​","type":1,"pageTitle":"💡 依賴反轉原則","url":"/en/docs/designPattern/oop/dip#dependency-inversion-principle","content":"抽象不應該依賴於細節，細節則應該要依賴於抽象因此我們需要先寫出抽象介面，在實作功能所有類別都要相依於抽象，而不是具體的實作可透過 DI Container 達到目的為了達到低耦合的目的 所有的類別之間都需要透過抽象介面 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 依賴反轉原則","url":"/en/docs/designPattern/oop/dip#範例","content":"","version":"Next","tagName":"h2"},{"title":"controller​","type":1,"pageTitle":"💡 依賴反轉原則","url":"/en/docs/designPattern/oop/dip#controller","content":"public class UserController { private readonly IUserService userService // DI public UserController( IUserService userService ) { this.userService = userService; } }  ","version":"Next","tagName":"h3"},{"title":"service​","type":1,"pageTitle":"💡 依賴反轉原則","url":"/en/docs/designPattern/oop/dip#service","content":"public interface IUserService { //define function } public class UserService:IUserService { // Do something }  ","version":"Next","tagName":"h3"},{"title":"💡 介面隔離原則","type":0,"sectionRef":"#","url":"/en/docs/designPattern/oop/isp","content":"","keywords":"","version":"Next"},{"title":"interface segregation principle​","type":1,"pageTitle":"💡 介面隔離原則","url":"/en/docs/designPattern/oop/isp#interface-segregation-principle","content":"確保模組之間的耦合度低所有模組之間的依賴關係應該要依賴他們所需要的 interface確保後續的維護與修改可以更容易的進行 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 介面隔離原則","url":"/en/docs/designPattern/oop/isp#範例","content":"動物的介面 public interface IAnimal { //吃 void Eat(); //睡覺 void Sleep(); }  貓咪類別 public class Cat : IAnimal { public void Eat() { // Eat implementation } public void Sleep() { // Sleep implementation } }  狗狗類別 public class Dog : IAnimal { public void Eat() { // Eat implementation } public void Sleep() { // Sleep implementation } }  ","version":"Next","tagName":"h2"},{"title":"💡 里氏替換原則","type":0,"sectionRef":"#","url":"/en/docs/designPattern/oop/lsp","content":"","keywords":"","version":"Next"},{"title":"Liskov substitution principle​","type":1,"pageTitle":"💡 里氏替換原則","url":"/en/docs/designPattern/oop/lsp#liskov-substitution-principle","content":"子類別可以擴充父類的功能，但不可以改變它原有的功能實作繼承後，需要確保他的型別被轉換後還可以獲得正確的結果只有在類別之間是 is-a 關係時才能用繼承 ","version":"Next","tagName":"h2"},{"title":"必須符合四個繼承的規範​","type":1,"pageTitle":"💡 里氏替換原則","url":"/en/docs/designPattern/oop/lsp#必須符合四個繼承的規範","content":"完全實作父類的方法子類別可以擁有他自己的特性Overload 時要注意傳入參數型別的父子關係輸出的父子關係也需要注意 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 里氏替換原則","url":"/en/docs/designPattern/oop/lsp#範例","content":"using System; // 父類 Animal public class Animal { // 父類方法 MakeSound public virtual void MakeSound() { Console.WriteLine(&quot;The animal makes a sound.&quot;); } } // 子類 Dog public class Dog : Animal { // 子類重寫父類方法 MakeSound public override void MakeSound() { Console.WriteLine(&quot;The dog barks.&quot;); } // 子類自己的方法 Fetch public void Fetch() { Console.WriteLine(&quot;The dog fetches the ball.&quot;); } } // 子類 Cat public class Cat : Animal { // 子類重寫父類方法 MakeSound public override void MakeSound() { Console.WriteLine(&quot;The cat meows.&quot;); } // 子類自己的方法 Scratch public void Scratch() { Console.WriteLine(&quot;The cat scratches the furniture.&quot;); } } public class Program { public static void Main(string[] args) { // 使用父類引用變數指向子類對象 Animal animal1 = new Dog(); animal1.MakeSound(); // 輸出: The dog barks. Animal animal2 = new Cat(); animal2.MakeSound(); // 輸出: The cat meows. // 調用子類特有的方法 Dog dog = new Dog(); dog.Fetch(); // 輸出: The dog fetches the ball. Cat cat = new Cat(); cat.Scratch(); // 輸出: The cat scratches the furniture. } }  ","version":"Next","tagName":"h2"},{"title":"💡 開閉原則","type":0,"sectionRef":"#","url":"/en/docs/designPattern/oop/ocp","content":"","keywords":"","version":"Next"},{"title":"open/closed principle​","type":1,"pageTitle":"💡 開閉原則","url":"/en/docs/designPattern/oop/ocp#openclosed-principle","content":"程式碼都有可能因為需求的增加需要擴充而擴充不應該修改原始的程式碼應該新增加是程式碼來擴充原本的系統 ","version":"Next","tagName":"h2"},{"title":"可擴充的作法​","type":1,"pageTitle":"💡 開閉原則","url":"/en/docs/designPattern/oop/ocp#可擴充的作法","content":"透過繼承C# 有擴充方法 ","version":"Next","tagName":"h2"},{"title":"範例: 需要可以支援各式圖表​","type":1,"pageTitle":"💡 開閉原則","url":"/en/docs/designPattern/oop/ocp#範例-需要可以支援各式圖表","content":"","version":"Next","tagName":"h2"},{"title":"1. 初期方案​","type":1,"pageTitle":"💡 開閉原則","url":"/en/docs/designPattern/oop/ocp#1-初期方案","content":"圓餅圖類 public class PicChart { public void display() { // Create pie chart } }  柱狀圖類 public class BarChart { public void display() { // Create bar chart } }  service public class ChartService { public void displayChart(string type) { switch(type) { case type.Equals(&quot;pie&quot;) : PicChart chart = new PicChart(); chart.display(); case type.Equals(&quot;bar&quot;) : BarChart chart = new BarChart(); chart.display(); } } }  ","version":"Next","tagName":"h3"},{"title":"2. 使用 OCP 原則重構​","type":1,"pageTitle":"💡 開閉原則","url":"/en/docs/designPattern/oop/ocp#2-使用-ocp-原則重構","content":"圖表介面 public interface IChart { void display(); }  圓餅圖類 public class PicChart : IChart { public void display() { // Create pie chart } }  柱狀圖類 public class BarChart : IChart { public void display() { // Create bar chart } }  service public class ChartService { // 工廠模式 private IChart SetChart(string type) { switch(type) { case type.Equals(&quot;pie&quot;) : return new PicChart(); case type.Equals(&quot;bar&quot;) : return new BarChart(); default throw new NotImplementedException(); } } public void displayChart(string type) { IChart chart = SetChart(type); chart.display(); } }  ","version":"Next","tagName":"h3"},{"title":"💡 物件導向設計原則概述","type":0,"sectionRef":"#","url":"/en/docs/designPattern/oop/oopOverview","content":"","keywords":"","version":"Next"},{"title":"物件導向設計​","type":1,"pageTitle":"💡 物件導向設計原則概述","url":"/en/docs/designPattern/oop/oopOverview#物件導向設計","content":"物件導向設計中主要目標為增加系統的可維護性與複用性最常見的物件導向設計原則為 SOLID 名稱\t定義單一責任原則 (SRP) Single Responsibility Principle\t一個類別應該只有一個改變的理由！ A class should have only one reason to change 開放封閉原則 (OCP) Open Closed Principle\t軟體實體 (類別、模組、函式等) 應能開放擴充但封閉修改 Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification 里氏替換原則 (LSP) Liskov Substitution Principle\t子型別必需可替換為他的基底型別 Subtypes must be substitutable for their base types 介面隔離原則 (ISP) Interface Segregation Principle\t多個用戶端專用的介面優於一個通用需求介面 Many client specific interfaces are better than one general purpose interface 依賴反轉原則 (DIP) Dependency Inversion Principle\t抽象不應該相依於細節。而細節則應該相依於抽象 Abstractions should not depend on details. Details should depend on abstractions ","version":"Next","tagName":"h2"},{"title":"💡 單一責任原則","type":0,"sectionRef":"#","url":"/en/docs/designPattern/oop/srp","content":"","keywords":"","version":"Next"},{"title":"single repository principle​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#single-repository-principle","content":"責任(Responsibility)強調高內聚，低耦合需將責任封裝於各個 class 之中如果多個職責總是同時發生，可將其封裝於同一 class 之中 Public class CustomerDataChart{ // connection Public void getConnection() { //TODO : connection to DB } // Read Public List&lt;CustomersDto&gt; Read() { // TODO : SELECT * FROM Custorm } // create Public void Creat(CustomersDto data) { // TODO : create } // 顯示圖表 Public void displayChart() { // TODO : Show chart } }  ","version":"Next","tagName":"h2"},{"title":"由以上程式碼可以發現​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#由以上程式碼可以發現","content":"一個 class 之中包含了 資料庫連線查詢新增修改 此 class 違背了單一職責如果需要修改資料庫連線方式 ","version":"Next","tagName":"h2"},{"title":"以單一職責進行重構​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#以單一職責進行重構","content":"首先可以將其分為三個 Class DBUtil - 資料庫連線CustomerDAO - 對 Customer 進行增刪改查CustomerDataChart - 負責圖表生成 ","version":"Next","tagName":"h2"},{"title":"1. DBUtil​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#1-dbutil","content":"Public class DBUtil { //DB connection Public void getConnection() { // TODO : connection to db } }  ","version":"Next","tagName":"h3"},{"title":"2. CustomerDao​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#2-customerdao","content":"Public class CustomerDao { // Read Public List&lt;CustomersDTO&gt; Read() { // TODO : get data list } // Create Public void Create() { // TODO : Create data } }  ","version":"Next","tagName":"h3"},{"title":"3. CustomerDataChart​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#3-customerdatachart","content":"Public class CustomerDataChart { Public void displayChart() { // TODO : show chart } }  ","version":"Next","tagName":"h3"},{"title":"常見問題​","type":1,"pageTitle":"💡 單一責任原則","url":"/en/docs/designPattern/oop/srp#常見問題","content":"將所有功能寫在同一個 class 造成 class 複雜度過高維護或修改時找不到問題使用 class 時不知道要呼叫哪個 function切分太細時會造成高耦合度的問題 ","version":"Next","tagName":"h2"},{"title":"💡 設計模式概述(一)","type":0,"sectionRef":"#","url":"/en/docs/designPattern/overview1","content":"","keywords":"","version":"Next"},{"title":"設計模式的起源​","type":1,"pageTitle":"💡 設計模式概述(一)","url":"/en/docs/designPattern/overview1#設計模式的起源","content":"設計模式的誕生 : 出自於 Christopher Alexander&lt;哈佛大學建築學博士&gt;，號稱 The father of patternsChristopher Alexander 與其團隊用了將近 20 年的時間，調查住宅周邊環境他們發現人們對舒適的住宅與城市環境之間存在著一些共同的認同定律Christopher Alexander 在著作 A Pattern Language: Towns, Buildings, Construction 中把這些認同規律歸納為 253 个模式每個模式都是從 Context(前提條件)Theme 或 Problem（目標問題）Solution（解決方案） 後來 Christopher Alexander 給出了一個建議: A pattern is a successful or efficient solution to a recurring problem within a context 模式是在特定環境下人們解決某類重複出現問題的一套成功獲有效的解決方案  ","version":"Next","tagName":"h2"},{"title":"設計模式思想的引用​","type":1,"pageTitle":"💡 設計模式概述(一)","url":"/en/docs/designPattern/overview1#設計模式思想的引用","content":"1990 年，軟體工程界開始關注 Christopher Alexander 在住宅領域的突破在 1991~1992 年間由四位軟體工程的學者，將其引入程式開發中在 1994 年歸納並發表出 23 種常用的設計模式主要用模式來統一溝通物件導向在 1. 溝通 2. 設計 3.開發之間的代溝 軟體模式(Software Patterns)就此誕生，軟體開發的生命週期上都存在著一些被認同的模式 軟體模式示圖: ","version":"Next","tagName":"h2"},{"title":"💡 設計模式概述(二)","type":0,"sectionRef":"#","url":"/en/docs/designPattern/overview2","content":"","keywords":"","version":"Next"},{"title":"設計模式是什麼？​","type":1,"pageTitle":"💡 設計模式概述(二)","url":"/en/docs/designPattern/overview2#設計模式是什麼","content":"設計模式（Design Pattern）是一套 可以反覆使用多數人知曉經過分類 使用設計模式是為了 可以重複使用程式提升可讀性降低出錯率 ","version":"Next","tagName":"h2"},{"title":"模式名稱(Patten Name)​","type":1,"pageTitle":"💡 設計模式概述(二)","url":"/en/docs/designPattern/overview2#模式名稱patten-name","content":"設計模式包含: 名稱問題 (Problem): 包含設計中存在的問題與問題存在的原因目的解決方案(Solution):描述設計模式的組成，各自的職責與協作方式 藉由模式名稱來描述設計模式包含的項目，以達到最有效的溝通大多數的模式都是使用其功能，或是模式結構來命名的 ","version":"Next","tagName":"h2"},{"title":"設計模式​","type":1,"pageTitle":"💡 設計模式概述(二)","url":"/en/docs/designPattern/overview2#設計模式","content":"設計模式可分為: 創建型(Creational) -&gt; 描述如何建立物件結構型(Structural) -&gt; 描述如何實現類別與物件的組合行為型(Behavioral) -&gt; 用於描述類別與物件之間怎樣交互及怎樣分配職責 此外設計模式也可以分為: 類別模式 -&gt; 例如:模板方法是類別行為型模式物件模式 -&gt; 例如:單例模式是物件創建型模式 ","version":"Next","tagName":"h2"},{"title":"創建型模式 - Creational Pattern​","type":1,"pageTitle":"💡 設計模式概述(二)","url":"/en/docs/designPattern/overview2#創建型模式---creational-pattern","content":"模式名稱單例模式 Singleton Pattern 簡單工廠模式 Simple Factory Pattern 工廠方法模式 Factory Method Pattern 抽象工廠模式 Abstract Factory Pattern 原型模式 Prototype Pattern 建造者模式 Builder Pattern ","version":"Next","tagName":"h3"},{"title":"結構型模式 - Structural Pattern​","type":1,"pageTitle":"💡 設計模式概述(二)","url":"/en/docs/designPattern/overview2#結構型模式---structural-pattern","content":"模式名稱轉接器模式 Adapter Pattern 橋接模式 Bridge Pattern 組合模式 Composite Pattern 裝飾器模式 Decorator Pattern 門面模式 Facade Pattern 享元模式 Flyweight Pattern 代理模式 Proxy Pattern ","version":"Next","tagName":"h3"},{"title":"行為模式 - Behavioral Pattern​","type":1,"pageTitle":"💡 設計模式概述(二)","url":"/en/docs/designPattern/overview2#行為模式---behavioral-pattern","content":"模式名稱職責鏈模式 Chain of Responsibility Pattern 命令模式 Command Pattern 解釋器模式 Interpreter Pattern 迭代器模式 Iterator Pattern 中介者模式 Mediator Pattern 備忘錄模式 Memento Pattern 觀察者模式 Observer Pattern 狀態模式 State Pattern 策略模式 Strategy Pattern 模板方法模式 Template Method Pattern 訪問者模式 Visitor Pattern ","version":"Next","tagName":"h3"},{"title":"💡 設計模式概述(三)","type":0,"sectionRef":"#","url":"/en/docs/designPattern/overview3","content":"","keywords":"","version":"Next"},{"title":"設計模式的用途​","type":1,"pageTitle":"💡 設計模式概述(三)","url":"/en/docs/designPattern/overview3#設計模式的用途","content":"提高可複用與維護性 : 設計模式經過各專家的經驗與智慧，設計模式可以提高我們的開發與效率方便溝通與交流 : 由於設計模式上有一套通用的設計詞彙，因此在溝通上可以相互理解提高擴充性 : 在系統日益增大，可擴充性與維護性，增加系統的靈活性與擴充性統一思路 :如果大家都以設計模式為主軸，那將有助於別人更快的理解系統 ","version":"Next","tagName":"h2"},{"title":"💡 轉接器模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/adapter","content":"","keywords":"","version":"Next"},{"title":"Adapter Pattern​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#adapter-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#概述","content":"在寫程式的過程中，我們經常會面臨不能修改原始碼或不允許修改的情況。轉接器模式就是為了解決這種情境而出現的設計模式它允許我們在不修改原有類的情況下，將其與客戶端代碼相適配 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#範例","content":"需求: 需要依照不同的情境，來輸出不同的檔案格式 ","version":"Next","tagName":"h2"},{"title":"1. 以下是目前現有的輸出檔案程式​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#1-以下是目前現有的輸出檔案程式","content":" internal interface IFileWitter { void Write(); } internal class JsonFileWitter : IFileWitter { public void Write() { Console.WriteLine(&quot;File.json&quot;); } } internal class CsvFileWitter : IFileWitter { public void Write() { Console.WriteLine(&quot;File.csv&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"2. 在不異動現有輸出檔案程式的情況下，我們需要新增一層轉接器​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#2-在不異動現有輸出檔案程式的情況下我們需要新增一層轉接器","content":" internal interface IFileTool { void Create(); } internal class Adapter : IFileTool { private readonly IFileWitter _tool; public Adapter(IFileWitter tool) { _tool = tool; } public void Create() { _tool.Write(); } }  ","version":"Next","tagName":"h3"},{"title":"3. 此處用簡單工廠來建立轉接器，並注入輸出檔案的類別​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#3-此處用簡單工廠來建立轉接器並注入輸出檔案的類別","content":" internal static class FileTool { public static IFileTool Factory(string fileType) { return fileType switch { &quot;json&quot; =&gt; new Adapter(new JsonFileWitter()), &quot;csv&quot; =&gt; new Adapter(new CsvFileWitter()), _ =&gt; throw new ArgumentException($&quot;尚未實做 {fileType}&quot;), }; } }  ","version":"Next","tagName":"h3"},{"title":"4. 客戶端使用​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#4-客戶端使用","content":"FileTool.Factory(&quot;json&quot;).Create(); FileTool.Factory(&quot;csv&quot;).Create();  ","version":"Next","tagName":"h3"},{"title":"5. 結果​","type":1,"pageTitle":"💡 轉接器模式","url":"/en/docs/designPattern/structuralPattern/adapter#5-結果","content":"輸出: File.json File.csv  ","version":"Next","tagName":"h3"},{"title":"💡 組合模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/composite","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#概述","content":"組合模式是一種結構性設計模式，用於將物件組合成樹狀結構，表示部分-整體層次結構組合模式使客戶可以以一致的方式處理單一物件和物件組合 ","version":"Next","tagName":"h2"},{"title":"組合模式主要解決以下問題​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#組合模式主要解決以下問題","content":"","version":"Next","tagName":"h2"},{"title":"優點​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#優點","content":"客戶端代碼不需要區分葉子物件和容器物件，可以統一處理它們簡化客戶端代碼，減少使用條件語句的需求可輕鬆添加新類型的組件，無需更改現有客戶端代碼 ","version":"Next","tagName":"h3"},{"title":"缺點​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#缺點","content":"限制了組件類型，某些操作可能無法在所有組件上執行，需要客戶端進行類型檢查 ","version":"Next","tagName":"h3"},{"title":"組合模式包含​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#組合模式包含","content":"組件（Component）角色：定義葉子和容器物件的通用接口，以便客戶端以一致的方式操作它們葉節點（Leaf）角色：組合中的葉子節點，沒有子節點容器（Composite）角色：組合中的容器節點，可以包含子節點，包括葉子和其他容器客戶端（Client）角色：使用組合模式的客戶端代碼，以統一的方式處理葉子和容器物件 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義 Component 介面​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#1-定義-component-介面","content":"public interface IComponent { void Operation(); }  ","version":"Next","tagName":"h3"},{"title":"2. 定義葉節點角色​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#2-定義葉節點角色","content":"public class Leaf : IComponent { public void Operation() { Console.WriteLine(&quot;葉節點操作&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"3. 定義容器角色​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#3-定義容器角色","content":"public class Composite : IComponent { private List&lt;IComponent&gt; children = new List&lt;IComponent&gt;(); public void Add(IComponent component) { children.Add(component); } public void Remove(IComponent component) { children.Remove(component); } public void Operation() { Console.WriteLine(&quot;容器操作&quot;); foreach (IComponent child in children) { child.Operation(); } } }  ","version":"Next","tagName":"h3"},{"title":"4. 主程式​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#4-主程式","content":"class Program { static void Main(string[] args) { IComponent leaf1 = new Leaf(); IComponent leaf2 = new Leaf(); Composite composite = new Composite(); composite.Add(leaf1); composite.Add(leaf2); IComponent leaf3 = new Leaf(); Composite root = new Composite(); root.Add(composite); root.Add(leaf3); root.Operation(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 結果​","type":1,"pageTitle":"💡 組合模式","url":"/en/docs/designPattern/structuralPattern/composite#5-結果","content":"容器操作 葉節點操作 葉節點操作 葉節點操作 ","version":"Next","tagName":"h3"},{"title":"💡 裝飾者模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/decorator","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#概述","content":"裝飾者模式是一種結構型設計模式，它允許你在不修改現有物件的情況下，動態地將新行為添加到物件這種模式是繼承的一個替代方案，可以用來擴充 class 的功能 裝飾者模式通常涉及一個抽象組件（Component），具體組件（ConcreteComponent），裝飾者（Decorator），以及具體裝飾者（ConcreteDecorator）抽象組件定義了介面，具體組件實現了具體的功能，裝飾者包含一個指向抽象組件的引用並實現了相同的介面，具體裝飾者擴充了裝飾者並添加了新的功能 ","version":"Next","tagName":"h2"},{"title":"裝飾者模式的主要優點​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#裝飾者模式的主要優點","content":"靈活性：你可以動態添加新功能，而不需要修改現有代碼開放/封閉原則：不需要修改現有代碼，就可以擴充物件的行為簡單性：你可以用多個簡單的裝飾者組合來實現複雜的功能，而不需要一個龐大的類層次結構 ","version":"Next","tagName":"h2"},{"title":"裝飾者模式的範例​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#裝飾者模式的範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義 Component 介面​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#1-定義-component-介面","content":"public interface IComponent { void Operation(); }  ","version":"Next","tagName":"h3"},{"title":"2. 定義具體組件​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#2-定義具體組件","content":"public class ConcreteComponent : IComponent { public void Operation() { Console.WriteLine(&quot;具體組件操作&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"3. 定義裝飾者抽象類別​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#3-定義裝飾者抽象類別","content":"public abstract class Decorator : IComponent { protected IComponent component; public Decorator(IComponent component) { this.component = component; } public virtual void Operation() { component.Operation(); } }  ","version":"Next","tagName":"h3"},{"title":"4. 定義具體裝飾者​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#4-定義具體裝飾者","content":"public class ConcreteDecoratorA : Decorator { public ConcreteDecoratorA(IComponent component) : base(component) { } public override void Operation() { base.Operation(); Console.WriteLine(&quot;具體裝飾者 A 的操作&quot;); } }  public class ConcreteDecoratorB : Decorator { public ConcreteDecoratorB(IComponent component) : base(component) { } public override void Operation() { base.Operation(); Console.WriteLine(&quot;具體裝飾者 B 的操作&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"5. 主程式​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#5-主程式","content":"class Program { static void Main(string[] args) { IComponent component = new ConcreteComponent(); Decorator decoratorA = new ConcreteDecoratorA(component); Decorator decoratorB = new ConcreteDecoratorB(decoratorA); decoratorB.Operation(); } }  ","version":"Next","tagName":"h3"},{"title":"6. 結果​","type":1,"pageTitle":"💡 裝飾者模式","url":"/en/docs/designPattern/structuralPattern/decorator#6-結果","content":"具體組件操作 具體裝飾者 A 的操作 具體裝飾者 B 的操作 ","version":"Next","tagName":"h3"},{"title":"💡 門面模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/facade","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#概述","content":"門面模式（Facade Pattern）是一種結構型設計模式，它提供了一個簡化介面，用於較大、更複雜或不同系統中的一組介面互動 該模式旨在隱藏系統的複雜性，並為客戶端提供一個更簡單和統一的界面 在門面模式中，通常有一個稱為 門面 的類，它包裝了系統的一組複雜子系統，同時向客戶端提供一個簡單的介面，以便客戶端可以與子系統進行互動，而不必了解子系統的內部工作 ","version":"Next","tagName":"h2"},{"title":"門面模式的主要優點包括​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#門面模式的主要優點包括","content":"封裝複雜性：它允許客戶端與系統的複雜性隔離，只需與門面互動，而不必理解系統的內部複雜性簡化介面：提供了一個簡單的介面，以便客戶端能夠輕鬆使用系統的功能降低耦合度：客戶端只與門面互動，而不必直接與多個子系統互動，從而降低了系統中各個組件之間的耦合度 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義多個子系統​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#1-定義多個子系統","content":"// 定義多個子系統 public class SubSystemA { public void OperationA() { Console.WriteLine(&quot;SubSystemA Operation&quot;); } } public class SubSystemB { public void OperationB() { Console.WriteLine(&quot;SubSystemB Operation&quot;); } } public class SubSystemC { public void OperationC() { Console.WriteLine(&quot;SubSystemC Operation&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"2. 定義門面​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#2-定義門面","content":"// 定義門面 public class Facade { private SubSystemA systemA; private SubSystemB systemB; private SubSystemC systemC; public Facade() { systemA = new SubSystemA(); systemB = new SubSystemB(); systemC = new SubSystemC(); } public void PerformOperation() { Console.WriteLine(&quot;Facade is performing operations...&quot;); systemA.OperationA(); // 與子系統A互動 systemB.OperationB(); // 與子系統B互動 systemC.OperationC(); // 與子系統C互動 } }  ","version":"Next","tagName":"h3"},{"title":"3. 主程式​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#3-主程式","content":"class Program { static void Main(string[] args) { Facade facade = new Facade(); // 創建門面物件 facade.PerformOperation(); // 執行門面操作 } }  ","version":"Next","tagName":"h3"},{"title":"4. 結果​","type":1,"pageTitle":"💡 門面模式","url":"/en/docs/designPattern/structuralPattern/facade#4-結果","content":"Facade is performing operations... SubSystemA Operation SubSystemB Operation SubSystemC Operation ","version":"Next","tagName":"h3"},{"title":"💡 橋接模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/bridge","content":"","keywords":"","version":"Next"},{"title":"Bridge Pattern​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#bridge-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#概述","content":"橋接模式用於將抽象部分和實作部分分離，使它們可以獨立地變化。這種模式允許把一個類別的實作與其抽象部分分離，從而能夠在兩者之間建立一個橋樑 ","version":"Next","tagName":"h2"},{"title":"橋接模式主要解決以下問題​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#橋接模式主要解決以下問題","content":"優點 分離抽象和實作：橋接模式讓抽象和實作可以獨立地變化，讓它們之間解耦。這樣一來，修改實作部分不會影響抽象部分的代碼，反之亦然增加擴展性：橋接模式允許在抽象和實作之間增加新的子類別，從而擴展系統的功能改善可讀性：橋接模式可以讓複雜的類別拆分成兩個獨立的層次，提高代碼的可讀性和可維護性 缺點 增加類別數量：橋接模式引入了多個額外的類別，這可能會增加系統的複雜性。設計過度：如果對系統中的每一個類別都應用橋接模式，而且沒有足夠的理由去這麼做，可能會造成設計過度 ","version":"Next","tagName":"h3"},{"title":"橋接模式包含​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#橋接模式包含","content":"抽象化（Abstraction）角色： 定義了抽象部分的介面，通常包含高層次的操作，並且可能包含對實作部分的參考可以是抽象類別或介面 具體抽象化（Refined Abstraction）角色： 是抽象化角色的具體實現通常為抽象類別的子類別 實作化（Implementor）角色： 定義了實作部分的介面，通常包含低層次的操作可以是抽象類別或介面 具體實作化（Concrete Implementor）角色： 是實作化角色的具體實現通常為實作化類別的子類別 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義實作化（Implementor）角色​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#1-定義實作化implementor角色","content":"// 實作化角色 - 引擎介面 public interface IEngine { void Start(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作具體實作化（Concrete Implementor）角色​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#2-實作具體實作化concrete-implementor角色","content":"// 具體實作化角色 - 汽油引擎 public class PetrolEngine : IEngine { public void Start() { Console.WriteLine(&quot;汽油引擎啟動！&quot;); } } // 具體實作化角色 - 電動引擎 public class ElectricEngine : IEngine { public void Start() { Console.WriteLine(&quot;電動引擎啟動！&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"3. 定義抽象化（Abstraction）角色​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#3-定義抽象化abstraction角色","content":"// 抽象化角色 public abstract class Car { // 引擎 protected IEngine engine; // 注入引擎 public Car(IEngine engine) { this.engine = engine; } // 啟動 public abstract void Drive(); }  ","version":"Next","tagName":"h3"},{"title":"4. 實作具體抽象化（Refined Abstraction）角色​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#4-實作具體抽象化refined-abstraction角色","content":"// 具體抽象化角色 - 跑車 public class SportsCar : Car { public SportsCar(IEngine engine) : base(engine) { } public override void Drive() { Console.WriteLine(&quot;跑車啟動！&quot;); engine.Start(); } } // 具體抽象化角色 - 越野車 public class SUV : Car { public SUV(IEngine engine) : base(engine) { } public override void Drive() { Console.WriteLine(&quot;越野車啟動！&quot;); engine.Start(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 實際使用​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#5-實際使用","content":"class Program { static void Main(string[] args) { // 創建汽車實例並使用汽油引擎 Car sportsCar = new SportsCar(new PetrolEngine()); sportsCar.Drive(); // 創建汽車實例並使用電動引擎 Car suvCar = new SUV(new ElectricEngine()); suvCar.Drive(); } }  ","version":"Next","tagName":"h3"},{"title":"6. 結果​","type":1,"pageTitle":"💡 橋接模式","url":"/en/docs/designPattern/structuralPattern/bridge#6-結果","content":"輸出: 跑車啟動！ 汽油引擎啟動！ 越野車啟動！ 電動引擎啟動！  ","version":"Next","tagName":"h3"},{"title":"💡 享元模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/flyweight","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#概述","content":"享元模式是一種結構型設計模式，用於最小化或共享物件，以節省記憶體或提高性能 該模式的核心思想是將共享的狀態（也就是內部狀態）與物件的其餘部分（外部狀態）分開 這樣多個物件可以共享相同的內部狀態，從而減少記憶體使用 享元模式主要用於管理大量相似的物件，並確保它們在記憶體中僅有一個實體 這種共享的方式可用於提高系統的效率，特別是當有大量相似物件需要處理時 ","version":"Next","tagName":"h2"},{"title":"享元模式主要解決以下問題​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#享元模式主要解決以下問題","content":"優點 減少記憶體消耗：享元模式允許多個物件共享相同的內部狀態，從而減少記憶體消耗提高性能：通過共享內部狀態，享元模式可以提高系統的性能，特別是在處理大量相似物件時支持大量物件：享元模式適用於需要管理大量相似物件的情況 缺點 複雜性增加：實現享元模式可能需要引入額外的複雜性，如內部狀態的管理和外部狀態的處理 ","version":"Next","tagName":"h3"},{"title":"享元模式包含​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#享元模式包含","content":"享元工廠（Flyweight Factory）：負責建立和管理享元物件，它維護一個享元池，以便重複使用享元物件享元（Flyweight）：表示一個共享的內部狀態，該狀態可以被多個物件共享，享元物件包含內部狀態和可以變化的外部狀態客戶端（Client）：使用享元物件的物件，客戶端可以通過享元工廠獲取享元物件，並設置外部狀態 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義享元介面​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#1-定義享元介面","content":"// 享元介面 public interface IFlyweight { void Operation(string externalState); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作具體享元類別​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#2-實作具體享元類別","content":"// 具體享元類別 public class ConcreteFlyweight : IFlyweight { private string intrinsicState; // 內部狀態 public ConcreteFlyweight(string intrinsicState) { this.intrinsicState = intrinsicState; } public void Operation(string externalState) { Console.WriteLine($&quot;內部狀態：{intrinsicState}, 外部狀態：{externalState}&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"3. 實作享元工廠​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#3-實作享元工廠","content":"// 享元工廠 public class FlyweightFactory { private Dictionary&lt;string, IFlyweight&gt; flyweights = new Dictionary&lt;string, IFlyweight&gt;(); public IFlyweight GetFlyweight(string key) { if (!flyweights.ContainsKey(key)) { flyweights[key] = new ConcreteFlyweight(key); } return flyweights[key]; } }  ","version":"Next","tagName":"h3"},{"title":"4. 實際使用​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#4-實際使用","content":"class Program { static void Main(string[] args) { FlyweightFactory factory = new FlyweightFactory(); IFlyweight flyweight1 = factory.GetFlyweight(&quot;A&quot;); flyweight1.Operation(&quot;X&quot;); IFlyweight flyweight2 = factory.GetFlyweight(&quot;B&quot;); flyweight2.Operation(&quot;Y&quot;); IFlyweight flyweight3 = factory.GetFlyweight(&quot;A&quot;); flyweight3.Operation(&quot;Z&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"5. 結果​","type":1,"pageTitle":"💡 享元模式","url":"/en/docs/designPattern/structuralPattern/flyweight#5-結果","content":"輸出: 內部狀態：A, 外部狀態：X 內部狀態：B, 外部狀態：Y 內部狀態：A, 外部狀態：Z   享元模式允許共享內部狀態，從而減少記憶體消耗並提高性能，這在需要處理大量相似物件的情況下特別有用，通過將內部狀態和外部狀態分離，享元模式實現了對物件的有效共享 ","version":"Next","tagName":"h3"},{"title":"💡 代理模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/structuralPattern/proxy","content":"","keywords":"","version":"Next"},{"title":"概述​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#概述","content":"代理模式是一種結構型設計模式，用於控制對其他物件的呼叫，它提供了一個代理物件，允許代理物件控制客戶端對實際物件的呼叫 代理模式的核心思想是在不改變實際物件的情況下，提供一個代理物件，客戶端通過代理物件呼叫實際物件 這可以用於實現不同的功能，例如遠程代理、虛擬代理、保護代理等 ","version":"Next","tagName":"h2"},{"title":"代理模式主要解決以下問題​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#代理模式主要解決以下問題","content":"優點 遠程代理：代理模式可以用於實現遠程代理，允許客戶端呼叫遠程物件，就像呼叫本地物件一樣虛擬代理：代理模式可以用於實現虛擬代理，延遲實際物件的創建和初始化，以提高性能保護代理：代理模式可以用於實現保護代理，控制客戶端對實際物件的呼叫權限 缺點 增加複雜性：引入代理物件可能增加系統的複雜性，需要額外的代理類別和代理邏輯 ","version":"Next","tagName":"h3"},{"title":"代理模式包含以下角色​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#代理模式包含以下角色","content":"客戶端（Client）：使用代理物件的物件，不直接呼叫實際物件，而是通過代理物件進行呼叫。抽象主題（Subject）：定義了實際物件和代理物件的共同介面，客戶端通常面向此介面進行呼叫。實際主題（Real Subject）：實際的物件，代理模式的目的是控制對實際主題的呼叫。代理（Proxy）：代理物件，實現了抽象主題介面，通常包含對實際主題的引用，並在必要時對呼叫進行控制。 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 定義抽象主題​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#1-定義抽象主題","content":"// 抽象主題 public interface ISubject { void Request(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作實際主題​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#2-實作實際主題","content":"// 實際主題 public class RealSubject : ISubject { public void Request() { Console.WriteLine(&quot;執行實際主題的請求&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"3. 實作代理​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#3-實作代理","content":"// 代理 public class Proxy : ISubject { private RealSubject realSubject; public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } // 在這裡可以添加控制邏輯 realSubject.Request(); } }  ","version":"Next","tagName":"h3"},{"title":"4. 實際使用​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#4-實際使用","content":"class Program { static void Main(string[] args) { ISubject subject = new Proxy(); subject.Request(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 結果​","type":1,"pageTitle":"💡 代理模式","url":"/en/docs/designPattern/structuralPattern/proxy#5-結果","content":"輸出: 執行實際主題的請求   在這個範例中，代理模式允許代理物件（Proxy）控制對實際主題（RealSubject）的呼叫 客戶端通過代理物件呼叫實際主題，並且代理物件可以在必要時添加控制邏輯，而不需要改變實際主題的程式碼 這種結構可以用於實現各種代理功能，例如遠程代理、虛擬代理、保護代理等。 ","version":"Next","tagName":"h3"},{"title":"🐄 HTML 概觀","type":0,"sectionRef":"#","url":"/en/docs/frontEnd/htmlOverview","content":"","keywords":"","version":"Next"},{"title":"何謂 HTML​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#何謂-html","content":"HTML (Hypertext Markup Language)，中文翻譯成超 文本語言 他是一種標記語言(Mark Language)，他會透過各種標籤，讓瀏覽器看懂，並呈現出最終的樣子 ","version":"Next","tagName":"h2"},{"title":"HTML 的結構​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#html-的結構","content":"","version":"Next","tagName":"h2"},{"title":"HTML 的組成​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#html-的組成","content":"以下這是一個 HTML &lt;div&gt; Hi Hi &lt;/div&gt;  開頭與結尾: HTML 的開頭 (Opening tag) 會使用 &lt;&gt; 結尾(Closing tag) 則是 &lt;/&gt;，內容 (Content) : 上面的例子 Hi Hi 就是內文 ","version":"Next","tagName":"h3"},{"title":"HTML 的架構​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#html-的架構","content":"首先會再開頭宣告，這段的內容是 HTML &lt;!doctype html&gt;  再來分別可以將 HTML 拆成兩塊head、body 可以將它看成頭跟身體 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h3"},{"title":"HTML head​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#html-head","content":"head 通常會放一些重要資訊: 瀏覽器搜尋的關鍵字 (SEO)CSS 會放在 head還有網頁的相關資訊 &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;我的網站標題&lt;/title&gt; &lt;/head&gt;  &lt;meta charset=&quot;&quot; /&gt; 通常會在 head 放上這行，表示要用 utf-8 這個字元呈現 &lt;title&gt;我的網站標題&lt;/title&gt; title 這個標籤通常會放在 head 而且只會有一個，他會顯示在瀏覽器的頁籤上，表示網頁的標題 ","version":"Next","tagName":"h3"},{"title":"HTML body​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#html-body","content":"&lt;body&gt; &lt;h1&gt;我是標題&lt;/h1&gt; &lt;div&gt;我是內文&lt;/div&gt; &lt;/body&gt;  ","version":"Next","tagName":"h3"},{"title":"HTML file​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#html-file","content":"HTML 檔案的副檔名為 .html 可以嘗試在電腦建立一個空白的記事本，並將檔名與附檔名改成 website.html 並貼上以下內容 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;我的網站標題&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是標題&lt;/h1&gt; &lt;div&gt;我是內文&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;  存檔後將他用瀏覽器打開，就可以看到第一個網站呈現了  ","version":"Next","tagName":"h3"},{"title":"學習資源​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#學習資源","content":"網站\t說明mdn web docs\t比較有權威性的網頁文件，適合初學，比較類似字典類型的網站 W3C school\t上面有許多範例，也可以直接在上面做練習，適合初學入門的網站 ","version":"Next","tagName":"h2"},{"title":"REF​","type":1,"pageTitle":"🐄 HTML 概觀","url":"/en/docs/frontEnd/htmlOverview#ref","content":"mdn web docs ","version":"Next","tagName":"h2"},{"title":"一隻雞的筆記","type":0,"sectionRef":"#","url":"/en/docs/intro","content":"","keywords":"","version":"Next"},{"title":"關於我​","type":1,"pageTitle":"一隻雞的筆記","url":"/en/docs/intro#關於我","content":"孤獨一隻雞I'm a backend developer. 我是一隻平凡無奇的雞，每天過著平凡無奇的生活 在這邊記錄下點點滴滴 ","version":"Next","tagName":"h2"},{"title":"聯絡我​","type":1,"pageTitle":"一隻雞的筆記","url":"/en/docs/intro#聯絡我","content":"E-mail: lonelyyeezhichicken@gmail.com ","version":"Next","tagName":"h2"},{"title":"技能組​","type":1,"pageTitle":"一隻雞的筆記","url":"/en/docs/intro#技能組","content":"Front-end\tFramework\tBack-end\tDB &amp; OthersVue JS\tAsp.net5\tC#\tMSSQL Vanilla JS\t.NET 6\tJava\tMySQL TypeScript\tSpring Boot\tMATLAB\tPLC React JS\tFlask\tPython\tOracle Knockout JS\tPhaser 3\tPHP\tDocker Tailwind CSS\tLaravel Message Queue ","version":"Next","tagName":"h2"},{"title":"🤖 C#簡介","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day1","content":"","keywords":"","version":"Next"},{"title":"故事時間​","type":1,"pageTitle":"🤖 C#簡介","url":"/en/docs/ironMan13/day1#故事時間","content":"在很久很久以前世界上誕生了 C 語言， 這是個非常靈活又高效的語言， 在不久之後他的後代 C++誕生了， C++不僅繼承了 C 語言的靈活與高效， 甚至還進化出物件導向的技術， 一直到今天還是最有生命力的程式語言。 但 C++令人最痛苦的莫過於它難以學習， 學習歷程是條艱辛難走之路， 開發週期也遙遙無期， 在此時此刻， C#悄悄的誕生了，他在學習的難易度與開發能力之間取得更好的平衡。 ","version":"Next","tagName":"h2"},{"title":"我們就來探討 C#的優點吧​","type":1,"pageTitle":"🤖 C#簡介","url":"/en/docs/ironMan13/day1#我們就來探討-c的優點吧","content":"","version":"Next","tagName":"h2"},{"title":"1. 語法簡潔又流暢​","type":1,"pageTitle":"🤖 C#簡介","url":"/en/docs/ironMan13/day1#1-語法簡潔又流暢","content":"C#與 C++的差異在於它的類似的功能只保留一種語法，降低學習的難易度易學是 C#最得意的特徵 ","version":"Next","tagName":"h3"},{"title":"2. 煥然一新的物件導向設計​","type":1,"pageTitle":"🤖 C#簡介","url":"/en/docs/ironMan13/day1#2-煥然一新的物件導向設計","content":"C#是一種很純粹的物件導向語言它包含了封裝、繼承、多態性等等物件導向的關鍵技術還新增了特性、屬性、委託等等強大功能 ","version":"Next","tagName":"h3"},{"title":"3. 下可傳統桌面 app，上可 web 開發​","type":1,"pageTitle":"🤖 C#簡介","url":"/en/docs/ironMan13/day1#3-下可傳統桌面-app上可-web-開發","content":"C#擁有 Winform WPF 來達到桌面開發加上 ASP.net MVC 網站開發甚至還有 ML.net 機器學習 ","version":"Next","tagName":"h3"},{"title":"4. 嚴謹的錯誤處理機制​","type":1,"pageTitle":"🤖 C#簡介","url":"/en/docs/ironMan13/day1#4-嚴謹的錯誤處理機制","content":"垃圾回收機制 =&gt; 擁有自動回收無用的物件所占用的內存異常與例外處理 =&gt; 提供異常非常有結構性又可擴充的錯誤檢測與處理 在學習 C#的過程中會發現到，他擁有各式各樣的框架，也許這是個缺點，但也是個優點，我們不需要刻意去學習其他後端語言就能寫出各式各樣的作品了 ","version":"Next","tagName":"h3"},{"title":"🤖 重播與停止 while迴圈與break","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day10","content":"","keywords":"","version":"Next"},{"title":"while 迴圈​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#while-迴圈","content":"執行前會先判斷條件是否為真如果條件為真就繼續執行，直到條件變成否如果條件式真，程式會永遠執行 ","version":"Next","tagName":"h2"},{"title":"範例:我們來倒數 10~1，數到 1 時就喊新年快樂​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#範例我們來倒數-101數到-1-時就喊新年快樂","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //先宣告一個開關 bool open = true; //宣告一個倒數用的整數變數 int number = 10; //開始執行倒數 while (open) { //如果數到1就把開關關掉，下次就不會執行 if(number == 1) { open = false; } //印出當前數字，印完後就減一 Console.WriteLine(number--); } //都倒數完後就喊新年快樂 Console.WriteLine(&quot;新年快樂!&quot;); Console.ReadKey(); } } }  結果: 10 9 8 7 6 5 4 3 2 1 新年快樂! ","version":"Next","tagName":"h3"},{"title":"break​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#break","content":"只要在迴圈中加入 break，無論迴圈條件如何就都直接結束迴圈即使條件為 true 還是會結束迴圈 ","version":"Next","tagName":"h3"},{"title":"範例:我們來用剛剛的範例來實驗 break 吧​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#範例我們來用剛剛的範例來實驗-break-吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //先宣告一個開關 bool open = true; //宣告一個倒數用的整數變數 int number = 10; //開始執行倒數 while (open) { //印出當前數字 Console.WriteLine(number); //如果數到1就break，放後面的原因是break後就不會執行了 if (number == 1) { //執行到這邊就中斷 break; } //break後就不會執行了，所以遞減放到後面 number--; } //都倒數完後就喊新年快樂 Console.WriteLine(&quot;新年快樂!&quot;); //我們寫看看開關的值 Console.WriteLine(&quot;開關 = &quot; + open); Console.ReadKey(); } } }  結果: 10 9 8 7 6 5 4 3 2 1 新年快樂! 開關 = True 在這邊我們可以看到開關的值明明還是true，但一執行Break迴圈就停掉了 ","version":"Next","tagName":"h3"},{"title":"continue​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#continue","content":"他跟 break 一樣是中斷迴圈但不一樣的點，他是中斷本次迴圈這次迴圈執行不執行，但下次還會執行 ","version":"Next","tagName":"h3"},{"title":"範例:我們印出 1~10 的偶數吧​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#範例我們印出-110-的偶數吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個計數用的整數變數 int number = 0; //開始執行計數 while (number &lt;11) { //先做加一 number++; //如果不是偶數，本次後面就不執行了 if (number % 2 !=0) { continue; } //印出當前數字，並加一 Console.WriteLine(number); } Console.ReadKey(); } } }  結果: 2 4 6 8 10 我們就可以發現，當基數的時候迴圈就沒往下執行了，偶數才會執行 ","version":"Next","tagName":"h3"},{"title":"我們今天的故事就到這邊，To be continue​","type":1,"pageTitle":"🤖 重播與停止 while迴圈與break","url":"/en/docs/ironMan13/day10#我們今天的故事就到這邊to-be-continue","content":"","version":"Next","tagName":"h3"},{"title":"🤖 把複雜的事情與關係簡單化~列舉與結構","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day11","content":"","keywords":"","version":"Next"},{"title":"列舉(enum)​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#列舉enum","content":"列舉類型(Enueration type)能把字串映射到數字增加可讀性也可參加計算結構如下 !注意!:WeekDays不是變數，而是一種數據類型，是和int,double,string等一樣的數據類型，該列舉類型的值只能是七個列舉項之一，每個列舉表面上是一個字串，背後都關聯著一個整數值，默認情況第一個為0之後依序遞增 ","version":"Next","tagName":"h2"},{"title":"範例:我們來用列舉定義星期吧​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#範例我們來用列舉定義星期吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { //宣告星期的列舉 enum WeekDays { 星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期天 } static void Main(string[] args) { int a = Convert.ToInt32(Console.ReadLine()); //將讀到的數字轉為星期 WeekDays today = (WeekDays)a; //判斷今天是否為假日 if ((today == WeekDays.星期天 || today == WeekDays.星期六)) { Console.WriteLine(&quot;放!假!啦!!!!&quot;); } else { Console.WriteLine(&quot;無情上班日!&quot;); } Console.ReadKey(); } } }  輸入: 1 結果: 1 無情上班日! 輸入: 6 結果: 6 放!假!啦!!!! ","version":"Next","tagName":"h3"},{"title":"列舉規則​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#列舉規則","content":"在默認情況之下，都是整數(int)類型如果有其他需要，我們可以自定義列舉型態關聯直可以是 byte,sbyte,short,ushort,int,uint,long 和 ulong 等類型 ","version":"Next","tagName":"h3"},{"title":"範例: 將列舉改成 short 型別​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#範例-將列舉改成-short-型別","content":" enum WeekDays : short { 星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期日 }  ","version":"Next","tagName":"h3"},{"title":"使用列舉的好處​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#使用列舉的好處","content":"使用值標示代替數字，增強程序的可讀性。使每個列舉都關聯著一個數字，可參加計算和循環。列舉變數只能舉列舉項中的值，有利於編譯器檢查出非法的賦值。 ","version":"Next","tagName":"h3"},{"title":"結構體(Structure)​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#結構體structure","content":"很多互相聯繫的信息組成一個整體C#中我們可以把這些緊密聯繫的變數定義成結構體(Structure) ","version":"Next","tagName":"h3"},{"title":"範例:我們來定義一個簡單的結構體與他的數據成員吧​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#範例我們來定義一個簡單的結構體與他的數據成員吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { /// &lt;summary&gt; /// 學生，結構體 /// &lt;/summary&gt; struct Student { //學號 public int number; //姓名 public string name; //性別 public string sex; //生日 public string birthday; } static void Main(string[] args) { Student boy;//宣告變數boy boy.number = 5487; boy.name = &quot;孤獨一隻雞&quot;; boy.sex = &quot;公&quot;; boy.birthday = &quot;1111.01.01&quot;; Student girl;//宣告變數girl girl.number = 9527; girl.name = &quot;孤獨九十九隻雞&quot;; girl.sex = &quot;母&quot;; girl.birthday = &quot;9999.09.09&quot;; Console.WriteLine(&quot;學號:&quot; + boy.number); Console.WriteLine(&quot;姓名:&quot; + boy.name); Console.WriteLine(&quot;性別:&quot; + boy.sex); Console.WriteLine(&quot;生日:&quot; + boy.birthday); Console.WriteLine(&quot;&quot;); Console.WriteLine(&quot;學號:&quot; + girl.number); Console.WriteLine(&quot;姓名:&quot; + girl.name); Console.WriteLine(&quot;性別:&quot; + girl.sex); Console.WriteLine(&quot;生日:&quot; + girl.birthday); Console.ReadKey(); } } }  結果: 學號:5487 姓名:孤獨一隻雞 性別:公 生日:1111.01.01 學號:9527 姓名:孤獨九十九隻雞 性別:母 生日:9999.09.09 ","version":"Next","tagName":"h3"},{"title":"有了列舉跟結構體，讓我們寫程式可以更加明確地去處理資料，也讓可讀性更好​","type":1,"pageTitle":"🤖 把複雜的事情與關係簡單化~列舉與結構","url":"/en/docs/ironMan13/day11#有了列舉跟結構體讓我們寫程式可以更加明確地去處理資料也讓可讀性更好","content":"","version":"Next","tagName":"h3"},{"title":"🤖 當我們同在一起~陣列(Array)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day12","content":"","keywords":"","version":"Next"},{"title":"陣列(array)​","type":1,"pageTitle":"🤖 當我們同在一起~陣列(Array)","url":"/en/docs/ironMan13/day12#陣列array","content":"注意:C#索引是從0開始計算 陣列的語法如下 整數陣列: 字串陣列: 當此句被執行時，系統就會在內存中分配一段連續的空間來儲存這四個 int 型數據 陣列元素的初始值列在大括號裡面，並且用逗號隔開  ","version":"Next","tagName":"h3"},{"title":"範例:我有國，英，數，物理四科，分數分別 70、89、72、93，請幫我算平均分數​","type":1,"pageTitle":"🤖 當我們同在一起~陣列(Array)","url":"/en/docs/ironMan13/day12#範例我有國英數物理四科分數分別-70897293請幫我算平均分數","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告整數陣列 int[] scores = { 70, 89, 72, 93 }; //計算總合 int sum = scores[0] + scores[1] + scores[2] + scores[3]; Console.WriteLine(&quot;總合 : &quot; + sum); //計算平均值 Console.WriteLine(&quot;平均值 : &quot; + (sum / 4)); Console.ReadKey(); } } }  結果: 總合 : 324 平均值 : 81 ","version":"Next","tagName":"h3"},{"title":"陣列進階用法​","type":1,"pageTitle":"🤖 當我們同在一起~陣列(Array)","url":"/en/docs/ironMan13/day12#陣列進階用法","content":"取得陣列長度 使用 array.Length 陣列非常適合搭配 for 迴圈服用 ","version":"Next","tagName":"h3"},{"title":"範例:將前面的範例使用 for 迴圈改寫​","type":1,"pageTitle":"🤖 當我們同在一起~陣列(Array)","url":"/en/docs/ironMan13/day12#範例將前面的範例使用-for-迴圈改寫","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告整數陣列 int[] scores = { 70, 89, 72, 93 }; //宣告總和 int sum = 0; //使用for迴圈，條件為陣列的長度 for (int i = 0; i &lt; scores.Length; i++) { Console.WriteLine(scores[i]); sum += scores[i]; } //將總和的分數除以陣列長度(總共幾門科) float average = sum / (scores.Length); Console.WriteLine(&quot;總分&quot; + sum); Console.WriteLine(&quot;平均值&quot; + average); Console.ReadKey(); } } }  結果: 70 89 72 93 總分 324 平均值 81 ","version":"Next","tagName":"h3"},{"title":"使用陣列來處理同樣類型但很多筆的資料是非常方便的，就讓我們同在一起吧!​","type":1,"pageTitle":"🤖 當我們同在一起~陣列(Array)","url":"/en/docs/ironMan13/day12#使用陣列來處理同樣類型但很多筆的資料是非常方便的就讓我們同在一起吧","content":"","version":"Next","tagName":"h3"},{"title":"🤖 來個輪迴吧~foreach迴圈","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day13","content":"","keywords":"","version":"Next"},{"title":"foreach 迴圈​","type":1,"pageTitle":"🤖 來個輪迴吧~foreach迴圈","url":"/en/docs/ironMan13/day13#foreach-迴圈","content":"foreach 是一個為集合而生的迴圈他的用法很類似 for 迴圈，但相較下來語法較為簡單以下是 foreach 的結構  範例:我們來用 foreach 列出雞的成長過程​ using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個字串陣列 string[] storyArray = { &quot;1.我是一顆蛋&quot;, &quot;2.破殼而出&quot;, &quot;3.吃了幾顆飼料，好飽&quot;, &quot;4.漸漸長大成肉雞&quot;, &quot;5.農場主人來在大家去市場玩&quot;, &quot;6.因為太邊緣所以沒上到車&quot;, &quot;7.大家一去就沒回來&quot;, &quot;8.成為孤獨一隻雞&quot; }; Console.WriteLine(&quot;這是很久很久以前，有一隻雞的故事&quot;); //使用foreach處理陣列 foreach(string story in storyArray) { Console.WriteLine(story); } Console.ReadKey(); } } }  結果 這是很久很久以前，有一隻雞的故事 1.我是一顆蛋 2.破殼而出 3.吃了幾顆飼料，好飽 4.漸漸長大成肉雞 5.農場主人來在大家去市場玩 6.因為太邊緣所以沒上到車 7.大家一去就沒回來 8.成為孤獨一隻雞 ","version":"Next","tagName":"h3"},{"title":"🤖 不同層次的陣列~二維陣列","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day14","content":"","keywords":"","version":"Next"},{"title":"二維陣列​","type":1,"pageTitle":"🤖 不同層次的陣列~二維陣列","url":"/en/docs/ironMan13/day14#二維陣列","content":"就如同象棋棋盤，我們要知道旗子的位置，就得說他是第幾行第幾列結構如下  他看起來的樣子就像 X\t第 0 列\t第 1 列\t第 2 列第 0 行\t1\t2\t3 第 1 行\t4\t5\t6 第 2 行\t7\t8\t9 使用方式跟一維陣列很像 ","version":"Next","tagName":"h3"},{"title":"範例:印出上面陣列的排列樣子​","type":1,"pageTitle":"🤖 不同層次的陣列~二維陣列","url":"/en/docs/ironMan13/day14#範例印出上面陣列的排列樣子","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個二維陣列 int[,] Matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; //開始照著陣列的樣子排列吧 Console.Write(Matrix[0, 0]); Console.Write(Matrix[0, 1]); Console.WriteLine(Matrix[0, 2]);//第一行 Console.Write(Matrix[1, 0]); Console.Write(Matrix[1, 1]); Console.WriteLine(Matrix[1, 2]);//第二行 Console.Write(Matrix[2, 0]); Console.Write(Matrix[2, 1]); Console.WriteLine(Matrix[2, 2]);//第三行 Console.ReadKey(); } } }  結果: 123 456 789 ","version":"Next","tagName":"h3"},{"title":"使用 for 迴圈處理二維陣列​","type":1,"pageTitle":"🤖 不同層次的陣列~二維陣列","url":"/en/docs/ironMan13/day14#使用-for-迴圈處理二維陣列","content":"這部分比較進階，需要使用兩層的 for 迴圈來處理 ","version":"Next","tagName":"h3"},{"title":"範例:使用雙重 for 迴圈，拆開二維陣列​","type":1,"pageTitle":"🤖 不同層次的陣列~二維陣列","url":"/en/docs/ironMan13/day14#範例使用雙重-for-迴圈拆開二維陣列","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個二維陣列 int[,] Matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; //使用雙重迴圈 //第一層，表示第幾行 for(int i=0; i &lt; 3; i++) { //第二層，表示第幾列，由於變數i已用過所以習慣上會用j for (int j = 0; j &lt; 3; j++) { Console.Write(Matrix[i, j]+&quot; &quot;); } //我們這邊要用一個特別的符號，換行符號&quot;\\n&quot;在C#中表示換行 Console.Write(&quot;\\n&quot;); } Console.ReadKey(); } } }  結果: 1 2 3 4 5 6 7 8 9 ","version":"Next","tagName":"h3"},{"title":"二維陣列可以做到 XY 軸的維度，但使用上也相對比較進階了，所以有興趣的朋友在深入研究​","type":1,"pageTitle":"🤖 不同層次的陣列~二維陣列","url":"/en/docs/ironMan13/day14#二維陣列可以做到-xy-軸的維度但使用上也相對比較進階了所以有興趣的朋友在深入研究","content":"","version":"Next","tagName":"h3"},{"title":"🤖 多筆資料的好朋友~List","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day15","content":"","keywords":"","version":"Next"},{"title":"List< T >​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#list-t-","content":"T 的部份我們可以用其他型別來替換他常見的方式是將 string 或 int，甚至是將 class 做成物件模型來使用他非常適合用於 foreach 迴圈 ","version":"Next","tagName":"h3"},{"title":"範例:我們將十二生肖填入 List 中​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#範例我們將十二生肖填入-list-中","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個List List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龍&quot;, &quot;蛇&quot;, &quot;馬&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;雞&quot;, &quot;狗&quot;, &quot;豬&quot; }; Console.WriteLine(&quot;出來吧12生肖!&quot;); //我們使用foreach迴圈來列出List的值 foreach(string item in myList) { Console.WriteLine(item); } Console.ReadKey(); } } }  結果: 出來吧 12 生肖! 鼠 牛 虎 兔 龍 蛇 馬 羊 猴 雞 狗 豬 他的初始值給法跟陣列十分相似，但她不需要給初始長度 ","version":"Next","tagName":"h3"},{"title":"新增資料​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#新增資料","content":"如果我們需要新增資料進到 List 呢，可以使用.Add()來新增單筆資料如果需要新增多筆資料就須使用 AddRange() ","version":"Next","tagName":"h3"},{"title":"範例:有一天，科學家發現，原來一年有 13 個月，因此必須幫第十三年補上熊的生肖​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#範例有一天科學家發現原來一年有-13-個月因此必須幫第十三年補上熊的生肖","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個List List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龍&quot;, &quot;蛇&quot;, &quot;馬&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;雞&quot;, &quot;狗&quot;, &quot;豬&quot; }; //使用Add()新增熊 myList.Add(&quot;熊&quot;); Console.WriteLine(&quot;出來吧13生肖!&quot;); //我們使用foreach迴圈來列出List的值 foreach(string item in myList) { Console.WriteLine(item); } Console.ReadKey(); } } }  結果: 出來吧 13 生肖! 鼠 牛 虎 兔 龍 蛇 馬 羊 猴 雞 狗 豬 熊 ","version":"Next","tagName":"h3"},{"title":"範例:後來科學家發現，一年不只 13 個月，實際上有 15 個月，所以還要補上象、魚這兩種動物​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#範例後來科學家發現一年不只-13-個月實際上有-15-個月所以還要補上象魚這兩種動物","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個List List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龍&quot;, &quot;蛇&quot;, &quot;馬&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;雞&quot;, &quot;狗&quot;, &quot;豬&quot; }; //宣告一個要新增的List List&lt;string&gt; newList = new List&lt;string&gt;() { &quot;熊&quot;, &quot;象&quot;, &quot;魚&quot; }; //AddRange()將newList新增到myList中 myList.AddRange(newList); //使用Count()來表示List筆數 Console.WriteLine(&quot;出來吧&quot; + myList.Count() + &quot;生肖!&quot;); //我們使用foreach迴圈來列出List的值 foreach (string item in myList) { Console.WriteLine(item); } Console.ReadKey(); } } }  結果: 出來吧 15 生肖! 鼠 牛 虎 兔 龍 蛇 馬 羊 猴 雞 狗 豬 熊 象 魚 我們這邊多使用了myList.Count()來列出目前List的總筆數 ","version":"Next","tagName":"h3"},{"title":"移除資料​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#移除資料","content":"單筆移除的方法我們使用 Remove()多筆移除則是使用 RemoveRange(第幾筆,共刪幾筆) ","version":"Next","tagName":"h3"},{"title":"範例:科學家發現原來是儀器故障才會算成 15 年，實際上只有 14 年，所以要把魚拿掉​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#範例科學家發現原來是儀器故障才會算成-15-年實際上只有-14-年所以要把魚拿掉","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個List List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龍&quot;, &quot;蛇&quot;, &quot;馬&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;雞&quot;, &quot;狗&quot;, &quot;豬&quot;, &quot;熊&quot;, &quot;象&quot;, &quot;魚&quot; }; //使用Remove()移除魚 myList.Remove(&quot;魚&quot;); //使用Count()來表示List筆數 Console.WriteLine(&quot;出來吧&quot; + myList.Count() + &quot;生肖!&quot;); //我們使用foreach迴圈來列出List的值 foreach (string item in myList) { Console.WriteLine(item); } Console.ReadKey(); } } }  結果: 出來吧 14 生肖! 鼠 牛 虎 兔 龍 蛇 馬 羊 猴 雞 狗 豬 熊 象 ","version":"Next","tagName":"h3"},{"title":"範例:後來科學家又發現，原來研究儀器是玩具店買的，根本沒有那麼多個月，實際上只有 12 個月，所以要把動物復原​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#範例後來科學家又發現原來研究儀器是玩具店買的根本沒有那麼多個月實際上只有-12-個月所以要把動物復原","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個List List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龍&quot;, &quot;蛇&quot;, &quot;馬&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;雞&quot;, &quot;狗&quot;, &quot;豬&quot;, &quot;熊&quot;, &quot;象&quot;, &quot;魚&quot; }; //由於第一筆是從0算起，所以要從12開始刪3筆 myList.RemoveRange(12,3); //使用Count()來表示List筆數 Console.WriteLine(&quot;出來吧&quot; + myList.Count() + &quot;生肖!&quot;); //我們使用foreach迴圈來列出List的值 foreach (string item in myList) { Console.WriteLine(item); } Console.ReadKey(); } } }  結果: 出來吧 12 生肖! 鼠 牛 虎 兔 龍 蛇 馬 羊 猴 雞 狗 豬 ","version":"Next","tagName":"h3"},{"title":"進階用法:結合 class​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#進階用法結合-class","content":"我們可以利用 class 的屬性來建立資料模型將資料模型做成 List ","version":"Next","tagName":"h3"},{"title":"範例:我們將 12 個月與生肖結合吧​","type":1,"pageTitle":"🤖 多筆資料的好朋友~List","url":"/en/docs/ironMan13/day15#範例我們將-12-個月與生肖結合吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { //建立一個class class DataModel { //月份 public int month; //動物 public string animal; } class Program { static void Main(string[] args) { //宣告一個List List&lt;DataModel&gt; dataList = new List&lt;DataModel&gt;(); //宣告一個List List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龍&quot;, &quot;蛇&quot;, &quot;馬&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;雞&quot;, &quot;狗&quot;, &quot;豬&quot; }; //宣告整數來算月份 int Count = 1; //我們使用foreach迴圈來填寫dataList的值 foreach (string item in myList) { //新增一筆新的資料所以我們要使用new dataList.Add(new DataModel { month = Count, animal = item }); //進入下個月 Count++; } //使用Count()來表示List筆數 Console.WriteLine(&quot;出來吧&quot; + dataList.Count() + &quot;生肖!&quot;); //我們使用foreach迴圈來列出List的值 foreach (DataModel item in dataList) { //這邊需要用item.物件名稱，才有辦法取到值 Console.WriteLine(item.month + &quot;月 , 屬 :&quot; + item.animal); } Console.ReadKey(); } } }  結果: 出來吧 12 生肖! 1 月 , 屬 :鼠 2 月 , 屬 :牛 3 月 , 屬 :虎 4 月 , 屬 :兔 5 月 , 屬 :龍 6 月 , 屬 :蛇 7 月 , 屬 :馬 8 月 , 屬 :羊 9 月 , 屬 :猴 10 月 , 屬 :雞 11 月 , 屬 :狗 12 月 , 屬 :豬 ","version":"Next","tagName":"h3"},{"title":"🤖 虛擬代工廠~方法(function)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day16","content":"","keywords":"","version":"Next"},{"title":"方法(function)​","type":1,"pageTitle":"🤖 虛擬代工廠~方法(function)","url":"/en/docs/ironMan13/day16#方法function","content":"為了解決以下問題: 1.程式碼的重複 2.結構很不清晰 3.有利於修改與維護他就像是一間代工廠一樣  ","version":"Next","tagName":"h3"},{"title":"字串方法​","type":1,"pageTitle":"🤖 虛擬代工廠~方法(function)","url":"/en/docs/ironMan13/day16#字串方法","content":"會回傳處理後的字串可以自己定義傳入的參數 ","version":"Next","tagName":"h3"},{"title":"範例:我們來回傳孤獨一隻雞的字串​","type":1,"pageTitle":"🤖 虛擬代工廠~方法(function)","url":"/en/docs/ironMan13/day16#範例我們來回傳孤獨一隻雞的字串","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //我們來呼叫方法並賦值給變數 string animal = GetChicken(); Console.WriteLine(animal); Console.ReadKey(); } //宣告字串方法 static string GetChicken() { return &quot;孤獨一隻雞&quot;; } } }  結果: 孤獨一隻雞 使用static關鍵字時，表示他是靜態的，所以不需要去new他 ","version":"Next","tagName":"h3"},{"title":"範例:我們拋今天的日期到方法中，讓他自動組成年月日​","type":1,"pageTitle":"🤖 虛擬代工廠~方法(function)","url":"/en/docs/ironMan13/day16#範例我們拋今天的日期到方法中讓他自動組成年月日","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //來取得過去的一個時間吧 string MtDate = GetDate(1995, 4, 9); Console.WriteLine(MtDate); //來取得今日的時間吧 MtDate = GetDate(2021, 9, 17); Console.WriteLine(MtDate); Console.ReadKey(); } //宣告一個組合日期的方法 static string GetDate(int y,int M,int d) { //因為值傳進來是正數所以需要轉成字串 string Date_y = Convert.ToString(y);//第一種轉型方式Convert.To... string Date_M = M.ToString();//第二種轉型方式 參數.ToString() string Date_d = d.ToString(); //組合回傳字串，用return回傳 return Date_y + &quot;年 &quot; + Date_M + &quot;月 &quot; + Date_d + &quot;日&quot;; } } }  結果: 1995 年 4 月 9 日 2021 年 9 月 17 日 ","version":"Next","tagName":"h3"},{"title":"有了方法，可以大大降低程式碼的重複率，也可以隨處呼叫他​","type":1,"pageTitle":"🤖 虛擬代工廠~方法(function)","url":"/en/docs/ironMan13/day16#有了方法可以大大降低程式碼的重複率也可以隨處呼叫他","content":"","version":"Next","tagName":"h3"},{"title":"🤖 像個郵差一樣~值與址的傳遞","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day17","content":"","keywords":"","version":"Next"},{"title":"傳值​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#傳值","content":"在呼叫方法時我們難免需要將參數做傳遞值得傳遞，表示他們在記憶體中，會佔不同的空間當值傳遞完成後他們之間將毫無關係 ","version":"Next","tagName":"h3"},{"title":"範例:我們來輸入兩個數字，並且將他們比大小​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#範例我們來輸入兩個數字並且將他們比大小","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告X整數 int x = Convert.ToInt32(Console.ReadLine()); //宣告y整數 int y = Convert.ToInt32(Console.ReadLine()); //呼叫Bigger方法，並將x，y的直傳入 int reault = Bigger(x, y); Console.WriteLine(&quot;x = &quot; + x + &quot; ,y = &quot; + y); Console.WriteLine(&quot;最大值為&quot; + reault); Console.ReadKey(); } //比較兩數大小的方法，將x y 傳入 static int Bigger(int x, int y) { //判斷x y誰大 int maxValue = (x &gt;= y) ? x : y; return maxValue; } } }  輸入: 1 5 結果: 1 5 x = 1 ,y = 5 最大值為 5 我們這邊使用到了三元條件運算子，它的結構如下: ","version":"Next","tagName":"h3"},{"title":"中斷點​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#中斷點","content":"中斷點，是 debug 時非常好用的一個功能如果對程式碼的執行有任何疑問，基本上都是可以使用中斷點做逐步執行的 ","version":"Next","tagName":"h3"},{"title":"中斷點使用方式:​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#中斷點使用方式","content":"在想要停止的程式前面點一下，會出現小紅點(快捷鍵:F9) 接下來我們執行程式，會發現執行到此行時程式停下來了 這時候我們到功能列上按逐步執行(快捷鍵:F11)，會發現按一下就執行一行程式，這樣我們就可以了解程式如何執行了 如果我們逐步執行程式後，會發現原來呼叫方法時，程式會先進入方法執行，執行完再回到原本程式繼續執行 ","version":"Next","tagName":"h3"},{"title":"址的傳遞​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#址的傳遞","content":"假設有一個擁有上百的參數的陣列，做參數的傳遞，等於又得在記憶體中切割一樣大小的空間出來因此像陣列或結構體複雜的傳遞，他傳的是記憶體所在的位址，而不是傳遞參數傳遞後新的陣列也會指向相同的記憶體位置，因此做任何異動時都會影響到原來的陣列 ","version":"Next","tagName":"h3"},{"title":"範例:我們用 List 來驗證傳址的行為吧​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#範例我們用-list-來驗證傳址的行為吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個Llist List&lt;string&gt; myList = new List&lt;string&gt;() { &quot;孤獨一隻雞&quot;, &quot;人生一條蟲&quot;, &quot;寂寞一隻鳥&quot;, &quot;爆肝一隻鵝&quot; }; Console.WriteLine(&quot;原始筆數 = &quot; + myList.Count()); //呼叫方法並傳入List int newCount = ListCount(myList); Console.WriteLine(&quot;目前筆數 = &quot; + newCount); //這時候我們用foreach迴圈來拆解原本的List foreach(string item in myList) { Console.Write(item + &quot; &quot;); } Console.ReadKey(); } //我們使用一個方法並接收list的傳遞，然後回傳list的筆數 static int ListCount(List&lt;string&gt; newList) { //我們在這list偷偷加一隻魚 newList.Add(&quot;高冷一隻魚&quot;); return newList.Count(); } }  結果: 原始筆數 = 4 目前筆數 = 5 孤獨一隻雞 人生一條蟲 寂寞一隻鳥 爆肝一隻鵝 高冷一隻魚 我們可以發現，我們明明在新的方法，新的List去修改List，結果原來的List卻受到影響，這就是因為他們指向的記憶體位置是同一個地方，所以只要一有變動所有資料都會受到影響 ","version":"Next","tagName":"h3"},{"title":"以上就是我們今天小郵差的故事，我們明天見喽!​","type":1,"pageTitle":"🤖 像個郵差一樣~值與址的傳遞","url":"/en/docs/ironMan13/day17#以上就是我們今天小郵差的故事我們明天見喽","content":"","version":"Next","tagName":"h3"},{"title":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day18","content":"","keywords":"","version":"Next"},{"title":"ref 關鍵字​","type":1,"pageTitle":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","url":"/en/docs/ironMan13/day18#ref-關鍵字","content":"上回我們說好了，參數有分為傳值與傳址ref 關鍵字的用途就是將參數指定為傳址因此做任何修改都會影響到原參數 ","version":"Next","tagName":"h3"},{"title":"範例:我們來讓一隻雞進化吧​","type":1,"pageTitle":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","url":"/en/docs/ironMan13/day18#範例我們來讓一隻雞進化吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一隻雞 string chicken = &quot;一隻雞&quot;; Console.WriteLine(&quot;小時候 : &quot; + chicken); //呼叫成長方法 ChangAChicken(ref chicken); Console.WriteLine(&quot;漂泊完回家後的雞 : &quot; + chicken); Console.ReadKey(); } //宣告小雞長大的方法，這邊使用常數方法，不需要做return static void ChangAChicken(ref string newChicken) { //讓雞進化 newChicken = &quot;孤獨&quot; + newChicken; } } }  結果: 小時候 : 一隻雞 漂泊完回家後的雞 : 孤獨一隻雞 ","version":"Next","tagName":"h3"},{"title":"out 參數修飾詞​","type":1,"pageTitle":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","url":"/en/docs/ironMan13/day18#out-參數修飾詞","content":"Out 的存在是為了解決一個方法只能回傳一個值但使用 Out 就能回來多個值Out 的參數，使用前是不能賦值的，即使賦值也會被忽略 ","version":"Next","tagName":"h3"},{"title":"範例:我們知道一個圓的半徑，求它的面積與圓周長吧​","type":1,"pageTitle":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","url":"/en/docs/ironMan13/day18#範例我們知道一個圓的半徑求它的面積與圓周長吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告圓半徑 double x = 4; Console.WriteLine(&quot;圓半徑 : &quot; + x); //宣告圓周長 double y; //呼叫計算方法 double area = GetArea(x, out y); Console.WriteLine(&quot;圓周長 = &quot; + y); Console.WriteLine(&quot;圓面積 = &quot; + area); Console.ReadKey(); } //宣告方法來計算面積，要return 面積，out 圓周長 static double GetArea(double r, out double y) { //計算圓周長 y = 2 * r * Math.PI; //計算圓面積 double s = (r * r) * Math.PI; return s; } } }  結果: 圓半徑 : 4 圓周長 = 25.1327412287183 圓面積 = 50.2654824574367 ","version":"Next","tagName":"h3"},{"title":"ref 與 Out 的差異​","type":1,"pageTitle":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","url":"/en/docs/ironMan13/day18#ref-與-out-的差異","content":"ref : 使用前可以給傳遞的參數 值Out : 使用前是不能賦值的，即使賦值也會被忽略因此 Out 無法拿來做數據傳遞，只能取得返回值 ","version":"Next","tagName":"h3"},{"title":"今天的文章就到這邊，大家記得像鮭魚一樣，明天記得回來看我的文章哦!​","type":1,"pageTitle":"🤖 回頭吧!孩子~ref 與 out 參數修飾詞","url":"/en/docs/ironMan13/day18#今天的文章就到這邊大家記得像鮭魚一樣明天記得回來看我的文章哦","content":"","version":"Next","tagName":"h3"},{"title":"🤖 讓時間倒轉吧~遞迴","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day19","content":"","keywords":"","version":"Next"},{"title":"遞迴​","type":1,"pageTitle":"🤖 讓時間倒轉吧~遞迴","url":"/en/docs/ironMan13/day19#遞迴","content":"遞迴就是在方法中呼叫方法自己通常會使用遞迴的程式碼都比較簡潔遞迴通常執行效率較低 ","version":"Next","tagName":"h3"},{"title":"範例:我們來讓 20 一直倒扣到 0，然後喊出新年快樂吧​","type":1,"pageTitle":"🤖 讓時間倒轉吧~遞迴","url":"/en/docs/ironMan13/day19#範例我們來讓-20-一直倒扣到-0然後喊出新年快樂吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //呼叫遞迴方法 Fac(20); Console.WriteLine(&quot;新年快樂!&quot;); Console.ReadKey(); } //宣告一個遞迴方法 static void Fac(int n) { Console.WriteLine(&quot;n = &quot; + n); //如果n等於0之後就不呼叫自己 if (n != 0) { Fac(n - 1); } } } }  結果: n = 20 n = 19 n = 18 n = 17 n = 16 n = 15 n = 14 n = 13 n = 12 n = 11 n = 10 n = 9 n = 8 n = 7 n = 6 n = 5 n = 4 n = 3 n = 2 n = 1 n = 0 新年快樂! ","version":"Next","tagName":"h3"},{"title":"進階練習:​","type":1,"pageTitle":"🤖 讓時間倒轉吧~遞迴","url":"/en/docs/ironMan13/day19#進階練習","content":"","version":"Next","tagName":"h3"},{"title":"費波那契數列:​","type":1,"pageTitle":"🤖 讓時間倒轉吧~遞迴","url":"/en/docs/ironMan13/day19#費波那契數列","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個整數，看要輸出多少項 int n = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;Fibonacci : &quot;); for (int i = 1; i &lt;= n; i++) { //輸出費波那契數列的第i項 Console.Write(Fibonacci(i) + &quot;\\t&quot;); //每輸出五項換一行 if ((i % 5) == 0) { Console.WriteLine(); } } Console.ReadKey(); } //宣告方法 static int Fibonacci(int n) { if (n == 1 || n == 2) { //初始值 return 1; } else { //遞迴 return (Fibonacci(n - 1) + Fibonacci(n - 2)); } } } }  輸入: 30 輸出: 30 Fibonacci : 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040  ","version":"Next","tagName":"h3"},{"title":"這就一個 C#倒帶按鍵的故事~​","type":1,"pageTitle":"🤖 讓時間倒轉吧~遞迴","url":"/en/docs/ironMan13/day19#這就一個-c倒帶按鍵的故事","content":"","version":"Next","tagName":"h3"},{"title":"🤖 與C#開發千里來相見","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day2","content":"","keywords":"","version":"Next"},{"title":"開發工具​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#開發工具","content":"我們這邊使用 Visual Studio 2017 來做為程式的編譯工具， 其他版本來做練習也是沒有問題的。 ","version":"Next","tagName":"h2"},{"title":"專案建​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#專案建","content":"首先我們開啟 VS 2017 建立一個主控台應用程式 記得幫專案命名，選擇路徑，命名方案，一個方案下可以包含多個專案 建立完成後就可以看到自動產生的程式碼啦 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { } } }  ","version":"Next","tagName":"h2"},{"title":"結構介紹​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#結構介紹","content":"在 C#之中就像一台車子我們可以想像專案(project)-就是車子本體接下來類別(class)- 如同各式模組(例如:引擎)更往下就是物件(object)-物件則是個瑣碎的零件(如:螺絲)沒錯 C#簡單來說就是由他們組成的，他們之間往往環環相扣缺一不可 ","version":"Next","tagName":"h2"},{"title":"實戰演練​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#實戰演練","content":"在說明完結構後想必各位也手癢癢想來寫寫看了 我們就來寫個 Hello world 讓程式來跟這世界打聲招呼吧! using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //印出文字 Console.WriteLine(&quot;Hello world&quot;); Console.ReadKey(); } } }  ","version":"Next","tagName":"h2"},{"title":"執行:我們可以按快捷鍵(Ctrl+F5)或是點選功能列的開始執行程式​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#執行我們可以按快捷鍵ctrlf5或是點選功能列的開始執行程式","content":"結果我們會看到 Hello world 恭喜你!你的程式誕生了! 但剛剛究竟發生什麼事情呢?讓我們繼續看下去! ","version":"Next","tagName":"h2"},{"title":"知識小學堂​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#知識小學堂","content":"原來它的結構是這樣啊!? 在未來我們會更詳細的說明他們其中的含意，我們今天先來教大家之後常常會看到的函式 函式\t用途Console.WriteLine()\t輸出(會換行) Console.Write()\t輸出(不換行) Console.ReadLine()\t讀取輸入的資料 Console.ReadKey()\t取得使用者按下的下一個字元或功能鍵 我們這邊的 Console.ReadKey() 主要用途只是要讓主控台不會跑完程式就關閉 ","version":"Next","tagName":"h2"},{"title":"隨堂小練習​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#隨堂小練習","content":"既然大家都會了那我們就來做個小練習，結束今天這一回合吧! ","version":"Next","tagName":"h2"},{"title":"題目​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#題目","content":"請大家用 C#來做個簡單自我介紹吧!介紹內容需有(姓名，年齡，血型，星座，自我介紹)範例: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //印出文字 Console.WriteLine(&quot;姓名 : 孤獨一隻雞&quot;); Console.WriteLine(&quot;年齡 : 48歲&quot;); Console.WriteLine(&quot;血型 : O型&quot;); Console.WriteLine(&quot;星座 : 金牛座&quot;); Console.WriteLine(&quot;自我介紹 : 我像是一隻你可有可無的小雞&quot;); Console.ReadKey(); } } }  結果: 姓名 : 孤獨一隻雞 年齡 : 48 歲 血型 : O 型 星座 : 金牛座 自我介紹 : 我像是一隻你可有可無的小雞 ","version":"Next","tagName":"h2"},{"title":"我們今天故事就告一段落了，敬請期待明天的故事~ 我們明天再見​","type":1,"pageTitle":"🤖 與C#開發千里來相見","url":"/en/docs/ironMan13/day2#我們今天故事就告一段落了敬請期待明天的故事-我們明天再見","content":"","version":"Next","tagName":"h2"},{"title":"🤖 物件導向(oop)基本觀念","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day20","content":"","keywords":"","version":"Next"},{"title":"物件導向(Object-oriented programming)​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#物件導向object-oriented-programming","content":"物件導向概念: 將數據與對數據的操作，包裝成&quot;零件&quot;，人們利用這些零件來組裝程式 ","version":"Next","tagName":"h3"},{"title":"物件導向基本概念​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#物件導向基本概念","content":"Class (類別)Encapsulation (封裝)Interface (介面)Object (物件) ","version":"Next","tagName":"h3"},{"title":"詳細內容​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#詳細內容","content":"","version":"Next","tagName":"h3"},{"title":"1. Class (類別)​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#1-class-類別","content":"他就如同一輛車子的設計藍圖，並非沒有實體，用來定義規矩，讓大家的思維，保持一致將事物編寫為一個一個類別，用數據表示事務的屬性，用函數實現數據行為。類別就像是一種資料模型，由他來定義資料的結構應該長成甚麼樣子。 ","version":"Next","tagName":"h3"},{"title":"2. Encapsulation (封裝)​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#2-encapsulation封裝","content":"就如同車子的零件，讓維修員只要&quot;會拆裝&quot;，就能讓一台車上路，大大提升了，車輛生產的效率物件導向技術，將事務的屬性與行為的細節封裝於類別中，形成一個可以重複使用的零件。 ","version":"Next","tagName":"h3"},{"title":"3. Interface (介面)​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#3-interface介面","content":"他就像是車子的輪胎規格，將規格定義好，大家都可以不用使用特製的輪胎，甚至更有利於做車子的改裝在物件導向程式設計中，只要保持接口不變，就能將一個設計更好的類別來替換原來的類別。 ","version":"Next","tagName":"h3"},{"title":"4. Object (物件)​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#4-object物件","content":"生活中處處充斥物件，EX:一棟房子、一輛汽車.....他是動態的，狀態隨時都會改變，但整體的結構與行為並不會因為他的動而受到影響 ","version":"Next","tagName":"h3"},{"title":"我們明天開始就來學習物件導向的基礎知識吧​","type":1,"pageTitle":"🤖 物件導向(oop)基本觀念","url":"/en/docs/ironMan13/day20#我們明天開始就來學習物件導向的基礎知識吧","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~類別(class)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day21","content":"","keywords":"","version":"Next"},{"title":"變數成員與方法成員​","type":1,"pageTitle":"🤖 物件導向(oop)~類別(class)","url":"/en/docs/ironMan13/day21#變數成員與方法成員","content":"結構: ","version":"Next","tagName":"h3"},{"title":"範例:我們來實作貓的類別  ​","type":1,"pageTitle":"🤖 物件導向(oop)~類別(class)","url":"/en/docs/ironMan13/day21#範例我們來實作貓的類別-","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //使用類別前要先實例化 Cat cat = new Cat(); //填寫變數成員 Console.WriteLine(&quot;請輸入姓名:&quot;); cat.name = Console.ReadLine(); Console.WriteLine(&quot;請輸入年齡:&quot;); cat.age =Convert.ToInt32(Console.ReadLine()); //呼叫方法成員 //喵喵叫 cat.Meow(); //抓到老鼠 cat.CaseMice(); Console.ReadKey(); } } class Cat { //名稱 public string name; //年齡 public int age; //老鼠數量 public int miceCount = 0; //記錄抓幾隻老鼠 //方法成員 //方法:打招呼 public void Hello() { Console.WriteLine(&quot;嗨!我是{0} &quot;, name); } //方法:喵喵叫 public void Meow() { Hello(); Console.WriteLine(&quot;喵~~~~~喵~~~&quot;); } //方法:捉老鼠 public void CaseMice() { miceCount++; Hello(); Console.WriteLine(&quot;我已經抓了 {0} 隻老鼠&quot;, miceCount); Console.ReadKey(); } } }  輸入: 孤獨一隻雞 48 輸出: 請輸入姓名: 孤獨一隻雞 請輸入年齡: 48 嗨!我是孤獨一隻雞 喵~喵~~~ 嗨!我是孤獨一隻雞 我已經抓了 1 隻老鼠 在 Cat 這個類別之中， 貓有三個屬性: 1. 名字 2. 年齡 3. 捉到老鼠數量 分別使用 name 、age、 miceCount 來表示， 他們稱為類別的成員變數(Member Variable) 公用和私用 (public/private) public/private 統稱為&quot;修飾詞&quot;  public string name; public int age; ⇒ 公有成員 public void Meow() public void CaseMice() private int miceCount = 0; private void Hello() ⇒私有成員   ※把變數或函數標記為private，可以確保這些數據不受到外界的影響 已宣告存取範圍\t意義public\t未限制存取。 protected\t存取限於包含類別或衍生自包含類別的類型。 internal\t存取限於目前組件。 protected internal\t存取限於目前組件或衍生自包含類別的類型。 private\t存取限於包含類型。 private protected\t存取限於目前組件內包含類別或衍生自包含類別的類型。 自 C# 7.2 起可用。 ","version":"Next","tagName":"h3"},{"title":"學會了類別之後，會發現原來程式碼，也可以這樣做分類鴨!​","type":1,"pageTitle":"🤖 物件導向(oop)~類別(class)","url":"/en/docs/ironMan13/day21#學會了類別之後會發現原來程式碼也可以這樣做分類鴨","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~物件(Object)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day22","content":"","keywords":"","version":"Next"},{"title":"物件基本原理​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#物件基本原理","content":"C#通過 new 來創建物件，執行 new 後系統會在記憶體分配一個空間給數據成員，這過程我們將其稱為實例化實例化之後的所有成員都會被初始化為 null,整數成員也會被初始化為 0如果我們創建多個物件但都是同一個類別，那麼大家都共用同樣的程式碼，但不共用數據，而且每個物件都會在記憶體中擁有自己的內存空間 ","version":"Next","tagName":"h3"},{"title":"實例化語句如下:​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#實例化語句如下","content":"記憶體將切割一個內存空間給 Kitty 做使用，並且 Kitty 將會擁有 Cat 類別的所有成員  ","version":"Next","tagName":"h3"},{"title":"如何使用成員呢?​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#如何使用成員呢","content":"這邊我們需要使用到點運算符，透過點運算符我們可以呼叫到 Kitty 底下的公有成員  ","version":"Next","tagName":"h3"},{"title":"如何呼叫函式呢?​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#如何呼叫函式呢","content":"一樣使用點運算符，我們就能呼叫到 Kitty 底下的公有函數 ","version":"Next","tagName":"h3"},{"title":"範例:我們沿用 Day21 的程式碼來做練習​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#範例我們沿用-day21-的程式碼來做練習","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //我們實例化兩個類 Cat cat1 = new Cat(); Cat cat2 = new Cat(); //填寫cat1數據成員 cat1.name = &quot;慚愧一隻貓&quot;; cat1.age = 10; //填寫cat2數據成員 cat2.name = &quot;無悔一隻貓&quot;; cat2.age = 35; //顯示結果 Console.WriteLine(&quot;姓名 : &quot; + cat1.name + &quot;,年齡 : &quot; + cat1.age); Console.WriteLine(&quot;姓名 : &quot; + cat2.name + &quot;,年齡 : &quot; + cat2.age); Console.ReadKey(); } } class Cat { //名稱 public string name; //年齡 public int age; //老鼠數量 public int miceCount = 0; //記錄抓幾隻老鼠 //方法成員 //方法:打招呼 public void Hello() { Console.WriteLine(&quot;嗨!我是{0} &quot;, name); } //方法:喵喵叫 public void Meow() { Hello(); Console.WriteLine(&quot;喵~~~~~喵~~~&quot;); } //方法:捉老鼠 public void CaseMice() { miceCount++; Hello(); Console.WriteLine(&quot;我已經抓了 {0} 隻老鼠&quot;, miceCount); } } }  結果: 姓名 : 慚愧一隻貓,年齡 : 10 姓名 : 無悔一隻貓,年齡 : 35 ","version":"Next","tagName":"h3"},{"title":"範例:我們看看方法的狀況​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#範例我們看看方法的狀況","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //我們實例化兩個類 Cat cat1 = new Cat(); Cat cat2 = new Cat(); //填寫cat1數據成員 cat1.name = &quot;慚愧一隻貓&quot;; cat1.age = 10; //填寫cat2數據成員 cat2.name = &quot;無悔一隻貓&quot;; cat2.age = 35; //讓慚愧一隻貓抓兩隻老鼠 cat1.CaseMice(); cat1.CaseMice(); //讓無悔一隻貓抓一隻老鼠 cat2.CaseMice(); //顯示結果 Console.WriteLine(&quot;姓名 : &quot; + cat1.name + &quot;,年齡 : &quot; + cat1.age + &quot;,共抓 &quot; + cat1.miceCount + &quot; 隻老鼠&quot;); Console.WriteLine(&quot;姓名 : &quot; + cat2.name + &quot;,年齡 : &quot; + cat2.age + &quot;,共抓 &quot; + cat2.miceCount + &quot; 隻老鼠&quot;); Console.ReadKey(); } } class Cat { //名稱 public string name; //年齡 public int age; //老鼠數量 public int miceCount = 0; //記錄抓幾隻老鼠 //方法成員 //方法:打招呼 public void Hello() { Console.WriteLine(&quot;嗨!我是{0} &quot;, name); } //方法:喵喵叫 public void Meow() { Hello(); Console.WriteLine(&quot;喵~~~~~喵~~~&quot;); } //方法:捉老鼠 public void CaseMice() { miceCount++; Hello(); Console.WriteLine(&quot;我已經抓了 {0} 隻老鼠&quot;, miceCount); } } }  結果: 嗨!我是慚愧一隻貓 我已經抓了 1 隻老鼠 嗨!我是慚愧一隻貓 我已經抓了 2 隻老鼠 嗨!我是無悔一隻貓 我已經抓了 1 隻老鼠 姓名 : 慚愧一隻貓,年齡 : 10,共抓 2 隻老鼠 姓名 : 無悔一隻貓,年齡 : 35,共抓 1 隻老鼠 ","version":"Next","tagName":"h3"},{"title":"以上就是物件，最基本元素的用法，我們明天見喽​","type":1,"pageTitle":"🤖 物件導向(oop)~物件(Object)","url":"/en/docs/ironMan13/day22#以上就是物件最基本元素的用法我們明天見喽","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~屬性(Property)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day23","content":"","keywords":"","version":"Next"},{"title":"訪問器 (Assessor)​","type":1,"pageTitle":"🤖 物件導向(oop)~屬性(Property)","url":"/en/docs/ironMan13/day23#訪問器-assessor","content":"把變數改為私用private int age;並加入兩行限制 ","version":"Next","tagName":"h3"},{"title":"範例:我們建立一個狗的類別做練習​","type":1,"pageTitle":"🤖 物件導向(oop)~屬性(Property)","url":"/en/docs/ironMan13/day23#範例我們建立一個狗的類別做練習","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Dog dog = new Dog(); //設定為三歲 dog.SetAge(3); Console.WriteLine(dog.GetAge()); //設定為-1歲 dog.SetAge(-1); Console.WriteLine(dog.GetAge()); Console.ReadKey(); } } //狗的類別 class Dog { //名稱 public string name; //年齡 private int age; //設定年齡 public void SetAge(int ageValue) { //如果年齡為負數就改成0 if (ageValue &lt;= 0) { age = 0; } else { age = ageValue; } } //回傳設定後的年齡 public int GetAge() { return age; } } }  結果: 3 0 ※訪問器雖然解決了問題，但大家還是習慣把年齡作為變數使用。屬性就是這而生的 ","version":"Next","tagName":"h3"},{"title":"屬性(Property)​","type":1,"pageTitle":"🤖 物件導向(oop)~屬性(Property)","url":"/en/docs/ironMan13/day23#屬性property","content":"屬性的好處: 有封裝性可以進行合法性的檢查符合變數的使用方式 用法: 習慣將變數命名成小寫，屬性命名為大寫 定義了 get 與 set 兩個訪問器 ➀get 訪問器用來讀取變數的值 ➁set 訪問器用來修改變數的值 ","version":"Next","tagName":"h3"},{"title":"範例:我們來建立一個鴨子類別來練習吧​","type":1,"pageTitle":"🤖 物件導向(oop)~屬性(Property)","url":"/en/docs/ironMan13/day23#範例我們來建立一個鴨子類別來練習吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Duck duck = new Duck(); //設定為三歲 duck.duckAge = 3; Console.WriteLine(duck.duckAge); //設定為-1歲 duck.duckAge = -1; Console.WriteLine(duck.duckAge); Console.ReadKey(); } } /// &lt;summary&gt; /// Day23-02 /// 鴨的類別 /// &lt;/summary&gt; class Duck { //名稱 public string name; //年齡 private int age; //屬性 public int duckAge { get//回傳值 { //回傳設定後的值 return age; } set //設定值 { if (value &lt;= 0) { age = 0; } else { age = value; } } } } }  結果: 3 0 ","version":"Next","tagName":"h3"},{"title":"屬性解決了我們喜換用變數，又可以自動檢查，並且又具有封裝性，一次解決三種問題​","type":1,"pageTitle":"🤖 物件導向(oop)~屬性(Property)","url":"/en/docs/ironMan13/day23#屬性解決了我們喜換用變數又可以自動檢查並且又具有封裝性一次解決三種問題","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~建構方法(Constructor)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day24","content":"","keywords":"","version":"Next"},{"title":"建構方法​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#建構方法","content":"在我們創建物件時，系統為物件的成員分配記憶體，然後通過建構方法來初始化物件的成員變數 ","version":"Next","tagName":"h3"},{"title":"1. 默認建構方法 : 每個類別都有一個默認的與類別同名的建構方法​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#1-默認建構方法--每個類別都有一個默認的與類別同名的建構方法","content":"建構方法總是存在的，即使沒有特別顯示定義，編譯器也會為類別分配一個默認的建構方法每當類別實例化時，每個成員都會在記憶體分到內存空間，並寫存入初始值 EX: 整型變數 初始 &gt;&gt; 0 實型變數 初始 &gt;&gt; 0.0 布林變數 初始 &gt;&gt; false 字串變數 初始 &gt;&gt; null ","version":"Next","tagName":"h3"},{"title":"範例:我們建立一個豬的類別來看看結果​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#範例我們建立一個豬的類別來看看結果","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Pig pig = new Pig(); Console.WriteLine(&quot;name = &quot; + pig.name); Console.WriteLine(&quot;age = &quot; + pig.age); Console.ReadKey(); } } //豬的類別 class Pig { //名稱 public string name; //年齡 public int age; } }  結果: name = age = 0 ","version":"Next","tagName":"h3"},{"title":"2. 帶參數的建構方法​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#2-帶參數的建構方法","content":"※建構方法是一種特殊涵式，她必須和類別同名，並且沒有返回類型(連void也沒有) ","version":"Next","tagName":"h3"},{"title":"範例:我們修改一下豬類別吧​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#範例我們修改一下豬類別吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //使用建構方法 Pig pig = new Pig(&quot;肥嘟嘟一隻豬&quot;, 3); Console.WriteLine(&quot;姓名: &quot; + pig.name); Console.WriteLine(&quot;年齡: &quot; + pig.age); Console.ReadKey(); } } //豬的類別 class Pig { //名稱 public string name; //年齡 public int age; //使用建構方法 public Pig() { //初始化變數 name = nameValue; age = ageValue; } } }  結果: 姓名: 肥嘟嘟一隻豬 年齡: 3  ","version":"Next","tagName":"h3"},{"title":"3.無參數建構方法​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#3無參數建構方法","content":"當我們定義建構方法後，默認的函數就失效了，如果想繼續用無參數建構方，就必須顯式定義 ","version":"Next","tagName":"h3"},{"title":"範例:我們在修改一下豬的類別​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#範例我們在修改一下豬的類別","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Pig pig = new Pig(); Console.WriteLine(&quot;name = &quot; + pig.name); Console.WriteLine(&quot;age = &quot; + pig.age); Console.ReadKey(); } } //豬的類別 class Pig { //名稱 public string name; //年齡 public int age; //使用建構方法 public Pig() { //初始化變數 name = &quot;肥肥一隻豬&quot;; age = 20; } } }  結果: name = 肥肥一隻豬 age = 20 ","version":"Next","tagName":"h3"},{"title":"以上就是我們今天的建構方法，期待大家在點餐前就能想好自己要什麼了​","type":1,"pageTitle":"🤖 物件導向(oop)~建構方法(Constructor)","url":"/en/docs/ironMan13/day24#以上就是我們今天的建構方法期待大家在點餐前就能想好自己要什麼了","content":"","version":"Next","tagName":"h3"},{"title":"🤖 共產主義者~靜態成員","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day25","content":"","keywords":"","version":"Next"},{"title":"靜態變數​","type":1,"pageTitle":"🤖 共產主義者~靜態成員","url":"/en/docs/ironMan13/day25#靜態變數","content":"一般情況下變數成員並不會互相影響如同每個人都有自己的年齡，並不會互相影響但靜態變數不一樣，他的值在記憶體中只會存一份，然後大家一起共用他結構  範例: 我們來做一個小遊戲​ 目前農場有 30 隻雞一天會出生 3 隻雞每過兩天，農夫就會載 8 隻雞去市場賣掉只要農場的雞變成 0，那農場就倒閉了那一個月後農場會不會倒閉呢? using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { for(int i = 1; i &lt;= 31; i++) { Console.WriteLine(); Console.WriteLine(&quot;---新的一天--&quot;); Console.WriteLine(&quot;今天 : &quot; + i + &quot;號&quot;); //新的一天需要生新的雞 Chicken chickenClass = new Chicken(); chickenClass.NewDayChicken(); Console.WriteLine(&quot;目前農場有 : &quot; + Chicken.ChickenCount + &quot;隻雞&quot;); //判斷今天是否有要去市場 if ((i % 2) == 0) { //農夫去市場賣雞 Farmer farmerClass = new Farmer(); Console.WriteLine(&quot;農夫載雞去賣了...&quot;); farmerClass.GoToMarket(); Console.WriteLine(&quot;賣完雞後剩下 : &quot; + Chicken.ChickenCount + &quot;隻雞&quot;); } //判斷雞還剩幾隻 if(Chicken.ChickenCount &lt;= 0) { Console.WriteLine(); Console.WriteLine(&quot;!!!!!!!雞被賣光光了!!!!!&quot;); Console.WriteLine(&quot;農場倒閉!&quot;); //既然營業不下去就跳脫迴圈吧 break; } } Console.ReadKey(); } } //定義雞的類別 class Chicken { //宣告一個雞數量的靜態變數 public static int ChickenCount = 30; //新的一天生四隻雞 public void NewDayChicken() { ChickenCount += 3; } } //定義農夫的類別 class Farmer { public void GoToMarket() { //使用靜態變數不需要實例化 Chicken.ChickenCount -= 8; } } }  結果: ---新的一天-- 今天 : 1 號 目前農場有 : 33 隻雞 ---新的一天-- 今天 : 2 號 目前農場有 : 36 隻雞 農夫載雞去賣了... 賣完雞後剩下 : 28 隻雞 ---新的一天-- 今天 : 3 號 目前農場有 : 31 隻雞 ---新的一天-- 今天 : 4 號 目前農場有 : 34 隻雞 農夫載雞去賣了... 賣完雞後剩下 : 26 隻雞 . . . . ---新的一天-- 今天 : 29 號 目前農場有 : 5 隻雞 ---新的一天-- 今天 : 30 號 目前農場有 : 8 隻雞 農夫載雞去賣了... 賣完雞後剩下 : 0 隻雞 !!!!!!!雞被賣光光了!!!!! 農場倒閉!  最終雞還是供不應求賣光光了!農場難逃倒閉危機! ","version":"Next","tagName":"h3"},{"title":"靜態變數只有在創建類別的時候會做一次初始化而已，這點是大家須特別注意的，我們就明天見喽​","type":1,"pageTitle":"🤖 共產主義者~靜態成員","url":"/en/docs/ironMan13/day25#靜態變數只有在創建類別的時候會做一次初始化而已這點是大家須特別注意的我們就明天見喽","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~ 多載(Overload)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day26","content":"","keywords":"","version":"Next"},{"title":"多載​","type":1,"pageTitle":"🤖 物件導向(oop)~ 多載(Overload)","url":"/en/docs/ironMan13/day26#多載","content":"","version":"Next","tagName":"h3"},{"title":"範例:我們先來看一段程式​","type":1,"pageTitle":"🤖 物件導向(oop)~ 多載(Overload)","url":"/en/docs/ironMan13/day26#範例我們先來看一段程式","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Console.WriteLine(&quot;Int : &quot; + Calculate.DivideInt(10, 20)); Console.WriteLine(&quot;Double : &quot; + Calculate.DivideDouble(10.11, 20.22)); Console.ReadKey(); } } //定義計算的類別 class Calculate { //宣告靜態法來計算整數 public static int DivideInt(int x, int y) { return x * y; } //宣告靜態法來計算浮點數 public static double DivideDouble(double x, double y) { return x * y; } } }  結果: Int : 200 Double : 204.4242 如果需要不同的算法，我們就需要寫種方法，但對於多載來說它可以幫他們穿上制服 ","version":"Next","tagName":"h3"},{"title":"範例:使用多載來處理上面的程式吧​","type":1,"pageTitle":"🤖 物件導向(oop)~ 多載(Overload)","url":"/en/docs/ironMan13/day26#範例使用多載來處理上面的程式吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Console.WriteLine(&quot;Int : &quot; + Calculate.Divide(10, 20)); Console.WriteLine(&quot;Double : &quot; + Calculate.Divide(10.11, 20.22)); Console.ReadKey(); } } // 定義計算的類別 class Calculate { //宣告靜態法來計算整數 public static int Divide(int x, int y) { return x * y; } //宣告靜態法來計算浮點數 public static double Divide(double x, double y) { return x * y; } } }  結果: Int : 200 Double : 204.4242 各位可能會突然頓悟，啊原來多載就是一樣名字的方法，卻可以做不同事情 ","version":"Next","tagName":"h3"},{"title":"希望大家都學會幫自己的程式穿上一樣的制服喔，我們明天見​","type":1,"pageTitle":"🤖 物件導向(oop)~ 多載(Overload)","url":"/en/docs/ironMan13/day26#希望大家都學會幫自己的程式穿上一樣的制服喔我們明天見","content":"","version":"Next","tagName":"h3"},{"title":"🤖 做錯事該怎麼辦呢?~錯誤處理","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day27","content":"","keywords":"","version":"Next"},{"title":"異常(Exception)​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#異常exception","content":"程式不可能萬無一失，總會有出錯的一天但如果不處理這些錯誤，可能會造成程式崩潰 ","version":"Next","tagName":"h3"},{"title":"範例:我們寫一個分數，並看看分母為零會發生什麼事情吧​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#範例我們寫一個分數並看看分母為零會發生什麼事情吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告分子 int x = 100; //宣告分母 int y = 0; int z = x / y; Console.WriteLine(&quot;結果 : &quot; + z); Console.ReadKey(); } } }  結果: 未處理的例外狀況: System.DivideByZeroException: 嘗試以零除。 於 CsharpDemo.Program.Main(String[] args) 於 C:/CsharpDemo/Program.cs: 行 21 我們會發現程式拋出了一個DivideByZeroException類別的錯誤，來提醒開發者發生什麼事情了 ","version":"Next","tagName":"h3"},{"title":"捕捉異常~try-catch​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#捕捉異常try-catch","content":"try-chatch 能幫我們把異常捕捉出來，並且讓我們決定後續的處理 ","version":"Next","tagName":"h3"},{"title":"範例:我們讓使用者輸入分母，並且來捕捉錯誤吧​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#範例我們讓使用者輸入分母並且來捕捉錯誤吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { try { Console.WriteLine(&quot;請輸入分母&quot;); //宣告分子 int x = 100; //宣告分母 int y = Convert.ToInt32(Console.ReadLine()); int z = x / y; Console.WriteLine(&quot;結果 : &quot; + z); } catch (DivideByZeroException)//捕捉分母為0的錯誤 { Console.WriteLine(&quot;分母不可以為0&quot;); } catch (FormatException)//捕捉格式錯誤 { Console.WriteLine(&quot;格式不正確&quot;); } Console.ReadKey(); } } }  輸入: 0 結果: 請輸入分母 0 分母不可以為 0 輸入: 孤獨一隻雞 結果: 請輸入分母 孤獨一隻雞 格式不正確 ","version":"Next","tagName":"h3"},{"title":"最後的處理~try-catch-finally​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#最後的處理try-catch-finally","content":"人不管有沒有犯錯，還是得吃飯程式也一樣，有些事情就算犯錯了還是得吧他做完 ","version":"Next","tagName":"h3"},{"title":"範例:我們來試試看吧​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#範例我們來試試看吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { try { Console.WriteLine(&quot;請輸入分母&quot;); //宣告分子 int x = 100; //宣告分母 int y = Convert.ToInt32(Console.ReadLine()); int z = x / y; Console.WriteLine(&quot;結果 : &quot; + z); } catch (Exception ex)//捕捉所有發生的錯誤，如果不知道可能會發生的錯誤可以使用此類別 { //ex.Message可得到簡易的錯誤描述，如果需要詳情，建議使用 ex.ToString() Console.WriteLine(ex.Message); } finally//最終要處理的事情 { Console.WriteLine(&quot;既然都犯錯了，那就收工吃飯吧!&quot;); } Console.ReadKey(); } } }  輸入: 0 結果: 請輸入分母 0 嘗試以零除。 既然都犯錯了，那就收工吃飯吧! ","version":"Next","tagName":"h3"},{"title":"把異常丟出來~throw​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#把異常丟出來throw","content":"如果原本的異常不夠我們用，那我們就人工來拋異常吧 ","version":"Next","tagName":"h3"},{"title":"範例:我們來輸入 1~10 的數字吧，超過就把錯誤拋出來​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#範例我們來輸入-110-的數字吧超過就把錯誤拋出來","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { try { Console.WriteLine(&quot;請輸入1~10任一數&quot;); int number = Convert.ToInt32(Console.ReadLine()); //判斷是否有超過範圍 if (number &lt; 1 || number &gt; 10) { //拋出超出範圍的異常 throw new IndexOutOfRangeException(); } else { Console.WriteLine(&quot;你輸入了 : &quot; + number); } } catch (Exception ex)//捕捉所有發生的錯誤，如果不知道可能會發生的錯誤可以使用此類別 { //ex.Message可得到簡易的錯誤描述，如果需要詳情，建議使用 ex.ToString() Console.WriteLine(ex.Message); } finally//最終要處理的事情 { Console.WriteLine(&quot;既然都犯錯了，那就收工吃飯吧!&quot;); } Console.ReadKey(); } } }  輸入: 11 結果: 請輸入 1~10 任一數 11 索引在陣列的界限之外。 既然都犯錯了，那就收工吃飯吧! ","version":"Next","tagName":"h3"},{"title":"今天學會錯誤處理之後，程式就不會因為一點點小毛病就當掉啦，期待我們明天再會啦​","type":1,"pageTitle":"🤖 做錯事該怎麼辦呢?~錯誤處理","url":"/en/docs/ironMan13/day27#今天學會錯誤處理之後程式就不會因為一點點小毛病就當掉啦期待我們明天再會啦","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~ 繼承","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day28","content":"","keywords":"","version":"Next"},{"title":"繼承概述​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#繼承概述","content":"繼承的概念就如同生物學裡面的，界門綱目科屬種關係是一層一層繼承下來的就如同脊椎動物的特徵都是，有脊椎，有體溫，會呼吸，鳥類也有以上特徵，因此只需要去繼承脊椎動物的特徵，並加上自己的特徵，有翅膀，會下蛋，雞更屬於他們的下層，因此雞也可以繼承以上的特徵，並且加上自己的特徵，有雞冠，會咕咕叫如同上面條件脊椎動物，我們會把它稱為基底類別(Base class)再來就是繼承他的類別我們稱之為衍生類別（Derived class） ","version":"Next","tagName":"h3"},{"title":"小練習​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#小練習","content":"","version":"Next","tagName":"h3"},{"title":"1. 建立雞底類別​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#1-建立雞底類別","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { vertebrate vertebrateClass = new vertebrate(); //先個別印特徵 Console.WriteLine(&quot;各別顯示特徵&quot;); vertebrateClass.VertebrateFeature1(); vertebrateClass.VertebrateFeature2(); vertebrateClass.VertebrateFeature3(); //一次全印 Console.WriteLine(); Console.WriteLine(&quot;一次列出所有特徵&quot;); vertebrateClass.ShowALLVertebrateFeature(); Console.ReadKey(); } } //脊椎動物類 class vertebrate { //特徵1:會呼吸 public void VertebrateFeature1() { Console.WriteLine(&quot;我會呼吸&quot;); } //特徵2:有脊椎 public void VertebrateFeature2() { Console.WriteLine(&quot;我有脊椎&quot;); } //特徵3:有體溫 public void VertebrateFeature3() { Console.WriteLine(&quot;我有體溫&quot;); } //顯示所有特徵 public void ShowALLVertebrateFeature() { VertebrateFeature1(); VertebrateFeature2(); VertebrateFeature3(); } } }  結果: 各別顯示特徵 我會呼吸 我有脊椎 我有體溫 一次列出所有特徵 我會呼吸 我有脊椎 我有體溫  ","version":"Next","tagName":"h3"},{"title":"2. 建立衍生類別~鳥類​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#2-建立衍生類別鳥類","content":"繼承用法就是在新的衍生類別後面加上:基底類別如: class Birds: vertebrate這時他將會擁有上一個類別的所有特性 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //實例化鳥類 Birds birdsClass = new Birds(); //先個別印特徵 Console.WriteLine(&quot;各別顯示特徵&quot;); birdsClass.BirdsFeature1(); birdsClass.BirdsFeature2(); birdsClass.VertebrateFeature1(); birdsClass.VertebrateFeature2(); birdsClass.VertebrateFeature3(); //一次全印 Console.WriteLine(); Console.WriteLine(&quot;一次列出所有特徵&quot;); birdsClass.ShowALLBirdsFeature(); Console.ReadKey(); } } //鳥類，並且繼承脊椎動物類 class Birds : vertebrate { //特徵1:會呼吸 public void BirdsFeature1() { Console.WriteLine(&quot;我有翅膀&quot;); } //特徵2:有脊椎 public void BirdsFeature2() { Console.WriteLine(&quot;我會下蛋&quot;); } //顯示所有特徵 public void ShowALLBirdsFeature() { //直接用脊椎動物類的全部顯示方法 ShowALLVertebrateFeature(); BirdsFeature1(); BirdsFeature2(); } } //脊椎動物類 class vertebrate { //特徵1:會呼吸 public void VertebrateFeature1() { Console.WriteLine(&quot;我會呼吸&quot;); } //特徵2:有脊椎 public void VertebrateFeature2() { Console.WriteLine(&quot;我有脊椎&quot;); } //特徵3:有體溫 public void VertebrateFeature3() { Console.WriteLine(&quot;我有體溫&quot;); } //顯示所有特徵 public void ShowALLVertebrateFeature() { VertebrateFeature1(); VertebrateFeature2(); VertebrateFeature3(); } } }  結果: 各別顯示特徵 我有翅膀 我會下蛋 我會呼吸 我有脊椎 我有體溫 一次列出所有特徵 我會呼吸 我有脊椎 我有體溫 我有翅膀 我會下蛋 你會發現太神奇了吧，繼承了別的類別，就能擁有它的功能，還可以自己增加新東西 ","version":"Next","tagName":"h3"},{"title":"我們來個課後練習吧​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#我們來個課後練習吧","content":"","version":"Next","tagName":"h3"},{"title":"練習題:請繼承上面鳥類來生出一隻雞​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#練習題請繼承上面鳥類來生出一隻雞","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //實例化雞類 Chicken chickenClass = new Chicken(); //先個別印特徵 Console.WriteLine(&quot;各別顯示特徵&quot;); chickenClass.ChickenFeature1(); chickenClass.ChickenFeature2(); chickenClass.BirdsFeature1(); chickenClass.BirdsFeature2(); chickenClass.VertebrateFeature1(); chickenClass.VertebrateFeature2(); chickenClass.VertebrateFeature3(); //一次全印 Console.WriteLine(); Console.WriteLine(&quot;一次列出所有特徵&quot;); chickenClass.ShowALLChickenFeature(); Console.ReadKey(); } } //雞類病繼承鳥類 class Chicken : Birds { //特徵1:會呼吸 public void ChickenFeature1() { Console.WriteLine(&quot;我有有雞冠&quot;); } //特徵2:有脊椎 public void ChickenFeature2() { Console.WriteLine(&quot;我會咕咕叫&quot;); } //顯示所有特徵 public void ShowALLChickenFeature() { //直接用脊椎動物類的全部顯示方法 ShowALLBirdsFeature(); ChickenFeature1(); ChickenFeature2(); } } //鳥類，並且繼承脊椎動物類 class Birds : vertebrate { //特徵1:會呼吸 public void BirdsFeature1() { Console.WriteLine(&quot;我有翅膀&quot;); } //特徵2:有脊椎 public void BirdsFeature2() { Console.WriteLine(&quot;我會下蛋&quot;); } //顯示所有特徵 public void ShowALLBirdsFeature() { //直接用脊椎動物類的全部顯示方法 ShowALLVertebrateFeature(); BirdsFeature1(); BirdsFeature2(); } } //脊椎動物類 class vertebrate { //特徵1:會呼吸 public void VertebrateFeature1() { Console.WriteLine(&quot;我會呼吸&quot;); } //特徵2:有脊椎 public void VertebrateFeature2() { Console.WriteLine(&quot;我有脊椎&quot;); } //特徵3:有體溫 public void VertebrateFeature3() { Console.WriteLine(&quot;我有體溫&quot;); } //顯示所有特徵 public void ShowALLVertebrateFeature() { VertebrateFeature1(); VertebrateFeature2(); VertebrateFeature3(); } } }  結果: 各別顯示特徵 我有有雞冠 我會咕咕叫 我有翅膀 我會下蛋 我會呼吸 我有脊椎 我有體溫 一次列出所有特徵 我會呼吸 我有脊椎 我有體溫 我有翅膀 我會下蛋 我有有雞冠 我會咕咕叫 ","version":"Next","tagName":"h3"},{"title":"繼承是物件導向語言的超強功能，要好好利用他，能更精簡程式碼，明天見喽​","type":1,"pageTitle":"🤖 物件導向(oop)~ 繼承","url":"/en/docs/ironMan13/day28#繼承是物件導向語言的超強功能要好好利用他能更精簡程式碼明天見喽","content":"","version":"Next","tagName":"h3"},{"title":"🤖 物件導向(oop)~介面(Interface)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day29","content":"","keywords":"","version":"Next"},{"title":"介面(Interface)​","type":1,"pageTitle":"🤖 物件導向(oop)~介面(Interface)","url":"/en/docs/ironMan13/day29#介面interface","content":"在介面命名中大家習慣以I開頭在介面中，我們要去定義與規範類別成員介面中不會去寫任何得邏輯而且介面的成員永遠都是公用的，所以不需要也不能加上public如果需要簽合約的類別就必須繼承介面 ","version":"Next","tagName":"h3"},{"title":"範例:每台 ATM 都需要統一他們的方法，因此我們來建立一個 ATM 的介面吧​","type":1,"pageTitle":"🤖 物件導向(oop)~介面(Interface)","url":"/en/docs/ironMan13/day29#範例每台-atm-都需要統一他們的方法因此我們來建立一個-atm-的介面吧","content":" //ATM介面 interface IATM { //方法:存款 void PayIn(int amount); //方法:收款 bool GetMoney(int amount); //屬性:帳戶餘額 int Balance { get; } }  這就是一個介面的樣子介面最大的用途就是讓所有與他簽合約的類別保持方法與成員一致 ","version":"Next","tagName":"h3"},{"title":"範例:我們來實作一台雞頭牌 ATM，並與介面簽合約吧​","type":1,"pageTitle":"🤖 物件導向(oop)~介面(Interface)","url":"/en/docs/ironMan13/day29#範例我們來實作一台雞頭牌-atm並與介面簽合約吧","content":" //雞頭牌ATM public class ChickenATM : IATM //需要繼承介面 { //私有變數 private int blance; //繼承後，就必須有介面裡面定義的方法 //方法:存款 public void PayIn(int amount) { blance += amount; } //方法:收款 public bool GetMoney(int amount) { //判斷餘額是否足夠 if (blance &gt;= amount) { blance -= amount; return true; } else { Console.WriteLine(&quot;餘額不足，取款失敗!&quot;); return false; } } //屬性:帳戶餘額 public int Balance { get { return blance; } } }  ","version":"Next","tagName":"h3"},{"title":"範例:既然 Atm 都蓋好了，我們就來測一下​","type":1,"pageTitle":"🤖 物件導向(oop)~介面(Interface)","url":"/en/docs/ironMan13/day29#範例既然-atm-都蓋好了我們就來測一下","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { ///有包含介面的宣告方式,前面可先選方式 public static IATM chickenAtm = new ChickenATM(); static void Main(string[] args) { //先讓客人選擇功能 Console.WriteLine(); Console.WriteLine(&quot;請選擇需要模式&quot;); Console.WriteLine(&quot;存款請按1，領款請按2&quot;); string goFuncton = Console.ReadLine(); //判斷要使用哪個方法 if (goFuncton == &quot;1&quot;)//領錢 { Console.WriteLine(&quot;請輸入要存入的金額!&quot;); int amount = Convert.ToInt32(Console.ReadLine()); //付款方法 chickenAtm.PayIn(amount); } else if(goFuncton == &quot;2&quot;) { Console.WriteLine(&quot;請輸入要領取的金額!&quot;); int amount = Convert.ToInt32(Console.ReadLine()); //付款方法 chickenAtm.GetMoney(amount); } Console.WriteLine(&quot;目前餘額 : &quot; + chickenAtm.Balance); //這邊用遞迴來讓方法可以持續輪迴 string[] array = new string[0]; Main(array); } } //ATM介面 interface IATM { //方法:存款 void PayIn(int amount); //方法:收款 bool GetMoney(int amount); //屬性:帳戶餘額 int Balance { get; } } //雞頭牌ATM public class ChickenATM : IATM //需要繼承介面 { //私有變數 private int blance; //繼承後，就必須有介面裡面定義的方法 //方法:存款 public void PayIn(int amount) { blance += amount; } //方法:收款 public bool GetMoney(int amount) { //判斷餘額是否足夠 if (blance &gt;= amount) { blance -= amount; return true; } else { Console.WriteLine(&quot;餘額不足，取款失敗!&quot;); return false; } } //屬性:帳戶餘額 public int Balance { get { return blance; } } } }  ","version":"Next","tagName":"h3"},{"title":"來玩看看以下劇情會產生的結果吧​","type":1,"pageTitle":"🤖 物件導向(oop)~介面(Interface)","url":"/en/docs/ironMan13/day29#來玩看看以下劇情會產生的結果吧","content":"先領 50 元今天發工資啦，共 500 元，把錢都存進去吧忘記把吃飯錢領出來了，趕快領 100 來吃飯 結果: 請選擇需要模式 存款請按 1，領款請按 2 2 請輸入要領取的金額! 50 餘額不足，取款失敗! 目前餘額 : 0 請選擇需要模式 存款請按 1，領款請按 2 1 請輸入要存入的金額! 500 目前餘額 : 500 請選擇需要模式 存款請按 1，領款請按 2 2 請輸入要領取的金額! 100 目前餘額 : 400 請選擇需要模式 存款請按 1，領款請按 2 ","version":"Next","tagName":"h3"},{"title":"以上就是我們的介面，他主要用途是在統一天下的，我們明天再見了鴨​","type":1,"pageTitle":"🤖 物件導向(oop)~介面(Interface)","url":"/en/docs/ironMan13/day29#以上就是我們的介面他主要用途是在統一天下的我們明天再見了鴨","content":"","version":"Next","tagName":"h3"},{"title":"🤖 核心的數據成員~變數(一)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day3","content":"","keywords":"","version":"Next"},{"title":"變數的世界​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#變數的世界","content":"在 C#世界中，基本上大家都希望有自己的歸屬感，所以他們都會被賦予一個的種族， 這也是所謂的強型別語言擁有的特性。 我們待會會跟各位介紹常見的種族，正是所謂的變數型別。 我們在這世界無論或大或小都會有一個棲身之處，也許是皇宮或者是天橋下，總有個地方讓我們睡覺， 變數也是一樣的，它們在電腦世界中無論如何最終會有一個記憶體內存供他們容身。 ","version":"Next","tagName":"h2"},{"title":"數字類型的變數​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#數字類型的變數","content":"數字類型的變數是變數中人口最多的種族了，當然他們底下也細分成很多種族群 ","version":"Next","tagName":"h3"},{"title":"整數變數​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#整數變數","content":"整數這東西是人類在歷史上最早掌握的數字，我們來套用一個古人的名言: “1”是數的第一原則，萬物之母，也是智慧； “2”是對立和否定的原則，是意見； “3”是萬物的形體和形式； “4”是正義，是宇宙創造者的象徵； “5”是奇數和偶數，雄性與雌性和結合，也是婚姻； “6”是神的生命，是靈魂； “7”是機會； “8 ”是和諧，也是愛情和友誼； “9”是理性和強大； “10”包容了一切數目，是完滿和美好。 --畢達哥拉斯 沒錯這就是標榜&quot;萬物皆數&quot;的畢達哥拉斯，他讓我們了解到生活上處處都存在著整數的運算接下來我們就心動不如馬上行動，來看看 C#世界中的整數吧! 首先我們剛剛有說過，當一個變數出生前，我們就得先給他們個種族(類型)那麼整數的種族標誌就是 int當一個變數被賦予 int 之後，他就擁有一個家族使命，並馬上獲得他的領土(內存中 4 個 Byte 的空間)但因為剛剛才出生，所以什麼都不會，就如同一張白紙一樣(默認預設值 0) 明白整數的身世之謎後我們來他玩玩吧!題目: 阿嬤到菜市場買菜，買了一根 50 元的蘿蔔跟 70 元的豬肉，請問阿嬤在未殺價的情況下給了攤主多少錢呢? using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //首先要來一個型態為整數的蘿蔔變數 int radish; //再來個型態為整數的豬肉變數 int pork; //此時阿嬤問攤主蘿蔔多少錢，攤主告訴阿嬤50元 //我們就可以讓蘿蔔變成50元 radish = 50; //這時阿嬤又問攤主豬肉多少錢，攤主告訴阿嬤70元 //我們就可以就來讓豬肉變成70元 pork = 70; //阿嬤為了計算方便就先把價錢寫下來了 Console.WriteLine(&quot;蘿蔔 &quot; + radish + &quot;元 ，豬肉 &quot; + pork + &quot;元&quot;); //這時候店家拿出計算機按給阿嬤看 int computer = radish + pork; //阿嬤看按計算機上面寫的價錢，就從錢包拿出錢給攤販開心回家了 Console.WriteLine(&quot;計算機畫面 =&gt; &quot; + radish + &quot; + &quot; + pork + &quot; = &quot; + computer); Console.ReadKey(); } } }  ","version":"Next","tagName":"h3"},{"title":"執行:我們可以按快捷鍵(Ctrl+F5)或是點選功能列的開始執行程式​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#執行我們可以按快捷鍵ctrlf5或是點選功能列的開始執行程式","content":"蘿蔔 50 元 ，豬肉 70 元\\ 計算機畫面 =&gt; 50 + 70 = 120 ","version":"Next","tagName":"h3"},{"title":"知識小學堂​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#知識小學堂","content":"這就是所謂的整數變數這邊是整數的家，在內存中佔了 4Byte，也就是 32bit ","version":"Next","tagName":"h3"},{"title":"其他整數類型​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#其他整數類型","content":"short 型(短整數) : 這種類型只會分配到 2 個 byte，他值範圍為-32768~32768long 型(長整數) : 他擁有 8 個 byte，值的範圍則是-9223372036854775808~9223372036854775807如果我們在short與long前面看到一個英文字母u，他則是無符號的型別ushort，ulong，他們這種族的世界中，是沒有負面情緒的，是個十分樂觀的種族，所以他們只有正數，沒有負數 ","version":"Next","tagName":"h3"},{"title":"現在我們來歸納一下整數類型吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#現在我們來歸納一下整數類型吧","content":"C#類型\t值的範圍\t中文名稱byte\t0 ~ 255\t字節 short\t-32768 ~ 32767\t短整數 ushort\t0 ~ 65535\t無號短整數 int\t-2147483648 ~ 2147483647\t整數 uint\t0 ~ 4294967295\t無號整數 long\t-9223372036854775808~9223372036854775807\t長整數 ulong\t0 ~ 18446744073709551615\t無號長整數 注意:如果使用超出這些範圍外，我們將它稱為溢位，程式會出錯， 所以我們使用前應該要先想好會用到多大的數值，別宣告太小導致溢位， 也別宣告太大而佔用內存空間 ","version":"Next","tagName":"h3"},{"title":"浮點數執行別變數​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#浮點數執行別變數","content":"什麼是浮點數呢?浮點數就是所謂的小數有時候整數的運算，已經無法滿足我們的需求，所以 C#中也有小數的運算 ","version":"Next","tagName":"h3"},{"title":"小數最常見有三種類型​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#小數最常見有三種類型","content":"C#類型\t值的範圍\t準確率float\t±1.5 x 10−45 ~ ±3.4 x 1038\t~6-9 位數 double\t±5.0 × 10−324 ~ ±1.7 × 10308\t~15-17 位數 decimal\t±1.0 x 10-28 ~ ±7.9228 x 1028\t28-29 位數 ","version":"Next","tagName":"h3"},{"title":"我們馬上來練習看看吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#我們馬上來練習看看吧","content":"題目:請分別用 float 與 double 來印出?。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //使用float型別來宣告變數 //記得數字最後要加上後置詞f float pi_f = 3.1415926535879f; //使用double來宣告變數 double pi_d = 3.1415926535879; Console.WriteLine(&quot;pi_f = &quot; + pi_f); Console.WriteLine(&quot;pi_d = &quot; + pi_d); Console.ReadKey(); } } }  ","version":"Next","tagName":"h3"},{"title":"結果​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#結果","content":"pi_f = 3.141593\\ pi_d = 3.1415926535879 由此我們就可以看得出，他們型別之間的差異，這樣在使用之前，我們可以優先考慮，應該要用哪個型別 ","version":"Next","tagName":"h3"},{"title":"歡樂的時光總是過得特別的快，以上就是我們今天的變數，請大家請期待明天的字串變數​","type":1,"pageTitle":"🤖 核心的數據成員~變數(一)","url":"/en/docs/ironMan13/day3#歡樂的時光總是過得特別的快以上就是我們今天的變數請大家請期待明天的字串變數","content":"","version":"Next","tagName":"h3"},{"title":"🤖 Install Tailwind Css with ASP.NET MVC5","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day30","content":"","keywords":"","version":"Next"},{"title":"一.先前準備​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#一先前準備","content":"建立新資料夾將資料夾命名為 jit_init  開啟資料夾位置  於路徑輸入 CMD，並按下 Enter  ","version":"Next","tagName":"h3"},{"title":"二.導入 tailwindcss​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#二導入-tailwindcss","content":"於主控台輸入 npx tailwindcss-cli init --jit成功之後會在 jit_init 資料夾看到 tailwind.config.js 檔案  將附檔 package.json 複製到 jit_init 資料夾輸入 npm install tailwindcss autoprefixer postcss postcss-cli成功之後會在 jit_init 資料夾看到 node_modules 目錄以及 package-lock.json 檔案package.json (點我下載)  將附檔 public.zip 解壓縮並複製到 jit_init 資料夾public.zip (點我下載) 開啟 package.json 修改 css 輸出路徑 開啟 tailwind.config.js 修改 purge(tailwindcss 作用範圍) MVC 為例('../Views/*/.cshtml')  ","version":"Next","tagName":"h3"},{"title":"三.啟動 tailwindcss-cli​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#三啟動-tailwindcss-cli","content":"於主控台輸入npm install 於主控台輸入npm run jit ","version":"Next","tagName":"h3"},{"title":"四.MVC 專案設定​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#四mvc-專案設定","content":"將 app.css 引用到_Layout.cshtml&lt;link href=&quot;~/Content/app.css&quot; rel=&quot;stylesheet&quot;&gt;  於方案總管點選顯示所有檔案 將 app.css 加入專案 ","version":"Next","tagName":"h3"},{"title":"注意:每次重新開啟專案時，皆需執行 npm run jit 指令​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#注意每次重新開啟專案時皆需執行-npm-run-jit-指令","content":"這樣編輯 CSS 時，才有辦法做更新 ","version":"Next","tagName":"h3"},{"title":"最後最後，我們謝謝兔兔當時花很多時間在幫我校這份稿​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#最後最後我們謝謝兔兔當時花很多時間在幫我校這份稿","content":"","version":"Next","tagName":"h3"},{"title":"如果大家對 Tailwind Css 不熟，但很想入門，歡迎去看他的文章​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#如果大家對-tailwind-css-不熟但很想入門歡迎去看他的文章","content":"","version":"Next","tagName":"h3"},{"title":"兔兔傳送門 (點我來去找兔兔)​","type":1,"pageTitle":"🤖 Install Tailwind Css with ASP.NET MVC5","url":"/en/docs/ironMan13/day30#兔兔傳送門-點我來去找兔兔","content":"","version":"Next","tagName":"h3"},{"title":"🤖 結語","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day31","content":"","keywords":"","version":"Next"},{"title":"為什麼會想報名鴨?​","type":1,"pageTitle":"🤖 結語","url":"/en/docs/ironMan13/day31#為什麼會想報名鴨","content":"這是第一次參加鐵人賽， 會參加的原因都是一時衝動，真的是一時衝動，就報名下去了， 後來想說隨便寫個像是筆記的東西解鎖個成就， 想不到越來越多人追蹤，隨便寫筆記真的跟自己的雞心過意不去， 開始翻遍微軟的官網、自己最初學習的筆記與當初我的啟蒙之書(《叩响 C#之门》~ 梁斌玉)， 在這 30 天內我發現我觀念很多都不太足夠，邊寫邊學，會發現啊!原來這東西是這麼回事啊! ","version":"Next","tagName":"h2"},{"title":"一隻平凡無奇的雞的求學歷程​","type":1,"pageTitle":"🤖 結語","url":"/en/docs/ironMan13/day31#一隻平凡無奇的雞的求學歷程","content":"我並不是本科系的，當年意外地在網路上翻到這本《叩响 C#之门》開始了我的 C#之路， 所有所有的一切都是從這本書開始的，雖然是 20 年前的書了， 但基本的觀念還是與現今沒甚麼落差， 在我把程式碼敲進電腦時，發現程式竟然跑得起來，當下是如此的感動， 漸漸的越寫越有成就感，就這樣我真的開起 C#之門了。 ","version":"Next","tagName":"h3"},{"title":"偷偷幫各位半途遇到的好友推銷文章，大家有興趣可以去看看哦​","type":1,"pageTitle":"🤖 結語","url":"/en/docs/ironMan13/day31#偷偷幫各位半途遇到的好友推銷文章大家有興趣可以去看看哦","content":"同為 C#的-小乳牛​ [從 0 到 1] C#小乳牛 兔兔教得代表人物-兔兔​ 排版神器 Tailwind CSS  號稱是路人的 -深水小魚​ 當拉拉肉遇到單元測試 多才多藝的助教 -Ray​ 從 JavaScript 角度學 Python 美食專家 -雪倫​ 雪倫的 30 天拜託冰箱 ","version":"Next","tagName":"h3"},{"title":"這次鐵人賽的故事就到這邊告一段落了，我們有緣下次見​","type":1,"pageTitle":"🤖 結語","url":"/en/docs/ironMan13/day31#這次鐵人賽的故事就到這邊告一段落了我們有緣下次見","content":"","version":"Next","tagName":"h3"},{"title":"🤖 核心的數據成員~變數(二)","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day4","content":"","keywords":"","version":"Next"},{"title":"千變萬化的字串變數​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#千變萬化的字串變數","content":"他為什麼千變萬化呢?因為字串這種型別，別人給他什麼他就是什麼就如同一位認真向學的小朋友，他如此天真無邪，老師教的都會認真記住在 C#的世界中，我們要表明一個字串時都需要用&quot;&quot;把他包起來 ","version":"Next","tagName":"h2"},{"title":"範例:我們來看看有\"\"跟沒有\"\"的差異吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例我們來看看有跟沒有的差異吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個整數叫做 hi，然後賦予他100的值 int hi = 100; //我們來列印看看 Console.WriteLine(&quot;我沒有加雙引號 : &quot; + hi); Console.WriteLine(&quot;我有加雙引號 : &quot; + &quot;hi&quot;); Console.ReadKey(); } } }  結果: 我沒有加雙引號 : 100 我有加雙引號 : hi ","version":"Next","tagName":"h2"},{"title":"由此我們可以發現，加上\"\"的\"hi\"他是被當成文字的，沒有\"\"的 hi 他則是整數變數，會直接印出他的值​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#由此我們可以發現加上的hi他是被當成文字的沒有的-hi-他則是整數變數會直接印出他的值","content":"","version":"Next","tagName":"h3"},{"title":"我們接著開始介紹他們這型別的成員吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#我們接著開始介紹他們這型別的成員吧","content":"","version":"Next","tagName":"h3"},{"title":"首先歡迎字元型變數~char​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#首先歡迎字元型變數char","content":"char 他顧名思義只能存一個字元他跟大家不一樣的地方在於，他使用的是單引號''，而不是雙引號&quot;&quot; ","version":"Next","tagName":"h3"},{"title":"範例:使用一個 char 型別變數來印出 A B C 三個字母吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例使用一個-char-型別變數來印出-a-b-c-三個字母吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個char型別的變數 char hi; //先賦值A給變數hi，然後印出來 hi = 'A'; Console.WriteLine(&quot;1. &quot; + hi); //再來賦值B給變數hi，然後印出來 hi = 'B'; Console.WriteLine(&quot;2. &quot; + hi); //最後賦值C給變數hi，然後印出來 hi = 'C'; Console.WriteLine(&quot;3. &quot; + hi); Console.ReadKey(); } } }  結果: ABC ","version":"Next","tagName":"h3"},{"title":"再來是善變的字串型變數~string​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#再來是善變的字串型變數string","content":"string 類型可以存多個字元我們常常會需要讓用戶輸入一長串的資訊，或是我們需要顯示一些提示給用戶，他就是最佳人選 ","version":"Next","tagName":"h3"},{"title":"範例:我們讓電腦自己跟自己來個尬聊​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例我們讓電腦自己跟自己來個尬聊","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個string型別的變數 string hi; //讓電腦來個問候 hi = &quot;安安，你好，幾歲?住哪裡?&quot;; Console.WriteLine(hi); //讓電腦回答自己 hi = &quot;你好，你是個好人，但我才不要告訴你勒&quot;; Console.WriteLine(hi); Console.ReadKey(); } } }  結果: 安安，你好，幾歲?住哪裡? 你好，你是個好人，但我才不要告訴你勒 ","version":"Next","tagName":"h3"},{"title":"我們來玩轉字串吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#我們來玩轉字串吧","content":"","version":"Next","tagName":"h3"},{"title":"1.字串的讀取​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#1字串的讀取","content":"在這邊我們會用到Console.ReadLine()這個函式我們來試著跟電腦對話吧 ","version":"Next","tagName":"h3"},{"title":"範例:我們來對電腦輸入自己的名字讓他回答​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例我們來對電腦輸入自己的名字讓他回答","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //我們一開始使用Console.ReadLine()函式，讓電腦聽聽我們的心聲 //並將輸入的名字賦值到字串變數中 string name = Console.ReadLine(); //接下來讓電腦回答我們 Console.WriteLine(name + &quot;，帥氣十足!&quot;); Console.ReadKey(); } } }  輸入: 孤獨一隻雞 結果: 孤獨一隻雞 孤獨一隻雞，帥氣十足! ","version":"Next","tagName":"h3"},{"title":"2.字元的讀取​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#2字元的讀取","content":"在這邊我們會用到Console.Read()這個函式注意:Console.Read()讀出來會是字元的ASCII，所以會是整數 ","version":"Next","tagName":"h3"},{"title":"範例:我們來對電腦輸入一個字母，來查詢他 ASCII 編碼​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例我們來對電腦輸入一個字母來查詢他-ascii-編碼","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //我們使用Console.Read()函式，讓電腦讀取我們輸入的字母 //電腦會自動將他轉成ASCII編碼 //並將ASCII編碼賦值到變數中 int ch = Console.Read(); //印出輸入字母的 ASCII Console.WriteLine(&quot;The ASCII code is &quot; + ch); Console.ReadKey(); } } }  輸入: a 結果: a The ASCII code is 97 輸入: A 結果: A The ASCII code is 65 註:對於電腦而言，大寫或小寫甚至是任何符號，都有自己特有的編碼所以我們這邊輸入大小寫後會得到的結果 ","version":"Next","tagName":"h3"},{"title":"3.數字的讀取​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#3數字的讀取","content":"在這邊我們會用到Convert.ToInt32()這個函式Convert.ToInt32()這函式的用途，就是將其他型別轉成整數型別，稱為&quot;轉型&quot;就如同有人要移民來到美國，就必須到移民署辦理移民，而且要符合一些相關的規定，不然是辦理不成功的 ","version":"Next","tagName":"h3"},{"title":"範例:我們來對電腦輸入半徑，讓他自動算出圓面積​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例我們來對電腦輸入半徑讓他自動算出圓面積","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告半徑為整數變數 int r; //宣告圓面積為浮點數變數 double s; //宣告圓周率為浮點數變數 double π = 3.1415926536; //我們輸入一個半徑，並將輸入的半徑轉成整數，賦值給變數r Console.Write(&quot;r = &quot;); r = Convert.ToInt32(Console.ReadLine()); //計算面積 面積 = 圓周率 X 半徑 X 半徑 s = π * r * r; //印出答案 Console.WriteLine(&quot;Ans:&quot; + s); Console.ReadKey(); } } }  輸入: 5 結果: r = 5 Ans:78.53981634 ","version":"Next","tagName":"h3"},{"title":"4.字串的累加​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#4字串的累加","content":"當字串遇見了運算子&quot;+&quot;，究竟會產生什麼樣的愛恨糾葛呢?字串會直接銜接，並不會合體就如同我將隔壁鄰居的地買下來，那塊地還是在那個地方，並不會跟我的土地融合 ","version":"Next","tagName":"h3"},{"title":"範例:我們來產生各種口味的孤獨動物吧​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例我們來產生各種口味的孤獨動物吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告雞 string chicken = &quot;雞&quot;; //宣告魚 string fish = &quot;魚&quot;; //宣告狗 string dog = &quot;象&quot;; //宣告形容詞 string lonely = &quot;孤獨一隻&quot;; //將他們做累加 Console.WriteLine(lonely + chicken); Console.WriteLine(lonely + fish); Console.WriteLine(lonely + dog); Console.ReadKey(); } } }  結果: 孤獨一隻雞 孤獨一隻魚 孤獨一隻象 ","version":"Next","tagName":"h3"},{"title":"變數的命名規則​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#變數的命名規則","content":"最後在這邊跟各位說明一下命名規則 變數第一個字必須是字母底線或是@之後的字符可以是字母、數字或底線變數不能和關鍵字重名 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#範例","content":"正確命名: x a1 myname flowersCheckedListBox _number @float 錯誤命名: 8thStreet //不能以數字開頭命名 float //不能和關鍵字同名 注意: C#區分大小寫，比如name和Name是不同的變數，在為變數命名時，盡量選擇有意義的名稱。 ","version":"Next","tagName":"h3"},{"title":"關於變數的淒美愛情故事，我們就介紹到這邊了，大家明天見​","type":1,"pageTitle":"🤖 核心的數據成員~變數(二)","url":"/en/docs/ironMan13/day4#關於變數的淒美愛情故事我們就介紹到這邊了大家明天見","content":"","version":"Next","tagName":"h3"},{"title":"🤖 讓變數學會七十二變的高手~運算子","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day5","content":"","keywords":"","version":"Next"},{"title":"運算子​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#運算子","content":"程式的世界中，變數是無時無刻一直在變化的， 變數的變化 但為甚麼變 原來一切都 ","version":"Next","tagName":"h2"},{"title":"算術運​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#算術運","content":"在程式之，並將這兩個物件在指定的運算 ","version":"Next","tagName":"h3"},{"title":"C#之中​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#c之中","content":"運算子\t別+\t元 -\t元 *\t元 /\t元 %\t元 ","version":"Next","tagName":"h3"},{"title":"範例:使，來算出今天禮拜幾​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例使來算出今天禮拜幾","content":"using Syste using Syste; using Syste using Syste using Syste namespace C { class P { sta] args) { 公式 m + 3 * (m + 1) / 5 + y + y / 4 - y / 7; 021/9/6 星期&quot; + week); } } }  結果: 2021/9/6 在這公式中運算子，也體會到C#讓人十分驚豔的運算 ","version":"Next","tagName":"h3"},{"title":"特別的​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#特別的","content":"在 C#中的所差異在整數的動被捨去 ","version":"Next","tagName":"h3"},{"title":"範例:試我們觀念中應該答案是 1.5​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例試我們觀念中應該答案是-15","content":"using Syste using Syste; using Syste using Syste using Syste namespace C { class P { sta] args) { ns : &quot; + ans); } } }  結果: Ans : 1 由上我們後會直接被向0無條件捨去除非做浮浮點數 ","version":"Next","tagName":"h3"},{"title":"範例:驗數變數與直接做浮點數除法的差異​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例驗數變數與直接做浮點數除法的差異","content":"using Syste using Syste; using Syste using Syste using Syste namespace C { class P { sta] args) { 給浮點數變數 = &quot; + x + &quot; ，y = &quot; + y); } } }  結果 x = 4 ，y ","version":"Next","tagName":"h3"},{"title":"餘數運​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#餘數運","content":"使用此運數與方法[Macs.microsoft.com/zh-tw/dotnet/api/system.math.divrem一樣的結果 ","version":"Next","tagName":"h3"},{"title":"範例:我 來看看他們的餘數分別是多少​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例我-來看看他們的餘數分別是多少","content":"using Syste using Syste; using Syste using Syste using Syste namespace C { class P { sta] args) { 餘運算 0 % 4 =&quot; + no20); 1 % 4 =&quot; + no21); 2 % 4 =&quot; + no22); 3 % 4 =&quot; + no23); 4 % 4 =&quot; + no24); 5 % 4 =&quot; + no25); } } }  結果: 20 % 4 =0 21 % 4 =1 22 % 4 =2 23 % 4 =3 24 % 4 =0 25 % 4 =1 ","version":"Next","tagName":"h3"},{"title":"方法(Math)​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#方法math","content":"C#也有提供我們很多數學方法我們來介紹幾個比較常用的方法 功能\t方法\t範例\t數學表示 乘冪\tMath.Pow()\tMath.Pow(2,3)\t2^3 平方根\tMath.Sqrt()\tMath.Sqrt(4)\t√4 絕對值\tMath.Abs()\tMath.Abs(-4)\t`\t-4\t` 另外方法中還為我們定義三個欄位 數學涵義\t程式表示\t近似值\t說明τ\tMath.Tau\t6.2831853071795862\t弧度 π\tMath.PI\t3.1415926535897931\t圓周率 e\tMath.E\t2.7182818284590451\t自然對數底數 ","version":"Next","tagName":"h3"},{"title":"隨堂小練習​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#隨堂小練習","content":"","version":"Next","tagName":"h3"},{"title":"題目:已知梯形面積公式為((上底+下底)X 高/2)，目前知道上底是 30，下底是 52，高為 46​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#題目已知梯形面積公式為上底下底x-高2目前知道上底是-30下底是-52高為-46","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告上底 int x = 30; //宣告下底 int y = 52; //宣告高 int z = 46; //進行計算 int ans = (x + y) * z / 2; //印出答案 Console.WriteLine(&quot;Ans : &quot; + ans); Console.ReadKey(); } } }  結果: Ans : 1886 ","version":"Next","tagName":"h3"},{"title":"遞增運算子~++​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#遞增運算子","content":"他是屬於一元運算子增加的量為 1 ","version":"Next","tagName":"h3"},{"title":"範例 1(後置遞增運算子):我們來算算我今年 48 歲，明年我幾歲?​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例-1後置遞增運算子我們來算算我今年-48-歲明年我幾歲","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告我今年48歲 int age = 48; Console.WriteLine(&quot;我今年&quot; + age + &quot;歲&quot;); //使用後置遞增運算子，計算明年年紀 age++; Console.WriteLine(&quot;我明年&quot; + age + &quot;歲&quot;); Console.ReadKey(); } } }  結果: 我今年 48 歲 我明年 49 歲 ","version":"Next","tagName":"h3"},{"title":"範例 2(前置遞增運算子):我們來比較看看前置跟後置的差異吧​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例-2前置遞增運算子我們來比較看看前置跟後置的差異吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //後置遞增運算子，印出它的變化過程 Console.WriteLine(&quot;--後置運算子--&quot;); int x = 1; Console.WriteLine(x); Console.WriteLine(x++); Console.WriteLine(x); //前置遞增運算子，印出它的變化過程 Console.WriteLine(&quot;--前置運算子--&quot;); int y = 1; Console.WriteLine(y); Console.WriteLine(++y); Console.WriteLine(y); Console.ReadKey(); } } }  結果: --後置運算子-- 1 1 2 --前置運算子-- 1 2 2 由此我們可以看到前置跟後置的差異會是，在運算「之後」或「之前」某數的值 ","version":"Next","tagName":"h3"},{"title":"既然有遞增那必然有遞減運算子~--​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#既然有遞增那必然有遞減運算子--","content":"","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //遞減運算子 int x = 5; //後置 Console.WriteLine(x--); //前置 Console.WriteLine(--x); Console.ReadKey(); } } }  結果: 5 3 大家可能會覺得，這結果也太奇怪了吧?! 為什麼不是 5，4 呢? 原因很簡單，因為我們先用後置遞減運算子，所以他是在輸出 5 之後，x 變成 4 了， 接下來使用前置遞減運算子，所以 4 先被減成 3，然後才輸出 ","version":"Next","tagName":"h3"},{"title":"指派運算子​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#指派運算子","content":"功能\t範例\t等值寫法\t類別+=\tx += 100\tx = x + 100\t二元 -=\tx -= 100\tx = x - 100\t二元 *=\tx *= 100\tx = x * 100\t二元 /=\tx /= 100\tx = x / 100\t二元 %=\tx %= 100\tx = x % 100\t二元 ","version":"Next","tagName":"h3"},{"title":"範例:來試試看加法指派運算子 +=​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#範例來試試看加法指派運算子-","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //加法指派運算子 += (整數版) Console.WriteLine(&quot;--整數版--&quot;); int x = 10; x += 100; Console.WriteLine(x); //加法指派運算子 += (字串版) Console.WriteLine(&quot;--字串版--&quot;); string name = &quot;孤獨一隻雞&quot;; name += &quot; 史上最帥!&quot;; Console.WriteLine(name); Console.ReadKey(); } } }  結果: --整數版-- 110 --字串版-- 孤獨一隻雞 史上最帥! ","version":"Next","tagName":"h3"},{"title":"優先等級​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#優先等級","content":"小時候學數學時，常常會說先乘除後加減，但這麼多運算子中到底優先順序是什麼呢?雖然有優先順序這東西，但實際上程式撰寫時，還是建議各位搭配()做使用，這樣能增加程式的可讀性 ","version":"Next","tagName":"h3"},{"title":"當大家學會這些運算之後呢?就可以試著去練習做一些簡易的加減乘除啦​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#當大家學會這些運算之後呢就可以試著去練習做一些簡易的加減乘除啦","content":"","version":"Next","tagName":"h3"},{"title":"那我們今天的運算子故事就到這邊了，大家明天見​","type":1,"pageTitle":"🤖 讓變數學會七十二變的高手~運算子","url":"/en/docs/ironMan13/day5#那我們今天的運算子故事就到這邊了大家明天見","content":"","version":"Next","tagName":"h3"},{"title":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day6","content":"","keywords":"","version":"Next"},{"title":"比較運算子​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#比較運算子","content":"隨便兩個數字抓來都是可以做比較的，C#的世界也不例外 運算子\t用途\t類別&lt;\t小於\t二元 &gt;\t大於\t二元 &lt;=\t小於等於\t二元 &gt;=\t大於等於\t二元 ==\t等於\t二元 !=\t不等於\t二元 注意! 各位千萬不要把 &quot; == &quot; 與 &quot; = &quot;搞混了，前者是比較，後者是賦值 ","version":"Next","tagName":"h2"},{"title":"邏輯表達式​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#邏輯表達式","content":"搭配著比較運算子，我們可以列出邏輯表達式如果答案是正確的我們稱之為&quot;真(true)&quot;反之答案是不正確的我們稱之為&quot;假(false)&quot; 邏輯表達式\t結果1 &lt; 2\t真 3 &gt; 2\t真 4 == 5\t假 (6 / 2) != 3\t假 ","version":"Next","tagName":"h3"},{"title":"範例:我們來驗證上面的例子​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#範例我們來驗證上面的例子","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //直接印出結果 Console.WriteLine(1 &lt; 2); Console.WriteLine(3 &gt; 2); Console.WriteLine(4 == 5); Console.WriteLine((6 / 2) != 3); Console.ReadKey(); } } }  結果: True True False False ","version":"Next","tagName":"h3"},{"title":"邏輯運算子​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#邏輯運算子","content":"裡頭包含了: &amp;&amp; 且 (and)|| 或 (or)! 非 (not) ","version":"Next","tagName":"h3"},{"title":"1. && 且 (and) :兩者條件都要滿足​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#1--且-and-兩者條件都要滿足","content":"P\tQ\tP and Qtrue\ttrue\ttrue true\tfalse\tfalse false\ttrue\tfalse false\tfalse\tfalse ","version":"Next","tagName":"h3"},{"title":"我們來看看電路圖，必須兩個開關都導通，才會通電​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#我們來看看電路圖必須兩個開關都導通才會通電","content":" ","version":"Next","tagName":"h3"},{"title":"範例:x 是大於 10 的偶數​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#範例x-是大於-10-的偶數","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告x為12 int x = 12; //x要大於10，因為是偶數所以可以被2整除 Console.WriteLine((x &gt; 10) &amp;&amp; (x % 2 == 0)); Console.ReadKey(); } } }  結果: True ","version":"Next","tagName":"h3"},{"title":"2. || 或 (or):其中之一滿足則成立​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#2--或-or其中之一滿足則成立","content":"P\tQ\tP and Qtrue\ttrue\ttrue true\tfalse\ttrue false\ttrue\ttrue false\tfalse\tfalse ","version":"Next","tagName":"h3"},{"title":"我們來看看電路圖，只要有一個開關都導通，就會通電​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#我們來看看電路圖只要有一個開關都導通就會通電","content":" ","version":"Next","tagName":"h3"},{"title":"範例:x 是負數或是 x 是 3 的倍數​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#範例x-是負數或是-x-是-3-的倍數","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告x為12 int x = 12; //x是正數，但x是三的倍數 Console.Write(&quot;x = &quot; + x+&quot; , &quot;); Console.WriteLine((x &lt; 10) || (x % 3 == 0)); //x是負數，但x不是三的倍數 x = -10; Console.Write(&quot;x = &quot; + x + &quot; , &quot;); Console.WriteLine((x &lt; 10) || (x % 3 == 0)); //x是正數，也x不是三的倍數 x = 10; Console.Write(&quot;x = &quot; + x + &quot; , &quot;); Console.WriteLine((x &lt; 10) || (x % 3 == 0)); Console.ReadKey(); } } }  結果: x = 12 , True x = -10 , True x = 10 , False ","version":"Next","tagName":"h3"},{"title":"4. ! 非 (not):與事實相反​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#4--非-not與事實相反","content":"如果 1 不等於 2，我們就 1 != 2 也可以使用 !(1 == 2) 表示 ","version":"Next","tagName":"h3"},{"title":"布林變數~bool​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#布林變數bool","content":"布林變數也是 C#變數成員的一種型別，他的種族代號是bool他的值只會有兩種，不是真就是假，從來不騙人 ","version":"Next","tagName":"h3"},{"title":"範例:我們輸入一個整數，讓電腦來告訴我們它是不是偶數​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#範例我們輸入一個整數讓電腦來告訴我們它是不是偶數","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個布林變數 bool isEven; Console.WriteLine(&quot;來輸入一個整數吧!&quot;); int x = Convert.ToInt32(Console.ReadLine()); //判斷是不是偶數 isEven = (x % 2) == 0; //列印結果 Console.Write(&quot;請問神奇一隻雞，&quot; + x + &quot;是偶數嗎 ? &quot;); Console.WriteLine(isEven); Console.ReadKey(); } } }  輸入: 10 結果: 來輸入一個整數吧! 10 請問神奇一隻雞，10 是偶數嗎 ? True 輸入: 11 結果: 來輸入一個整數吧! 1 請問神奇一隻雞，1 是偶數嗎 ? False ","version":"Next","tagName":"h3"},{"title":"就說電腦不會騙人吧，對就對，不對就不對，我們現在已經可以讓電腦算數學，也讓電腦擁有明辨是非的能力了，請大家期待之後的文章，電腦會越來越聰明的​","type":1,"pageTitle":"🤖 程式碼擁有判斷真假的能力~邏輯運算子","url":"/en/docs/ironMan13/day6#就說電腦不會騙人吧對就對不對就不對我們現在已經可以讓電腦算數學也讓電腦擁有明辨是非的能力了請大家期待之後的文章電腦會越來越聰明的","content":"","version":"Next","tagName":"h3"},{"title":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day7","content":"","keywords":"","version":"Next"},{"title":"if 陳述式​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#if-陳述式","content":"在日常對話中，我們常常說，如果...就...如果下雨，就待在家在 C#的表達方式則是，if....else...它的樣子會是 if ( 條件 )\\ {\\ ..............\\ }\\ else\\ {\\ ...............\\ } ","version":"Next","tagName":"h2"},{"title":"範例 1:如果下雨，那就待在家，沒下雨就出去玩​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#範例-1如果下雨那就待在家沒下雨就出去玩","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告天氣 string weather = &quot;下雨&quot;; Console.WriteLine(&quot;今天天氣 : &quot; + weather); //使用if陳述句來做判斷 if(weather == &quot;下雨&quot;) { Console.WriteLine(&quot;待在家&quot;); } else { Console.WriteLine(&quot;出去玩&quot;); } //把天氣改成晴天，再做一次判斷試試看 weather = &quot;晴天&quot;; Console.WriteLine(&quot;今天天氣 : &quot; + weather); //使用if陳述句來做判斷 if (weather == &quot;下雨&quot;) { Console.WriteLine(&quot;待在家&quot;); } else { Console.WriteLine(&quot;出去玩&quot;); } Console.ReadKey(); } } }  結果: 今天天氣 : 下雨 待在家 今天天氣 : 晴天 出去玩 ","version":"Next","tagName":"h3"},{"title":"判斷數字的大小​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#判斷數字的大小","content":"","version":"Next","tagName":"h3"},{"title":"範例:招牌上面寫說未成年請勿進入，那我們來做一個輸入年齡，讓電腦判斷能不能進入吧​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#範例招牌上面寫說未成年請勿進入那我們來做一個輸入年齡讓電腦判斷能不能進入吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Console.WriteLine(&quot;請輸入年齡&quot;); //宣告年齡，並將輸入的值賦予給他 int age = Convert.ToInt32(Console.ReadLine()); //判斷年齡 if(age &lt; 18) { Console.WriteLine(age + &quot; 歲是未成年，不可進入!&quot;); } else { Console.WriteLine(age + &quot; 歲已成年，歡迎光臨!&quot;); } Console.ReadKey(); } } }  輸入: 48 結果: 請輸入年齡 48 48 歲已成年，歡迎光臨! 輸入: 15 結果: 請輸入年齡 15 15 歲是未成年，不可進入! ","version":"Next","tagName":"h3"},{"title":"else if​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#else-if","content":"如果有多個要判斷的條件我們可以搭配else if做使用 ","version":"Next","tagName":"h3"},{"title":"範例:如果我滿 18 歲就可以考機車駕照，但要滿 20 歲才能考重機駕照​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#範例如果我滿-18-歲就可以考機車駕照但要滿-20-歲才能考重機駕照","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Console.WriteLine(&quot;請輸入年齡&quot;); //宣告年齡，並將輸入的值賦予給他 int age = Convert.ToInt32(Console.ReadLine()); //判斷年齡 if (age &lt; 18) { Console.WriteLine(age + &quot; 歲是未成年，任何駕照都不能考!&quot;); } else if (age &lt; 20) { Console.WriteLine(age + &quot; 歲，可以考機車駕照，但不能考重機駕照!&quot;); } else { Console.WriteLine(age + &quot; 歲，任何駕照都可以考!&quot;); } Console.ReadKey(); } } }  輸入: 15 結果: 請輸入年齡 15 15 歲是未成年，任何駕照都不能考! 輸入: 19 結果: 請輸入年齡 19 19 歲，可以考機車駕照，但不能考重機駕照! 輸入: 48 結果: 請輸入年齡 48 48 歲，任何駕照都可以考! ","version":"Next","tagName":"h3"},{"title":"巢狀 if​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#巢狀-if","content":"我們可能會先第一個決定，之後再做第二個決定 ","version":"Next","tagName":"h3"},{"title":"範例:如果是假日我就要出去玩，平日就得乖乖上課，如果晴天我就要去海邊，不然就去爬山​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#範例如果是假日我就要出去玩平日就得乖乖上課如果晴天我就要去海邊不然就去爬山","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //今天 Console.WriteLine(&quot;今天星期幾?&quot;); string today = Console.ReadLine(); //天氣 Console.WriteLine(&quot;今天天氣?&quot;); string weather = Console.ReadLine(); //先判斷今天日是不是假日 if (today == &quot;星期六&quot; || today == &quot;星期日&quot;) { if(weather == &quot;晴天&quot;) { Console.WriteLine(&quot;今天&quot; + today + &quot;，&quot; + weather + &quot;,來去海邊玩&quot;); } else { Console.WriteLine(&quot;今天&quot; + today + &quot;，&quot; + weather + &quot;,來去爬山&quot;); } } else { Console.WriteLine(&quot;今天&quot; + today + &quot;，所以要上課&quot;); } Console.ReadKey(); } } }  輸入: 星期六 晴天 結果: 今天星期幾? 星期六 今天天氣? 晴天 今天星期六，晴天,來去海邊玩 輸入: 星期日 陰天 結果: 今天星期幾? 星期日 今天天氣? 陰天 今天星期日，陰天,來去爬山 輸入: 星期一 陰天 結果: 今天星期幾? 星期一 今天天氣? 陰天 今天星期一，所以要上課 ","version":"Next","tagName":"h3"},{"title":"自從學會 if 之後再也沒有選擇障礙了，今天的故事就到這邊了，謝謝大家，我們明天再見​","type":1,"pageTitle":"🤖 你有選擇障礙嗎? 交給if陳述式解決吧","url":"/en/docs/ironMan13/day7#自從學會-if-之後再也沒有選擇障礙了今天的故事就到這邊了謝謝大家我們明天再見","content":"","version":"Next","tagName":"h3"},{"title":"🤖 如果沒有如果，只有太多的如果switch陳述式","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day8","content":"","keywords":"","version":"Next"},{"title":"Switch 陳述式​","type":1,"pageTitle":"🤖 如果沒有如果，只有太多的如果switch陳述式","url":"/en/docs/ironMan13/day8#switch-陳述式","content":"單憑 if..else..只能處理一個條件，但 Switch 是專門用來處理多分支的語句Switch語句中的測試量可以是一個變數，也可以是一個表達式。程式一一測試case分支中的值，測試匹配到哪個分支中的值，就執行哪個分支中的語句。 每個分支都已break語句結束，敘述句一旦遇到break，就會結束整個語句。 ","version":"Next","tagName":"h2"},{"title":"範例:來玩玩我們小時候的猴子繞口令吧​","type":1,"pageTitle":"🤖 如果沒有如果，只有太多的如果switch陳述式","url":"/en/docs/ironMan13/day8#範例來玩玩我們小時候的猴子繞口令吧","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //禮拜幾 string week = Console.ReadLine(); //使用switch switch (week) { case &quot;星期一&quot;: Console.WriteLine(&quot;猴子穿新衣&quot;); break; case &quot;星期二&quot;: Console.WriteLine(&quot;猴子肚子餓&quot;); break; case &quot;星期三&quot;: Console.WriteLine(&quot;猴子去爬山&quot;); break; case &quot;星期四&quot;: Console.WriteLine(&quot;猴子去考試&quot;); break; case &quot;星期五&quot;: Console.WriteLine(&quot;猴子去跳舞&quot;); break; case &quot;星期六&quot;: Console.WriteLine(&quot;猴子去斗六&quot;); break; case &quot;星期日&quot;: Console.WriteLine(&quot;猴子過生日&quot;); break; } Console.ReadKey(); } } }  輸入: 星期一 結果: 星期一 猴子穿新衣 輸入: 星期二 結果: 星期二 猴子肚子餓 ","version":"Next","tagName":"h3"},{"title":"隨堂小練習​","type":1,"pageTitle":"🤖 如果沒有如果，只有太多的如果switch陳述式","url":"/en/docs/ironMan13/day8#隨堂小練習","content":"還記的基姆拉爾森計算公式嗎?我們今天來用 switch 實現吧這過程程式可能會複雜點，屬於比較進階的公式，有興趣的朋友在研究就可以了 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { Console.WriteLine(&quot;請輸入年月日&quot;); int y = Convert.ToInt32(Console.ReadLine()); int m = Convert.ToInt32(Console.ReadLine()); int d = Convert.ToInt32(Console.ReadLine()); int total = 365; //平年 if ((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0) total = 366; switch (m) { case 1: total -= 31; goto case 2; case 2: if ((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0) //閏年 { total -= 29; } else { total -= 28; } goto case 3; case 3: total -= 31; goto case 4; case 4: total -= 30; goto case 5; case 5: total -= 31; goto case 6; case 6: total -= 30; goto case 7; case 7: total -= 31; goto case 8; case 8: total -= 31; goto case 9; case 9: total -= 30; goto case 10; case 10: total -= 31; goto case 11; case 11: total -= 30; goto case 12; case 12: total -= 31; goto default; default: total += d; break; } Console.WriteLine(m+&quot;月&quot;+d+&quot;日是&quot;+y+&quot;年的第&quot;+ total + &quot;天&quot;); Console.ReadKey(); } } }  輸入 2021 09 09 結果: 請輸入年月日 2021 09 09 9 月 9 日是 2021 年的第 252 天 go to 可以指定要去的條件，如果一個條件之下要跑好幾個分支就可以拿來做使用在switch中的else，寫作default ","version":"Next","tagName":"h3"},{"title":"一千個如果...就...，只要一個 switch 就能把程式碼排的整整齊齊的了，好啦大家明天見喽​","type":1,"pageTitle":"🤖 如果沒有如果，只有太多的如果switch陳述式","url":"/en/docs/ironMan13/day8#一千個如果就只要一個-switch-就能把程式碼排的整整齊齊的了好啦大家明天見喽","content":"","version":"Next","tagName":"h3"},{"title":"🤖 省去重複程式碼的好幫手~for迴圈","type":0,"sectionRef":"#","url":"/en/docs/ironMan13/day9","content":"","keywords":"","version":"Next"},{"title":"for 迴圈​","type":1,"pageTitle":"🤖 省去重複程式碼的好幫手~for迴圈","url":"/en/docs/ironMan13/day9#for-迴圈","content":"在 for 迴圈中，我們需要宣告一個初始值再來是宣告條件什麼時候該停下來以下是 for 迴圈的結構 ","version":"Next","tagName":"h2"},{"title":"範例:我們來練習 1+2+3+...+100​","type":1,"pageTitle":"🤖 省去重複程式碼的好幫手~for迴圈","url":"/en/docs/ironMan13/day9#範例我們來練習-123100","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //宣告一個整數，來讓他自增 int sum = 0; //開始使用for迴圈 for (int i = 1; i &lt;= 100; i++) { sum += i;//使用指派運算子 } //看結果 Console.WriteLine(sum); Console.ReadKey(); } } }  結果: 5050 ","version":"Next","tagName":"h3"},{"title":"隨堂小練習​","type":1,"pageTitle":"🤖 省去重複程式碼的好幫手~for迴圈","url":"/en/docs/ironMan13/day9#隨堂小練習","content":"","version":"Next","tagName":"h3"},{"title":"範例:我們來用 for 迴圈實現數學公式的階乘，n!=1 X 2 X.....Xn​","type":1,"pageTitle":"🤖 省去重複程式碼的好幫手~for迴圈","url":"/en/docs/ironMan13/day9#範例我們來用-for-迴圈實現數學公式的階乘n1-x-2-xxn","content":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace CsharpDemo { class Program { static void Main(string[] args) { //讀取用戶輸入的數字 int n = Convert.ToInt32(Console.ReadLine()); //宣告一個長整數變數 long a = 1; for (int i = 1; i &lt;= n; i++) { //做乘法的累計 a *= i; } Console.WriteLine(n + &quot;! = &quot; + a); Console.ReadKey(); } } }  輸入: 20 結果: 20 20! = 2432902008176640000 ","version":"Next","tagName":"h3"},{"title":"以上就是我們今天的 for 迴圈，匯了迴圈之後可以大大的降低程式的重複性，我們就明天再見啦​","type":1,"pageTitle":"🤖 省去重複程式碼的好幫手~for迴圈","url":"/en/docs/ironMan13/day9#以上就是我們今天的-for-迴圈匯了迴圈之後可以大大的降低程式的重複性我們就明天再見啦","content":"","version":"Next","tagName":"h3"},{"title":"🌤️ Spring Cloud 簡介","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_1springCloudOverView","content":"","keywords":"","version":"Next"},{"title":"關於​","type":1,"pageTitle":"🌤️ Spring Cloud 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_1springCloudOverView#關於","content":"Spring Cloud 是基於 Spring Boot 實現的微服務架構開發工具 它簡化了微服務架構中的各種操作，包括： 配置管理：幫助管理微服務的配置設定服務治理：支援管理和監控微服務的運行狀態斷路器：提供容錯機制，防止單一服務故障影響整體系統智能路由：根據需求動態調整流量路由，優化性能微代理：處理微服務間的請求轉發與通訊控制總線：建立微服務之間的通信橋樑全域鎖：管理分佈式環境下的資源訪問決策競選：支援分佈式系統中的決策和選舉過程分佈式會話：管理不同微服務間的用戶會話狀態集群狀態管理：監控和管理微服務集群的運行狀態 總之 Spring Cloud 簡化了微服務架構開發，提供了易於使用的方式來處理配置、監控、容錯等關鍵操作，從而幫助開發者更輕鬆地構建和管理微服務系統 ","version":"Next","tagName":"h2"},{"title":"Spring Cloud 子項目​","type":1,"pageTitle":"🌤️ Spring Cloud 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_1springCloudOverView#spring-cloud-子項目","content":"Spring Cloud Config: 配置管理工具，支持使用Git存儲配置內容，實現應用配置外部化存儲，並支持客戶端配置信息刷新、加密／解密配置內容等Spring Cloud Netflix: 核心組件，整合多個Netflix OSS開源套件 Eureka: 服務治理組件，包含服務註冊中心、服務註冊與發現機制的實現Hystrix: 容錯管理組件，實現斷路器模式，幫助處理服務依賴中的延遲和故障，提供強大的容錯能力Ribbon: 客戶端負載均衡的服務調用組件Feign: 基於Ribbon和Hystrix的聲明式服務調用組件Zuul: 網關組件，提供智能路由、訪問過濾等功能 Spring Cloud Bus: 事件、消息總線，用於在集群中傳播狀態變化或事件，觸發後續處理，如動態刷新配置等Spring Cloud Cluster: 针對ZooKeeper、Redis、Hazelcast、Consul的選舉算法和通用狀態模式的實現Spring Cloud Cloudfoundry: 與Pivotal Cloudfoundry的整合支持Spring Cloud Consul: 服務發現與配置管理工具Spring Cloud Stream: 通過Redis、Rabbit或Kafka實現的消費微服務，可通過簡單的聲明式模型發送和接收消息Spring Cloud AWS: 簡化整合Amazon Web Service的組件Spring Cloud Security: 安全工具包，提供在Zuul代理中對OAuth2客戶端請求的中繼器Spring Cloud Sleuth: Spring Cloud應用的分佈式跟蹤實現，可以完美整合ZipkinSpring Cloud ZooKeeper: 基於ZooKeeper的服務發現與配置管理組件Spring Cloud Starters: Spring Cloud的基礎組件，基於Spring Boot風格項目的基礎依賴模組Spring Cloud CLI: 用於在Groovy中快速創建Spring Cloud應用的Spring Boot CLI插件 ","version":"Next","tagName":"h2"},{"title":"🌤️ Spring Boot 簡介","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview","content":"","keywords":"","version":"Next"},{"title":"關於​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#關於","content":"Spring Cloud 是基於 Spring Boot 延伸出來的微服務架構 ","version":"Next","tagName":"h2"},{"title":"Spring 框架的問題與 Spring Boot 的優勢​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#spring-框架的問題與-spring-boot-的優勢","content":"","version":"Next","tagName":"h2"},{"title":"Spring 框架對初學者和老手的問題​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#spring-框架對初學者和老手的問題","content":"初學者因繁雜的設定而望而卻步老手每次新建專案都需要重複複製貼上一些相似的設定 ","version":"Next","tagName":"h3"},{"title":"解決問題的方法​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#解決問題的方法","content":"利用建構工具（如 Maven）建立腳手架專案，初始化標準專案，簡化設定流程 ","version":"Next","tagName":"h3"},{"title":"Spring Boot的優勢​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#spring-boot的優勢","content":"自動化設定簡化樣板化設定Starter POMs 集成功能，簡化依賴管理支援內嵌的 Tomcat、Jetty 等容器，輕鬆建構與部署適合容器化，可整合 Docker ","version":"Next","tagName":"h3"},{"title":"開發優勢​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#開發優勢","content":"使用 Groovy、Gradle 等工具開發 Spring Boot 應用程式簡潔範例：透過編譯、打包、java -jar 命令啟動 RESTful API Spring Boot 的出現有效簡化了 Spring 框架的設定與開發，透過自動化設定、Starter POMs、內嵌式容器等特性，使建構、部署和開發流程更加高效輕便 ","version":"Next","tagName":"h3"},{"title":"快速入門​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#快速入門","content":"","version":"Next","tagName":"h2"},{"title":"環境安裝​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#環境安裝","content":"Java 安裝文章連結 ","version":"Next","tagName":"h3"},{"title":"專案建立​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#專案建立","content":"透過 Spring Initializr 來建立專案 選擇 MavenJava選擇 Spring Boot 版本設定命名選擇 jar選擇 Java 版本加入Spring Web 模組最後匯出專案解壓縮專案，並且使用終端機輸入 code .使用 vs code 開啟專案 ","version":"Next","tagName":"h3"},{"title":"專案說明​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#專案說明","content":"整個專案的主程式為 src/main/java/DemoApplication.java package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }  專案的設定檔與靜態資源檔則會放在 src/main/resources 單元測試檔案則會放在 src/test/ Maven 的設定檔則是 pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;   ","version":"Next","tagName":"h3"},{"title":"建立專案範本​","type":1,"pageTitle":"🌤️ Spring Boot 簡介","url":"/en/docs/javaSpringCloud/Chapter2/2_2springBootOverview#建立專案範本","content":"github 連結 ","version":"Next","tagName":"h3"},{"title":"🌤️ 建立 RESTful API","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_3resfulAPI","content":"","keywords":"","version":"Next"},{"title":"實作​","type":1,"pageTitle":"🌤️ 建立 RESTful API","url":"/en/docs/javaSpringCloud/Chapter2/2_3resfulAPI#實作","content":"建立檔案 src/main/java/demoController.java package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class demoController { @RequestMapping(&quot;/Hi&quot;) public String index() { return &quot;Hi Hi&quot;; } }  在瀏覽器輸入以下網址 http://localhost:8080/Hi  結果 Hi Hi  ","version":"Next","tagName":"h2"},{"title":"建立 controller 範本​","type":1,"pageTitle":"🌤️ 建立 RESTful API","url":"/en/docs/javaSpringCloud/Chapter2/2_3resfulAPI#建立-controller-範本","content":"github 連結 ","version":"Next","tagName":"h2"},{"title":"🌤️ 進行單元測試","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_4unitTest","content":"","keywords":"","version":"Next"},{"title":"實作​","type":1,"pageTitle":"🌤️ 進行單元測試","url":"/en/docs/javaSpringCloud/Chapter2/2_4unitTest#實作","content":"建立檔案 src/test/java/demoControllerTest.java package com.example.demo; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; @SpringBootTest @AutoConfigureMockMvc public class demoControllerTest { @Autowired private MockMvc mockMvc; @Test public void testIndexEndpoint() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/Hi&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().string(&quot;Hi Hi&quot;)); } }  ","version":"Next","tagName":"h2"},{"title":"單元測試範本​","type":1,"pageTitle":"🌤️ 進行單元測試","url":"/en/docs/javaSpringCloud/Chapter2/2_4unitTest#單元測試範本","content":"github 連結 ","version":"Next","tagName":"h2"},{"title":"🌤️ Config 設定","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_5config","content":"","keywords":"","version":"Next"},{"title":"Spring Boot vs Spring​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#spring-boot-vs-spring","content":"在 Spring Boot 底下，不需要引入其他設定，只需要引入 Maven ， 雖然與傳統 Spring 一樣，都需要實作 Controller， 但在設定 Spring Boot 都是自動化的設定，除非有其他特殊的場景， 才需要手動設定 (EX: 8080 port 與其他網站衝突時，我們就必須手動修改)， 修改 Port 可參考 此篇 ","version":"Next","tagName":"h2"},{"title":"設定文件​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#設定文件","content":"","version":"Next","tagName":"h2"},{"title":"文件位置​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#文件位置","content":"src/main/resources  ","version":"Next","tagName":"h3"},{"title":"預設設定文件​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#預設設定文件","content":"application.properties  ","version":"Next","tagName":"h3"},{"title":"設定服務名稱​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#設定服務名稱","content":"開啟 src/main/resources/application.properties spring.application.name=hello  ","version":"Next","tagName":"h3"},{"title":"使用 Yaml​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#使用-yaml","content":"spring boot 的設定也可以使用 Yaml 格式以下是 Yaml 與傳統 properties 比較 Yaml environments: dev: url: http://test.com name: Developer Setup prod: url: http://demo.com name: My Demo App  properties environments.dev.url=http://test.com environments.dev.name=Developer Setup environments.prod.url=http://demo.com environments.prod.name=My Demo App  ","version":"Next","tagName":"h3"},{"title":"多環境設定​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#多環境設定","content":"可以根據不同的設定檔，來切換環境 以下設定會籲社會讀取開發環境 application-dev.properties: 開發環境application-test.properties: 測試環境application-prod.properties: 正式環境 如果要執行 jar 並且切換設定時 ex: 測試環境 java -jar [jar name].jar --application-test.properties=test  ","version":"Next","tagName":"h3"},{"title":"關於設定檔的載入順序​","type":1,"pageTitle":"🌤️ Config 設定","url":"/en/docs/javaSpringCloud/Chapter2/2_5config#關於設定檔的載入順序","content":"命令行參數： 首先，您可以通過命令行傳入參數，這些參數會影響配置。 SPRING_APPLICATION_JSON 屬性： 如果您在系統環境變數中以 JSON 格式設定了 SPRING_APPLICATION_JSON 屬性，Spring Boot 將從中讀取設定。 java:comp/env 的 JNDI 屬性： 您可以獲取位於 java:comp/env 環境下的 JNDI 屬性。 Java 系統屬性： 您可以透過 System.getProperties() 方法獲取 Java 系統屬性。 作業系統環境變數： 系統環境變數也可能影響配置設定。 隨機屬性設定： 如果您透過 random.* 設定了隨機屬性，這些設定也會被納入考慮。 外部配置文件（針對特定環境）： 對於特定的 {profile} 環境，您可以在應用 JAR 包外部準備配置文件，例如 app-{profile}.properties 或使用 YAML 格式的文件。 內部配置文件（針對特定環境）： 同樣地，對於特定的 {profile} 環境，您也可以在應用 JAR 包內部設置配置文件，例如 app-{profile}.properties 或使用 YAML 定義的文件。 外部的 application.properties 和 YAML 配置： 若這些配置位於應用 JAR 包的外部。 內部的 application.properties 和 YAML 配置： 若這些配置位於應用 JAR 包的內部。 @Configuration 標記的類中的 @PropertySource 屬性： 在被 @Configuration 標記的類中，您可以透過 @PropertySource 注解定義屬性。 應用默認屬性： 最後，使用 SpringApplication.setDefaultProperties 定義的應用默認屬性。 ","version":"Next","tagName":"h2"},{"title":"🌤️ 監控與管理","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_6monitoring","content":"","keywords":"","version":"Next"},{"title":"瓶頸​","type":1,"pageTitle":"🌤️ 監控與管理","url":"/en/docs/javaSpringCloud/Chapter2/2_6monitoring#瓶頸","content":"在微服務架構中，我們將原本龐大的單體系統拆分成多個提供不同服務的應用，雖然各個應用的內部邏輯因分解而得以簡化，但由於部署應用的數量成倍增長，系統的維護複雜度大大提升 運維人員面臨著應用數量的不斷增多，系統集群中出現故障的頻率也變得越來越高，雖然高可用機制的保護下，個別故障不會影響系統對外服務，但這些頻繁出現的故障需要被及時發現和處理才能長期保證系統處於健康可用狀態 為了能高效運維成倍增長的應用，傳統的運維方式明顯不合適，我們需要建立一套自動化的監控運維機制，其運行基礎是持續收集各個微服務應用的各項指標，然後根據這些基礎指標制定監控和預警規則，甚至實現一些自動化的運維操作 ","version":"Next","tagName":"h2"},{"title":"解決方案​","type":1,"pageTitle":"🌤️ 監控與管理","url":"/en/docs/javaSpringCloud/Chapter2/2_6monitoring#解決方案","content":"","version":"Next","tagName":"h2"},{"title":"選用 Spring Boot 與 Spring Cloud 提供的功能​","type":1,"pageTitle":"🌤️ 監控與管理","url":"/en/docs/javaSpringCloud/Chapter2/2_6monitoring#選用-spring-boot-與-spring-cloud-提供的功能","content":"我們在構建微服務時，選擇使用 Spring Boot 作為微服務框架 除了它強大的快速開發功能之外，還有一個特別的依賴模組 — spring-boot-starter-actuator，該模組能夠自動為 Spring Boot 應用提供一系列用於監控的端點， 同時在實現各個微服務組件時，Spring Cloud 對該模組進行了擴展，為原生端點增加了更多的指標和度量信息，例如: 在整合 Eureka 時，會為 /health 端點增加相關信息。對於不同的組件，還提供了更多有用的端點，比如 API 網關組件 Zuul 提供了 /routes 端點來返回路由信息 ","version":"Next","tagName":"h3"},{"title":"spring-boot-starter-actuator 的優勢​","type":1,"pageTitle":"🌤️ 監控與管理","url":"/en/docs/javaSpringCloud/Chapter2/2_6monitoring#spring-boot-starter-actuator-的優勢","content":"對於中小團隊來說，spring-boot-starter-actuator 模組的實現能夠顯著減少監控系統在采集應用指標時的開發工作量， 儘管它功能強大，並非萬能的，有時候我們可能需要對其進行一些簡單的擴展，以滿足系統個性化的監控需求 ","version":"Next","tagName":"h3"},{"title":"🌤️ Spring boot actuator","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_7actuator","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🌤️ Spring boot actuator","url":"/en/docs/javaSpringCloud/Chapter2/2_7actuator#說明","content":"Spring Boot 有提供一個模組 spring-boot－starter-actuator ， 他可以大幅的節省，開發監控系統的時間 ","version":"Next","tagName":"h2"},{"title":"實作​","type":1,"pageTitle":"🌤️ Spring boot actuator","url":"/en/docs/javaSpringCloud/Chapter2/2_7actuator#實作","content":"","version":"Next","tagName":"h2"},{"title":"導入模組​","type":1,"pageTitle":"🌤️ Spring boot actuator","url":"/en/docs/javaSpringCloud/Chapter2/2_7actuator#導入模組","content":"於 pom.xml 導入此模組 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;  ","version":"Next","tagName":"h3"},{"title":"啟動程式​","type":1,"pageTitle":"🌤️ Spring boot actuator","url":"/en/docs/javaSpringCloud/Chapter2/2_7actuator#啟動程式","content":"在網址列輸入 http://localhost:8080/actuator/health可以看到 { &quot;status&quot;: &quot;UP&quot; }   ","version":"Next","tagName":"h3"},{"title":"actuator 範本​","type":1,"pageTitle":"🌤️ Spring boot actuator","url":"/en/docs/javaSpringCloud/Chapter2/2_7actuator#actuator-範本","content":"github 連結 ","version":"Next","tagName":"h2"},{"title":"🌤️ 原生端點","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#說明","content":"根據端點的用途，我們將這些原生端點分為以下三大類： ","version":"Next","tagName":"h2"},{"title":"應用設定類​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#應用設定類","content":"取得應用程式載入的設定、環境變數、自動設定報告等，這些與 Spring Boot 應用程式緊密相關的設定資訊 ","version":"Next","tagName":"h3"},{"title":"監控指標類​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#監控指標類","content":"取得應用程式執行過程中用於監控的度量指標，例如: 記憶體資訊、執行緒池資訊、HTTP 請求統計等 ","version":"Next","tagName":"h3"},{"title":"操作控制類​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#操作控制類","content":"提供應用程式的關閉等操作功能 ","version":"Next","tagName":"h3"},{"title":"關於應用設定類​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#關於應用設定類","content":"","version":"Next","tagName":"h2"},{"title":"應用設定類說明​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#應用設定類說明","content":"傳統的 Spring 應用設定有時候相當繁瑣，要寫很多 XML 檔案 Spring Boot 為了簡化這一步驟，引入了自動掃描和自動設定的方式，讓我們不用寫太多設定檔，代碼看起來比較簡潔 但是這種做法可能會導致我們的應用實例和相依性被分散到各個設定類的註解上，這使得分析整個應用中的資源和實例關係變得有點困難 不過有些端點可以幫助我們輕鬆獲取有關 Spring 應用設定的詳細報告，包括自動設定的報告、Bean 的建立報告和環境屬性報告等 ","version":"Next","tagName":"h3"},{"title":"應用設定相關的端點資訊​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#應用設定相關的端點資訊","content":"端點\t用途/configprops\t提供應用程式的配置屬性及其來源的詳細資訊 /env\t查看應用程式的環境屬性，包括系統屬性、環境變數和配置屬性 /beans\t顯示應用程式中所有可用的 Spring Bean 資訊 /info\t提供有關應用程式的自訂資訊，可以根據需要進行配置 /mappings\t顯示應用程式中的所有 URL 對應，包括控制器對應和靜態資源對應 /conditions\t顯示自動設定條件以及其是否符合的詳細資訊 ","version":"Next","tagName":"h3"},{"title":"關於監控指標類​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#關於監控指標類","content":"","version":"Next","tagName":"h2"},{"title":"監控指標類說明​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#監控指標類說明","content":"應用設定類的端點給予固定報告，但計量指標類的端點則是給動態變動的執行時資訊，有助於打造微服務監控系統 ","version":"Next","tagName":"h3"},{"title":"監控指標相關的端點資訊​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#監控指標相關的端點資訊","content":"端點\t用途/metrics\t提供有關應用程式執行時的各種度量指標資訊，例如記憶體使用、HTTP 請求統計等 /health\t顯示應用程式的健康狀態，可用於監控系統的運作情況 /threaddump\t顯示有關執行緒的資訊，可用於分析應用程式的併發狀況 /\t主要的端點路徑，可以查看所有可用的監控和管理端點 ","version":"Next","tagName":"h3"},{"title":"關於操作控制類​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#關於操作控制類","content":"","version":"Next","tagName":"h2"},{"title":"操作控制類說明​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#操作控制類說明","content":"操作控制類端點提供了操作應用程式的方式，使您能夠執行各種管理任務和調整應用程式的執行時行為 ","version":"Next","tagName":"h3"},{"title":"操作控制相關的端點資訊​","type":1,"pageTitle":"🌤️ 原生端點","url":"/en/docs/javaSpringCloud/Chapter2/2_8actuatorSetting#操作控制相關的端點資訊","content":"端點\t用途/shutdown\t允許從遠程關閉應用程式，需進行適當的安全性配置 /restart\t允許從遠程重新啟動應用程式，同樣需要進行適當的安全性配置 /pause\t暫停接受流量，用於進行維護工作，需要安全性保護 /resume\t恢復接受流量，取消暫停狀態，同樣需要進行適當的安全性配置 ","version":"Next","tagName":"h3"},{"title":"🌧️ Spring Cloud Eureka","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter3/3_1eureka","content":"","keywords":"","version":"Next"},{"title":"關於 Eureka​","type":1,"pageTitle":"🌧️ Spring Cloud Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_1eureka#關於-eureka","content":"Spring Cloud Eureka 是 Spring Cloud Netflix 的其中一個套件他是 based on Netflix Eureka 進行第二次封裝可以透過他，來對 spring boot 進行自動化的設定 ","version":"Next","tagName":"h2"},{"title":"服務管理​","type":1,"pageTitle":"🌧️ Spring Cloud Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_1eureka#服務管理","content":"服務管理是微服務中，最核心的一塊 最初可能服務不多，還可以手動去設定，隨著系統越來越龐大， 服務不斷增加手動設定靜態資源會變得難以維護，造成大量的人力消耗 ","version":"Next","tagName":"h2"},{"title":"服務註冊​","type":1,"pageTitle":"🌧️ Spring Cloud Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_1eureka#服務註冊","content":"在微服務的架構中，通常會有一個註冊中心， 讓每個服務去註冊他提供的服務，並且註冊一些相關訊息， 例如: 版本號、主機與 port 、通訊協議等 ","version":"Next","tagName":"h3"},{"title":"服務發現​","type":1,"pageTitle":"🌧️ Spring Cloud Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_1eureka#服務發現","content":"在整個微服務的框架之下，服務之間就不需要知道對方的具體位置， 當他需要使用服務時，會透過服務中心來詢問，其他服務的相關資訊 ","version":"Next","tagName":"h3"},{"title":"🌧️ Netflix Eureka","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/Chapter3/3_2netflixEureka","content":"","keywords":"","version":"Next"},{"title":"Spring Cloud Eureka​","type":1,"pageTitle":"🌧️ Netflix Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_2netflixEureka#spring-cloud-eureka","content":"如果使用 Netflix Eureka ，它包含了伺服端與客戶端的模組， 並且客戶端與伺服端都是以 java 撰寫的， 因此 Eureka 適用於 java 的分散式系統或是相容 JVM 語言的系統 ","version":"Next","tagName":"h2"},{"title":"使用 Eureka 管理​","type":1,"pageTitle":"🌧️ Netflix Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_2netflixEureka#使用-eureka-管理","content":"Eureka 提供完整的 RESTful API，這意味著即使是用其他語言編寫的服務也可以與 Eureka 進行交互 這種語言無關性使得 Eureka 更加靈活和廣泛適用， 對於非 Java 平台，需要開發或使用特定語言的 Eureka 客戶端，對於一些流行的語言， 如 .NET 和 Node.js，已經有現成的客戶端框架，例如: Dotnet 的 Steeltoe 和 Node.js 的 eureka-js-client 就是這樣的解決方案 ","version":"Next","tagName":"h2"},{"title":"Eureka 伺服端（服務註冊中心）​","type":1,"pageTitle":"🌧️ Netflix Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_2netflixEureka#eureka-伺服端服務註冊中心","content":"可稱之為 服務註冊中心 所有微服務都在此註冊自己，以便於被發現和呼叫 支援高度可用的設定 可應對不同的故障 (ex: 當整個服務群集有某個分片故障時，會自動轉入保護模式) ","version":"Next","tagName":"h2"},{"title":"Eureka 客戶端​","type":1,"pageTitle":"🌧️ Netflix Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_2netflixEureka#eureka-客戶端","content":"主要處理註冊與發現 它將服務資訊註冊到 Eureka 伺服端，並從伺服端查詢其他服務的資訊 透過註解或是參數設定嵌入應用的程式碼中 程式運作時，Eureka 客戶端會主動發送生存確認給伺服端 ","version":"Next","tagName":"h2"},{"title":"註冊與通訊​","type":1,"pageTitle":"🌧️ Netflix Eureka","url":"/en/docs/javaSpringCloud/Chapter3/3_2netflixEureka#註冊與通訊","content":"微服務 A、B、C 代表使用 Eureka 客戶端的不同微服務它們各自向 Eureka 伺服端（服務註冊中心）註冊自己一旦註冊，這些微服務可以透過 Eureka 伺服端進行服務發現，意味著它們可以找到彼此並進行相互通訊Eureka 伺服端維護著所有註冊服務的列表，並在需要時提供這些資訊給客戶端微服務之間的通訊是直接的，但是它們的發現和註冊是透過 Eureka 伺服端完成的 ","version":"Next","tagName":"h2"},{"title":"🌧️ 微服務是什麼","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_1whatIsMicroservices","content":"","keywords":"","version":"Next"},{"title":"名詞解釋​","type":1,"pageTitle":"🌧️ 微服務是什麼","url":"/en/docs/javaSpringCloud/ChapterI/1_1whatIsMicroservices#名詞解釋","content":"","version":"Next","tagName":"h2"},{"title":"微服務 (Microservices)​","type":1,"pageTitle":"🌧️ 微服務是什麼","url":"/en/docs/javaSpringCloud/ChapterI/1_1whatIsMicroservices#微服務-microservices","content":"是一種系統架構的設計風格將原本一個獨立的系統拆分為多個小型的服務每個服務都在獨立的 Process 中運行 ","version":"Next","tagName":"h3"},{"title":"服務之間的溝通​","type":1,"pageTitle":"🌧️ 微服務是什麼","url":"/en/docs/javaSpringCloud/ChapterI/1_1whatIsMicroservices#服務之間的溝通","content":"在每個服務之間的溝通方式大致可以分為三類 RCPEvent streamingMessage brokers ","version":"Next","tagName":"h2"},{"title":"微服務優點​","type":1,"pageTitle":"🌧️ 微服務是什麼","url":"/en/docs/javaSpringCloud/ChapterI/1_1whatIsMicroservices#微服務優點","content":"在每個小型服務被拆開之後，每個服務只需要維護自身的邏輯， 並且擁有了輕量級的通訊，所以這些服務可以各自使用不同語言編寫 ","version":"Next","tagName":"h2"},{"title":"🌧️ 與單體系統的差異","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing","content":"","keywords":"","version":"Next"},{"title":"單體系統​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#單體系統","content":"","version":"Next","tagName":"h2"},{"title":"分為三個部分​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#分為三個部分","content":"Database後端服務前端畫面 ","version":"Next","tagName":"h3"},{"title":"專案發展過程​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#專案發展過程","content":"所有商業邏輯、開發、測試、部屬，都還算方便為了實現各式需求，因此加入了許多商業邏輯模組手機設備不斷進步，前端已經不被侷限於 Web 形式 ","version":"Next","tagName":"h3"},{"title":"中後期結果​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#中後期結果","content":"整個專案變得很肥大 ","version":"Next","tagName":"h3"},{"title":"影響​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#影響","content":"只需要修改一個小功能而已，為了部屬需要中斷其他功能的運作每個功能模組適用的場景、併發量、消耗的資源都不盡相同維護成本會不斷提升，越來越難控制 ","version":"Next","tagName":"h3"},{"title":"微服務​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#微服務","content":"","version":"Next","tagName":"h2"},{"title":"解決的問題​","type":1,"pageTitle":"🌧️ 與單體系統的差異","url":"/en/docs/javaSpringCloud/ChapterI/1_2diffWithSing#解決的問題","content":"系統被拆為多個服務，每個服務都可以獨立部屬與擴充 每個服務都運作在自己的 Process 裡面，所以不會影響到其他服務 由於每個服務都是獨立部屬的，所以可以很精準的評估服務的性能 ","version":"Next","tagName":"h3"},{"title":"🌧️ 如何執行微服務","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo","content":"","keywords":"","version":"Next"},{"title":"微服務延伸的問題​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#微服務延伸的問題","content":"","version":"Next","tagName":"h2"},{"title":"維運的新挑戰​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#維運的新挑戰","content":"維運人員須要維護的 Process 會大量增加， 維運人員需要具備更多技能來應對這樣的挑戰， 並且讓維運過程轉為自動化 ","version":"Next","tagName":"h3"},{"title":"介面的一致性​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#介面的一致性","content":"雖然把服務都獨立化了，但商業邏輯之間的依賴還是不變的， 因此在介面上確保他是一致的，並且需要嚴格遵守開閉原則 ","version":"Next","tagName":"h3"},{"title":"分散式的複雜性​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#分散式的複雜性","content":"拆分後的服務都是在各自的 Process 中運作， 他們之間只能靠通訊來進行溝通，因此整個環境中有許多需要考量的因素， 如: 網路延遲、分散式事務、非同步的訊息等 ","version":"Next","tagName":"h3"},{"title":"服務模組化​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#服務模組化","content":"","version":"Next","tagName":"h2"},{"title":"模組化的好處​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#模組化的好處","content":"模組化這件事情可以將程式變成一個獨立的元件來運作， 就如同汽車的輪胎、懸吊等，只要符合規格都可以任意改裝， 如果想要行駛過程中想要增加過彎的穩定性，就只需要將懸吊進行更換， 而不需要將整台車輛進行汰換 ","version":"Next","tagName":"h3"},{"title":"Smart endpoints and dumb pipes​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#smart-endpoints-and-dumb-pipes","content":"在單體服務中，只需要直接呼叫函式就可直接使用服務， 但在微服務中需要改由 RCP 來呼叫服務，導致每個服務之間會有繁瑣的通訊， 因此需要將通訊協議的粒度提高 ","version":"Next","tagName":"h3"},{"title":"常見的通訊​","type":1,"pageTitle":"🌧️ 如何執行微服務","url":"/en/docs/javaSpringCloud/ChapterI/1_3howToDo#常見的通訊","content":"HTTP 的 RESTful API 或其他輕量級的通訊協議 : 進行訊息傳遞與服務調用訊息佇列 : 如 ActiveMQ、RabbitMQ 等等可靠的非同步中間層 在需要極致性能下，有些團隊會選擇用二進位的訊息發送協議， 例如: protobuf ","version":"Next","tagName":"h3"},{"title":"🌧️ 去中心化","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization","content":"","keywords":"","version":"Next"},{"title":"去中心化管理​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#去中心化管理","content":"","version":"Next","tagName":"h2"},{"title":"問題​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#問題","content":"當使用集中式管理時，通常會定義統一的標準， 但每種技術都會有缺點，當碰到這個問題時， 需要花很大的力氣去解決這問題， 如果沒辦法解決，可能會成為系統的瓶頸 ","version":"Next","tagName":"h3"},{"title":"微服務解決的問題​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#微服務解決的問題","content":"整個微服務的架構都是透過統一的通訊介面進行溝通的， 讓整個服務不會被侷限於某種技術框架，可以針對不同情境的場景， 來選擇適合的服務 ","version":"Next","tagName":"h3"},{"title":"去中心化的資料管理​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#去中心化的資料管理","content":"","version":"Next","tagName":"h2"},{"title":"定義​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#定義","content":"在微服務架構底下，我們會期望每個服務管理各自的資料庫， 這就是去中心化的資料管理 ","version":"Next","tagName":"h3"},{"title":"實際狀況​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#實際狀況","content":"有可能會是將資料庫的表格拆分成好幾個 Database， 也有可能是將資料儲存到其他的儲存技術中，如: 將 log 儲存進 MongoDB、將一些比較即時性的資料儲存在 Redis ","version":"Next","tagName":"h3"},{"title":"注意事項​","type":1,"pageTitle":"🌧️ 去中心化","url":"/en/docs/javaSpringCloud/ChapterI/1_4decentralization#注意事項","content":"雖然去中心化可以讓資料更細緻，而且可以透過技術的選擇，讓整個資料庫性能達到最佳化， 但在這情境下 資料的一致性 是最致命的弱點，所以在微服務的架構中，只要求最後資料是一致的就可， 如果過程中發生錯誤，需要有補償機制來進行處來，讓資料最終可以達到一致性 ","version":"Next","tagName":"h3"},{"title":"🌧️ 自動化","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_5autoDev","content":"","keywords":"","version":"Next"},{"title":"微服務帶來的影響​","type":1,"pageTitle":"🌧️ 自動化","url":"/en/docs/javaSpringCloud/ChapterI/1_5autoDev#微服務帶來的影響","content":"","version":"Next","tagName":"h2"},{"title":"維運的噩夢​","type":1,"pageTitle":"🌧️ 自動化","url":"/en/docs/javaSpringCloud/ChapterI/1_5autoDev#維運的噩夢","content":"雖然容器化與公有雲的技術日漸成熟，所以維運的基礎設施， 日件容易，但是服務越拆分越細，導致維運人員需要注意的事項越來越多， 操作過程也變得複雜許多 ","version":"Next","tagName":"h3"},{"title":"持續交付​","type":1,"pageTitle":"🌧️ 自動化","url":"/en/docs/javaSpringCloud/ChapterI/1_5autoDev#持續交付","content":"微服務應該將 持續交付 當作整個平台構建的宗旨， 並且需要達成兩大內容 自動化測試: 部屬前進行測試，將部屬風險降到最低自動化部屬: 減少複雜環境與操作失誤的機會 ","version":"Next","tagName":"h3"},{"title":"🌧️ 容錯設計","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance","content":"","keywords":"","version":"Next"},{"title":"微服務 VS 單體服務​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#微服務-vs-單體服務","content":"","version":"Next","tagName":"h2"},{"title":"單體服務​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#單體服務","content":"一發生錯誤，就全部服務故障 ","version":"Next","tagName":"h3"},{"title":"微服務​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#微服務","content":"每個服務都跑在獨立的 Process一個服務故障後，其他服務不會受影響 微服務設計錯誤有可能會造成，某個服務故障，導致其他依賴它的服務逐漸癱瘓， 造成故障蔓延，最後導致所有系統癱瘓。 因此在微服務的設計中，應該要可以快速檢測故障的原因，並且自動復歸 ","version":"Next","tagName":"h3"},{"title":"微服務的設計演進​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#微服務的設計演進","content":"","version":"Next","tagName":"h2"},{"title":"微服務架構特點​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#微服務架構特點","content":"需要考慮多方面的設計和成本，對於缺乏經驗的團隊來說，實施完美的微服務架構可能比單體應用更費代價 ","version":"Next","tagName":"h3"},{"title":"漸進式構建​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#漸進式構建","content":"許多情況下，架構師會選擇以漸進的方式建構系統 初期可能採用單體系統設計和實施，因為系統初期較小，成本相對較低，且核心業務通常不會有大改變 ","version":"Next","tagName":"h3"},{"title":"微服務轉換​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#微服務轉換","content":"隨著系統成長和業務需求，架構師會將容易變動或具有時間效應的部分逐步轉換為微服務，進行分散處理， 同時會逐步拆分單體系統中多變的模塊 ","version":"Next","tagName":"h3"},{"title":"核心微服務​","type":1,"pageTitle":"🌧️ 容錯設計","url":"/en/docs/javaSpringCloud/ChapterI/1_6faultTolerance#核心微服務","content":"不易變動的模塊會形成核心微服務，穩定存在於整個架構中，這有助於保持穩定的基礎架構，並支援系統的穩定運作 ","version":"Next","tagName":"h3"},{"title":"🌧️ 12 因子應用程式","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor","content":"","keywords":"","version":"Next"},{"title":"目標​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#目標","content":"標準化流程增加服務的可移植性 (portability)適合部屬到雲平台 (cloud platforms)提高持續部屬的可行性 (continuous deployment)提高系統的擴展性 (scale up) ","version":"Next","tagName":"h2"},{"title":"12 因子​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#12-因子","content":"","version":"Next","tagName":"h2"},{"title":"1. 基礎程式碼 (Codebase)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#1-基礎程式碼-codebase","content":"基礎程式碼 集中式版控指的是系統上的儲存庫 (ex: SVN應該以最後一個版本為主)分散式版控指的是最上游的儲存庫 (ex: 如果 git 上的Repo是fork來的，應該以fork前的為主) (ex: git 應該以雲端最新的版本為主) 基礎程式碼與應用程式的關係: 一份基礎程式碼，對應一個應用程式一份基礎程式碼，對應多個應用程式多份基礎程式碼，是一個分散式系統 基礎程式碼只能有一份，但可以部屬成多個應用程式 ","version":"Next","tagName":"h3"},{"title":"2. 依賴聲明 (Dependencies)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#2-依賴聲明-dependencies","content":"依賴管理工具可能安裝的套件類型: 系統層級全域的依賴 (ex: python fastapi)應用程式專屬使用的 (ex: dotnet log4net) 依賴管理工具做法: (以Python為例) 依賴聲明 (requirements.txt)依賴隔離 (venv)依賴建置 (pip install) ","version":"Next","tagName":"h3"},{"title":"3. 設定(Config)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#3-設定config","content":"因環境差異而有所不同 資料庫設定第三方服務的存取憑證環境特有的設定 (ex: 網域 ) 建議使用環境變數 反例: 程式碼中使用常數使用設定檔 ","version":"Next","tagName":"h3"},{"title":"4. 後端服務(Backing services)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#4-後端服務backing-services","content":"定義 應用程式執行中需要透過網路呼叫的服務資料庫、Queue、SMTP、快取等，內部服務Google API，外部服務 作為應用程式的附加資源，使用URL或是其他形式，存在設定管理 在資料庫出問題時，應該先將備份的資料庫啟動，並修改環境變數中的連線字串，可能會有一些資料落差，但當下可以復歸系統 ","version":"Next","tagName":"h3"},{"title":"5.建置、發布、執行(Build, release, run)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#5建置發布執行build-release-run","content":"定義基礎程式碼轉換為部屬的階段: 建置階段 &gt; 透過編譯器，準備好依賴，打包成一個執行檔…發布階段 &gt; 準備好打包後的程式與設定檔執行階段 &gt; 當程式碼啟動之後產生一個 processes Release 應該使用版號或是一個流水號，好處是可以確定Release後的程式都應該要可以直接在PD環境上執行 ","version":"Next","tagName":"h3"},{"title":"6.程序(Processes)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#6程序processes","content":"一個應用程式通常是由一個或多個程序執行的程序需為無狀態且無共享(應保存在後端服務內) 無狀態 &gt; 前一個請求不應該影響到下一個請求的狀態無共享 &gt; 記憶體中是不會互相影響的 ","version":"Next","tagName":"h3"},{"title":"7.端口綁定(Port binding)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#7端口綁定port-binding","content":"應用程式應該要能夠自行建立網路服務，並透過端口綁定來提供服務 反例: C# 依賴 IIS 、Java 依賴 Tomcat正例: C# 與 ASP.NET Core、 Java 與 Jetty 或 Spring Boot ","version":"Next","tagName":"h3"},{"title":"8.併發(Concurrency)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#8併發concurrency","content":"以PHP為例，在Apache啟動時只會啟動最小Processes，並在使用時進行動態增長 另外以Java為例，在啟動時會將Processes都先啟動好，在請求進來時，進行分配 不同的工作會交給不同的程序處理應該使程序管理工具(systemd)，而不是使用常駐程式 ","version":"Next","tagName":"h3"},{"title":"9. 一次性的(Disposability)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#9-一次性的disposability","content":"應用程式是一次性的 快速啟動 (fast startup)優雅終止 (graceful shutdown) ","version":"Next","tagName":"h3"},{"title":"10. 開發環境與線上環境相同​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#10-開發環境與線上環境相同","content":"可能的差異 程式碼差異 &gt; 可能因為正在開發新功能而造成程式碼差異管理差異 &gt; 開發與維運人員不同造成管理差異服務差異 &gt; 後端服務的差異，線上使用MySQL，開發使用MSSQL ","version":"Next","tagName":"h3"},{"title":"11. 日誌(Logs)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#11-日誌logs","content":"不儲存、不管理，時機到了自動stdout出去由其他接收這來處理這些Log (ex: ELK Stack) ","version":"Next","tagName":"h3"},{"title":"12. 管理者程序(Admin processes)​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#12-管理者程序admin-processes","content":"管理任務作為一次性程序執行 EX: Entity Framework Core 使用 dotnet CLI 刪除資料庫 dotnet ef database drop  此任務執行一次之後就結束了  ","version":"Next","tagName":"h3"},{"title":"參考​","type":1,"pageTitle":"🌧️ 12 因子應用程式","url":"/en/docs/javaSpringCloud/ChapterI/1_712factor#參考","content":"The Twelve-Factor App DevOps Taiwan Community - Meetup 45 - 雲原生時代的軟體開發須知, Miles Chou ","version":"Next","tagName":"h2"},{"title":"🛸 Basics of Video","type":0,"sectionRef":"#","url":"/en/docs/ml/basicsOfVideo","content":"","keywords":"","version":"Next"},{"title":"Types of Color Video Signals​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#types-of-color-video-signals","content":"","version":"Next","tagName":"h2"},{"title":"Component video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#component-video","content":"主要作為單獨的影片訊號發送主要為RGB或是luminance-chrominance transformation ","version":"Next","tagName":"h3"},{"title":"Composite video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#composite-video","content":"顏色和亮度訊號混合到一個carrier wave無法避免兩個訊號之間產生的干擾 ","version":"Next","tagName":"h3"},{"title":"S-Video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#s-video","content":"為Component video與Composite video的折衷他使用兩條線，一條為luminance與一條複合訊號 ","version":"Next","tagName":"h3"},{"title":"Analog Video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#analog-video","content":"","version":"Next","tagName":"h2"},{"title":"NTSC Video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#ntsc-video","content":"每幀 525 條掃描線，每秒 30 幀（或者準確地說，29.97 fps，33.37 毫秒/幀） ","version":"Next","tagName":"h3"},{"title":"PAL Video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#pal-video","content":"每幀 625 條掃描線，每秒 25 幀（40 毫秒/幀）使用 YUV 顏色模型 ","version":"Next","tagName":"h3"},{"title":"Digital Video​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#digital-video","content":"","version":"Next","tagName":"h2"},{"title":"好處​","type":1,"pageTitle":"🛸 Basics of Video","url":"/en/docs/ml/basicsOfVideo#好處","content":"可以直接做非線性的編輯可以重複錄音不用blanking and sync pulse幾乎所有的digital video 都使用 component video ","version":"Next","tagName":"h3"},{"title":"🛸 影片與圖片的色彩","type":0,"sectionRef":"#","url":"/en/docs/ml/colorInImageAndVideo","content":"","keywords":"","version":"Next"},{"title":"Color in Image and Video​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#color-in-image-and-video","content":"","version":"Next","tagName":"h2"},{"title":"Basics of Color​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#basics-of-color","content":"","version":"Next","tagName":"h2"},{"title":"Light and Spectra(光和光譜)​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#light-and-spectra光和光譜","content":"可見光(visible light)為 400mm~700mm 的電磁波(electromagnetic wave)我們看到的光為各種不同波長所組合的 ","version":"Next","tagName":"h3"},{"title":"The Human Retina(人類視網膜)​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#the-human-retina人類視網膜","content":"人類的眼睛就像是相機每個神經元為一個rod或是一個coneRod對顏色不敏感 ","version":"Next","tagName":"h3"},{"title":"Cones and Perception​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#cones-and-perception","content":"cones有三種類型: 紅色(R)綠色(G)藍色(B) 在每種頻率的光之下都會有不同的反應大腦顏色信號來自三個cones，也就是說信號由三個數字組成一個顏色為三種顏色的總和，所以顏色會形成一個三維的向量空間 ","version":"Next","tagName":"h3"},{"title":"CIE Chromaticity Diagram​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#cie-chromaticity-diagram","content":"CIE (Commission Internationale de L'Eclairage, or International Commission on Illumination)定義了三個標準原色(X,Y,Z) ","version":"Next","tagName":"h3"},{"title":"Color Models in Images​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#color-models-in-images","content":"","version":"Next","tagName":"h2"},{"title":"一張彩色圖片由(R,G,B)整數三元組的2維陣列​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#一張彩色圖片由rgb整數三元組的2維陣列","content":"","version":"Next","tagName":"h3"},{"title":"RGB Color Model for CRT Displays​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#rgb-color-model-for-crt-displays","content":"CRT 顯示器具有三種的磷光體(phosphors)當他被激發時會產生多種的波長 ","version":"Next","tagName":"h3"},{"title":"CMY Color Model​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#cmy-color-model","content":"Cyan, Magenta, and Yellow (CMY)維RGB的互補色CMY主要用於影印設備，紙張上的顏料會吸收某些顏色 ","version":"Next","tagName":"h3"},{"title":"Color Models in Video​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#color-models-in-video","content":"","version":"Next","tagName":"h2"},{"title":"YIQ and YUV是影片中常用的顏色模型​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#yiq-and-yuv是影片中常用的顏色模型","content":"","version":"Next","tagName":"h3"},{"title":"YUV Color Model​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#yuv-color-model","content":"最初用於PAL模擬影像中，現在也適用於數字影像的CCIR 601標準Y(luminance)是CIE的Y原色U與V可以用來表示色差 U=B-YV=R-Y 如果黑白圖像時U=V=0 ","version":"Next","tagName":"h3"},{"title":"YCbCr Color Model​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#ycbcr-color-model","content":"YCbCr 與 YUV密切相關他就是一個縮放與位移的YUV通常用於JPEG與MPEG ","version":"Next","tagName":"h3"},{"title":"YIQ Color Model​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#yiq-color-model","content":"YIQ 用於NTSC彩色電視廣播向下兼容只使用Y的黑白電視I → orange-blue axisQ → purple-green axis眼睛敏感程度 Y → I →Q ","version":"Next","tagName":"h3"},{"title":"總結​","type":1,"pageTitle":"🛸 影片與圖片的色彩","url":"/en/docs/ml/colorInImageAndVideo#總結","content":"彩色圖像由三個數值所組成最常見的兩種成像顏色模型 → RGB,CMY最常見的兩種影像顏色模型 → YUV,YIQRGB → 是一種加色模型，常用於發光設備CMY → 是一種減色模型，常用於影印設備YUV → 是使用人眼特性來確定訊息的優先等級 Y黑白(亮度)圖像V和U是色差(色度)圖像YIQ也是使用類似的想法 ","version":"Next","tagName":"h3"},{"title":"🛸 K 近鄰演算法 (k-NN)","type":0,"sectionRef":"#","url":"/en/docs/ml/knnPython","content":"","keywords":"","version":"Next"},{"title":"k-nearest neighbor​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#k-nearest-neighbor","content":"K 近鄰演算法 (k-nearest neighbor, k-NN) 是一種基本的分類與回歸方法，屬於非監督式學習。其主要功能是根據輸入的特徵向量來預測實體的類別。該演算法通過計算不同數據之間的相似度來進行分類或回歸，並根據最近鄰的特徵向量來進行預測。 ","version":"Next","tagName":"h2"},{"title":"K-NN 三大要素​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#k-nn-三大要素","content":"距離度量此演算法會計算兩個數據之間的相似度，常見的距離度量包括歐基里德距離、曼哈頓距離和切比雪夫距離等。K 值K 值定義了使用多少個最近鄰點來進行預測，通常 K 值越小，模型會越複雜，相反地，K 值越大，模型相對簡單。分類決策規則演算法需要一種方式來決定最終的分類結果，例如投票決策或加權投票決策等。 ","version":"Next","tagName":"h2"},{"title":"K-NN 的運作方式如下​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#k-nn-的運作方式如下","content":"給定的特徵向量和相似度度量方法，計算待預測數據點與訓練集中各數據點之間的距離或相似度。距離或相似度的大小，選取最接近待預測數據點的 K 個訓練集中的數據點。選取的 K 個訓練集中的數據點的類別，使用投票決策規則或加權投票決策規則來預測待預測數據點的類別。 ","version":"Next","tagName":"h3"},{"title":"K-NN 的優點包括​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#k-nn-的優點包括","content":"簡單且易於實現。不需要進行模型訓練，因此可以直接進行預測。對於多類別分類問題和多標籤分類問題都適用。 ","version":"Next","tagName":"h3"},{"title":"K-NN 的缺點包括​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#k-nn-的缺點包括","content":"預測速度相對較慢，因為需要計算與訓練集中所有數據點的距離或相似度。對於高維特徵空間或大規模數據集可能效果不佳，因為在高維空間中，距離度量容易受到&quot;維度災難&quot;的影響，且需要較大的存儲空間。對於不平衡數據集或噪聲數據集容易受到干擾，可能會產生誤判。K 值的選擇對預測結果具有重要影響，需要仔細調參。無法處理缺失值或不完整的數據。 ","version":"Next","tagName":"h3"},{"title":"結論​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#結論","content":"K 近鄰演算法 (k-nearest neighbor, k-NN) 是一種簡單且易於實現的非監督式學習方法，主要用於分類和回歸問題。其基本思想是根據特徵向量的相似度來進行預測，並通過選取最近的 K 個鄰居來進行分類或回歸。儘管 K-NN 有一些缺點，但在特定的應用場景中仍然可以是一個有效的機器學習工具。在實際應用中，我們應該根據數據集的特點和需求來選擇合適的距離度量、K 值和分類決策規則，並進行適當的特徵工程和模型評估，以獲得較好的預測效果。 ","version":"Next","tagName":"h3"},{"title":"ref​","type":1,"pageTitle":"🛸 K 近鄰演算法 (k-NN)","url":"/en/docs/ml/knnPython#ref","content":" Cover, T., &amp; Hart, P. (1967). Nearest neighbor pattern classification. IEEE Transactions on Information Theory, 13(1), 21-27.Duda, R. O., Hart, P. E., &amp; Stork, D. G. (2012). Pattern classification. John Wiley &amp; Sons.Zhang, D. (2011). Nearest neighbor search: a database perspective. ACM SIGMOD Record, 40(2), 18-25.Altman, N. S. (1992). An introduction to kernel and nearest-neighbor nonparametric regression. The American Statistician, 46(3), 175-185.Beyer, K., Goldstein, J., Ramakrishnan, R., &amp; Shaft, U. (1999). When is &quot;nearest neighbor&quot; meaningful?. In International Conference on Database Theory (pp. 217-235). Springer. ","version":"Next","tagName":"h3"},{"title":"🛸 多媒體簡介","type":0,"sectionRef":"#","url":"/en/docs/ml/multimedia","content":"","keywords":"","version":"Next"},{"title":"多媒體系統的歷史​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#多媒體系統的歷史","content":"報紙是第一種大眾傳播的媒介(medium)報紙使用了文本、圖像1895年 Gugliemo Marconi發送了第一則無線電傳輸(wireless radio)1901年他探測到了橫跨大西洋的無線電波無線電的發明當初是為了電報，但如今被語音廣播廣泛使用20世紀之後發明電視，他帶來了影像(video)改變了大眾傳播(mass communications)的世界 ","version":"Next","tagName":"h2"},{"title":"2.Hypermedia/Multimedia​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#2hypermediamultimedia","content":"","version":"Next","tagName":"h2"},{"title":"超媒體與多媒體​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#超媒體與多媒體","content":"","version":"Next","tagName":"h2"},{"title":"何謂超文本(HyperText)與超媒體(HyperMedia)​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#何謂超文本hypertext與超媒體hypermedia","content":"Hypermedia → 數位的一定要有連結Hypertext 包含了其他連結的文字Hypertext 他是非線性的Hypermedia 不限於文本，它包含聲音與影像The World Wide Web (WWW) 是Hypermedia 的最佳例子 ","version":"Next","tagName":"h3"},{"title":"何謂多媒體(Multimedia)​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#何謂多媒體multimedia","content":"Multimedia → 類比+數位Multimedia 即為可除了傳統媒體之外，可透過聲音、影像、動畫的電腦資訊Hypermedia就是多媒體之一 ","version":"Next","tagName":"h3"},{"title":"3.Overview of Multimedia Sofware Tools(多媒體工具概述)​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#3overview-of-multimedia-sofware-tools多媒體工具概述","content":"","version":"Next","tagName":"h2"},{"title":"Music Sequencing and Notation(音樂編序和符號)​","type":1,"pageTitle":"🛸 多媒體簡介","url":"/en/docs/ml/multimedia#music-sequencing-and-notation音樂編序和符號","content":"Cakewalk 支援MIDI提供各種編輯介面 ","version":"Next","tagName":"h3"},{"title":"🛸 JPEG-圖片壓縮","type":0,"sectionRef":"#","url":"/en/docs/ml/imageCompressionJPEG","content":"","keywords":"","version":"Next"},{"title":"JPEG概述​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#jpeg概述","content":"Joint Photographic Expert Group在1992年被評為國際標準適用於彩色與灰階圖片 ","version":"Next","tagName":"h2"},{"title":"動機​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#動機","content":"The compression ratio of lossless methods (無損壓縮演算法)JPEG使用變換編碼: 大部分圖像內容在圖像轉換中是相對較慢的與較低頻率的空間頻率分量損失相比，人類更容易接受高頻率的損失 ","version":"Next","tagName":"h3"},{"title":"JPEG Overview​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#jpeg-overview","content":"編碼過程: DCT(Discrete Cosine Transformation) → 離散余弦變換 DPCM(Differential Pulse Code Modulation) → 差分預測編碼調製 → DC Zigzag Scanning → 曲折掃描 RLE(Run-Length Encoding) → AC Entropy Coding → 熵編碼 ","version":"Next","tagName":"h3"},{"title":"Discrete Cosine Transform (DCT)​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#discrete-cosine-transform-dct","content":"離散餘弦變換 (DCT)：  逆離散餘弦變換 (IDCT)：  ","version":"Next","tagName":"h3"},{"title":"Quantization​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#quantization","content":"量化的誤差是有損壓縮的主要來源均衡量化 每個F[u,v]都同除以常數N 非均衡量化 使用量化表最終在將量化表存於table之中 ","version":"Next","tagName":"h3"},{"title":"Zig-zag Scan​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#zig-zag-scan","content":" ","version":"Next","tagName":"h3"},{"title":"DPCM on DC component​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#dpcm-on-dc-component","content":"直流分量大且變化多端，但通常接近先前值 ","version":"Next","tagName":"h3"},{"title":"RLE on AC components​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#rle-on-ac-components","content":"保留跳過和值，其中跳過是零的數量，值是下一個非零分量 ","version":"Next","tagName":"h3"},{"title":"Entropy Coding​","type":1,"pageTitle":"🛸 JPEG-圖片壓縮","url":"/en/docs/ml/imageCompressionJPEG#entropy-coding","content":"使用Huffman TablesHuffman Tables是可以自行定義的 ","version":"Next","tagName":"h3"},{"title":"🦑 Java String","type":0,"sectionRef":"#","url":"/en/docs/javaSpringCloud/javaExercises/javaString","content":"","keywords":"","version":"Next"},{"title":"String​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#string","content":"字串須由兩個雙引號 &quot; &quot; 包裝起來 public class firstString { public static void main(String[] args) { // 宣告字串 String hi = &quot;hi hi&quot;; // 印出結果 System.out.println(hi); } }  Github 範例 ","version":"Next","tagName":"h2"},{"title":"new String​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#new-string","content":"字串除了使用 = &quot;hi hi&quot; 也可以使用 new public class newString { public static void main(String[] args) { // 使用 new 來宣告字串 String hi = new String(&quot;hi hi&quot;); // 印出結果 System.out.println(hi); } }  Github 範例 ","version":"Next","tagName":"h2"},{"title":"String 與 new String 的差異​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#string-與-new-string-的差異","content":"直接等於 String 的時候，會先到 String pool 尋找是否有相同的字串，拿來做使用 new String 則是直接在記憶體中開一段新的位址 ","version":"Next","tagName":"h2"},{"title":"var String​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#var-string","content":"caution 在 java 10 之後可以使用 var 來當宣告物件，它會自動判斷型別 使用前請先用 java -version 確認版本 public static void main(String[] args) { // 使用 var 來宣告字串 var hi = &quot;hi hi&quot;; // 印出結果 System.out.println(hi); }  Github 範例 ","version":"Next","tagName":"h2"},{"title":"字串相加​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#字串相加","content":"字串相加會將相加的字串按照順序組合在一起 public static void main(String[] args) { // 宣告字串 String one = &quot;1&quot;; // 宣告第二字串 String two = &quot;2&quot;; // 相加字串 String ans = &quot;ans=&quot; + one + two; // 印出結果 System.out.println(ans); }  結果: ans=12 Github 範例 ","version":"Next","tagName":"h2"},{"title":"常用方法​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#常用方法","content":"","version":"Next","tagName":"h2"},{"title":"長度 (length)​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#長度-length","content":"如果需要字串的長度可使用 length() public static void main(String[] args) { // 宣告字串 String hi = &quot;hi hi&quot;; // 印出結果 System.out.println(&quot;長度 = &quot; + hi.length()); }  結果: 長度 = 5 Github 範例 ","version":"Next","tagName":"h3"},{"title":"字串比較(contentEquals)​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#字串比較contentequals","content":"比較兩個字串是否相同比較的是 StringBuffer public static void main(String[] args) { // 宣告字串 String hi1 = &quot;hi hi&quot;; String hi2 = &quot;hi hi&quot;; String hi3 = &quot;你好&quot;; // 印出結果 System.out.println(&quot;hi1:hi2 &quot; + hi1.contentEquals(hi2)); System.out.println(&quot;hi1:hi3 &quot; + hi1.contentEquals(hi3)); }  結果: hi1:hi2 true hi1:hi3 false Github 範例 ","version":"Next","tagName":"h3"},{"title":"結尾是否符合(endsWith)​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#結尾是否符合endswith","content":"確認結尾是否符合 public static void main(String[] args) { // 宣告字串 String ten = &quot;10&quot;; // 印出結果 System.out.println(ten.endsWith(&quot;0&quot;)); }  結果: true Github 範例 ","version":"Next","tagName":"h3"},{"title":"字串比較(equals)​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#字串比較equals","content":"比較兩個字串是否相同比較的是 object public static void main(String[] args) { // 宣告字串 String hi1 = &quot;hi hi&quot;; String hi2 = &quot;hi hi&quot;; String hi3 = &quot;你好&quot;; // 印出結果 System.out.println(&quot;hi1:hi2 &quot; + hi1.equals(hi2)); System.out.println(&quot;hi1:hi3 &quot; + hi1.equals(hi3)); }  Github 範例 caution equals 與 == 的差異 == 比較的是位址，equals 比較的則是物件 public static void main(String[] args) { // 宣告字串 String hi1 = &quot;hi hi&quot;; String hi2 = new String(&quot;hi hi&quot;); // 印出結果 System.out.println(&quot;hi1.equals(hi2) &quot; + hi1.equals(hi2)); System.out.println(&quot;hi1 == hi2 &quot; + (hi1 == hi2)); }  Github 範例 ","version":"Next","tagName":"h3"},{"title":"字串比較(equalsIgnoreCase)​","type":1,"pageTitle":"🦑 Java String","url":"/en/docs/javaSpringCloud/javaExercises/javaString#字串比較equalsignorecase","content":"比較兩個字串是否相同不考慮大小寫 public static void main(String[] args) { // 宣告字串 String hi1 = &quot;hi hi&quot;; String hi2 = new String(&quot;hi hi&quot;); // 印出結果 System.out.println(&quot;hi1.equals(hi2) &quot; + hi1.equals(hi2)); System.out.println(&quot;hi1 == hi2 &quot; + (hi1 == hi2)); }  Github 範例 ","version":"Next","tagName":"h3"},{"title":"🛸 聲音數據化","type":0,"sectionRef":"#","url":"/en/docs/ml/multimediaData","content":"","keywords":"","version":"Next"},{"title":"Multimedia Data Representations​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#multimedia-data-representations","content":"","version":"Next","tagName":"h2"},{"title":"Digitization of Sound(聲音數據化)​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#digitization-of-sound聲音數據化","content":"","version":"Next","tagName":"h2"},{"title":"Facts about Sound(關於聲音的數據)​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#facts-about-sound關於聲音的數據","content":"聲音為壓力波聲音是在空氣中傳遞的連續波(continuous wave)是由壓力(pressure)差所造成的 ","version":"Next","tagName":"h3"},{"title":"一般數據化​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#一般數據化","content":"將聲音或影像輸入到電腦，我們就必須將他轉為數據(digitize)因此我們需要分散取樣(discrete sampling) → (time and voltage)Sampling(取樣) → 時間維度 → 水平軸Quantization(量化) → 訊號強度 → 垂直軸8bit 量化分為256 levels,16bit 量化分為 65536 levels ","version":"Next","tagName":"h3"},{"title":"Signal to Noise Ratio (SNR)(訊號雜訊比)​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#signal-to-noise-ratio-snr訊號雜訊比","content":"在電腦中有些信號是需要被測量的，有些是隨機產生的需要被測量的 → 訊號(voltage)隨機產生的 → 雜訊(noise)兩者的功率稱為訊號雜訊比單位通常以分貝做計算 ","version":"Next","tagName":"h3"},{"title":"Signal to Quantization Noise Ratio (SQNR)(訊號量化雜訊比)​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#signal-to-quantization-noise-ratio-sqnr訊號量化雜訊比","content":"量化誤差(quantization error)是採樣時間模擬信號的實際值與最接近的量化間隔值之間的差值 ","version":"Next","tagName":"h3"},{"title":"Graphic/Image Data Structures(圖形數據結構)​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#graphicimage-data-structures圖形數據結構","content":"Pixels → picture elements in digital images 數位圖像中的圖片元素 Image Resolution → number of pixels in a digital image 數位圖像中的像素數 Bit-Map → 數據顯示表示的方式與他們存在影片中的相同 ","version":"Next","tagName":"h3"},{"title":"單色圖像​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#單色圖像","content":"每個像素都由0與1組成的 ","version":"Next","tagName":"h3"},{"title":"灰階圖像​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#灰階圖像","content":"每像素由一個byte組成的 ","version":"Next","tagName":"h3"},{"title":"8-bit 彩色圖像​","type":1,"pageTitle":"🛸 聲音數據化","url":"/en/docs/ml/multimediaData#8-bit-彩色圖像","content":"每個像素一個byte支援256種顏色 ","version":"Next","tagName":"h3"},{"title":"🐍 Python 基本型別-字串","type":0,"sectionRef":"#","url":"/en/docs/ml/pyExercises/pyTypes","content":"","keywords":"","version":"Next"},{"title":"數字 (Number)​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#數字-number","content":"","version":"Next","tagName":"h2"},{"title":"整數​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#整數","content":"var1 = 1 var2 = 2 print(var1) print(var2)  結果 &gt;&gt;&gt; var1 = 1 &gt;&gt;&gt; var2 = 2 &gt;&gt;&gt; print(var1) 1 &gt;&gt;&gt; print(var2) 2  ","version":"Next","tagName":"h3"},{"title":"浮點數​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#浮點數","content":"var1 = 1.5 var2 = 2.7 print(var1 + var2)  結果 &gt;&gt;&gt; var1 = 1.5 &gt;&gt;&gt; var2 = 2.7 &gt;&gt;&gt; print(var1 + var2) 4.2  ","version":"Next","tagName":"h3"},{"title":"字串​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#字串","content":"","version":"Next","tagName":"h2"},{"title":"宣告字串​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#宣告字串","content":"str = 'HiHi' print(str)  結果 &gt;&gt;&gt; str = 'HiHi' &gt;&gt;&gt; print(str) HiHi  ","version":"Next","tagName":"h3"},{"title":"輸出第一個字​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#輸出第一個字","content":"str = 'HiHi' print(str[0])  結果 &gt;&gt;&gt; str = 'HiHi' &gt;&gt;&gt; print(str[0]) H  ","version":"Next","tagName":"h3"},{"title":"輸出二到四之間的字​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#輸出二到四之間的字","content":"str = 'HiHi' print(str[1:3])  結果 &gt;&gt;&gt; str = 'HiHi' &gt;&gt;&gt; print(str[1:3]) iH  ","version":"Next","tagName":"h3"},{"title":"從第二個字開始輸出​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#從第二個字開始輸出","content":"str = 'HiHi' print(str[1:])  結果 &gt;&gt;&gt; str = 'HiHi' &gt;&gt;&gt; print(str[1:]) iHi  ","version":"Next","tagName":"h3"},{"title":"只輸出到第二個字​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#只輸出到第二個字","content":"str = 'HiHi' print(str[:2])  結果 &gt;&gt;&gt; str = 'HiHi' &gt;&gt;&gt; print(str[:2]) Hi  ","version":"Next","tagName":"h3"},{"title":"輸出兩次​","type":1,"pageTitle":"🐍 Python 基本型別-字串","url":"/en/docs/ml/pyExercises/pyTypes#輸出兩次","content":"str = 'HiHi' print(str * 2)  結果 &gt;&gt;&gt; str = 'HiHi' &gt;&gt;&gt; print(str * 2) HiHiHiHi  ","version":"Next","tagName":"h3"},{"title":"🛸 標準系統格式","type":0,"sectionRef":"#","url":"/en/docs/ml/standardSystem","content":"","keywords":"","version":"Next"},{"title":"Standard System Independent Formats(標準系統獨立格式)​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#standard-system-independent-formats標準系統獨立格式","content":"","version":"Next","tagName":"h2"},{"title":"Gif​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#gif","content":"僅限於 8 位 (256) 色圖像，適用於很少有獨特顏色的圖像Gif89a 支援簡易動畫 ","version":"Next","tagName":"h3"},{"title":"JPEG​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#jpeg","content":"為影像壓縮標準由 Joint Photographics Experts Group創建利用人類視覺系統的侷限性來實現高壓縮綠 ","version":"Next","tagName":"h3"},{"title":"TIFF​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#tiff","content":"標記圖片文件格式(Tagged Image File Format)多種不同儲存類型(Ex: 單色、灰階、8-bit RGB)由 Aldus Corp 開發，後來獲得微軟的支持TIFF 是一種無損格式(在不使用 new JPEG tag的前提下)但與JPEG相比由於格式不普遍，所以無任何優勢，導致受歡迎程度下降 ","version":"Next","tagName":"h3"},{"title":"Graphics Animation Files​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#graphics-animation-files","content":"FLC → 主要為動畫(animation)或動圖文件(moving picture file)的格式FLI → 與FLC相類似GL → 高品質的動態圖片，通常為large file sizes ","version":"Next","tagName":"h3"},{"title":"Postscript/Encapsulated Postscript​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#postscriptencapsulated-postscript","content":"一種標籤的語言(typesetting language)其中包括文字矢量或結構圖形和bit-mapped images ","version":"Next","tagName":"h3"},{"title":"System Dependent Format​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#system-dependent-format","content":"","version":"Next","tagName":"h2"},{"title":"以下是一些常用的系統相關格式​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#以下是一些常用的系統相關格式","content":"","version":"Next","tagName":"h2"},{"title":"Microsoft Windows:BMP​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#microsoft-windowsbmp","content":"系統標準圖形文件格式支援24-bit bit-map images ","version":"Next","tagName":"h3"},{"title":"Macintosh:PAINT and PICT​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#macintoshpaint-and-pict","content":"PAINT 是最初用於 MacPaint 程序，最初僅用於 1 位單色圖像 ","version":"Next","tagName":"h3"},{"title":"X-windows: XBM​","type":1,"pageTitle":"🛸 標準系統格式","url":"/en/docs/ml/standardSystem#x-windows-xbm","content":"支持 24-bit color bit-map常用於儲存icon、pixmaps、backdrops ","version":"Next","tagName":"h3"},{"title":"🎨 線條與迴圈","type":0,"sectionRef":"#","url":"/en/docs/p5jsNote/LineAndLoop","content":"","keywords":"","version":"Next"},{"title":"最終結果​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#最終結果","content":" ","version":"Next","tagName":"h2"},{"title":"圖表座標​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#圖表座標","content":" ","version":"Next","tagName":"h2"},{"title":"定義畫布​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#定義畫布","content":"使用變數宣告方式，分別宣告 width(寬度),height(高度)將寬度設定為 400將高度設定為 400 function setup() { let width = 400; //定義寬度 let height = 400; //定義高度 createCanvas(width, height); //將變數帶入設定中 console.log(&quot;寬: &quot; + width + &quot; , 高: &quot; + height); //在console上面印出目前寬高 }  ","version":"Next","tagName":"h2"},{"title":"line()使用方式​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#line使用方式","content":" line(x1, y1, x2, y2);  (x1,y1) (x2, y2) 各別代表一個點的座標兩個點相連之後，會成為一條線 ","version":"Next","tagName":"h2"},{"title":"搭配 for 使用​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#搭配-for-使用","content":"","version":"Next","tagName":"h2"},{"title":"1. 左上角(直線)​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#1--左上角直線","content":"需要從下到上，由左而右畫出直線因此第一個點會從( 1 X 10 ,400/2) -&gt; (10,200) 畫到 (1 X 10,0) -&gt; (10,0)for 迴圈條件 -&gt; 小於 20 的原因是因為，我們每次都將 i X 10，整張畫布的寬是 400 切成一半為 200 for (let i = 1; i &lt;= 20; i++) { fill(250); line(i * 10, height / 2, i * 10, 0); }  ","version":"Next","tagName":"h3"},{"title":"2. 右上角(橫線)​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#2-右上角橫線","content":"需要從上到下，由左而右畫出直線因此第一個點會從( 400/2, 1 X 10) -&gt; (200,10) 畫到 ( 400,1 X 10) -&gt; (400,10)for 迴圈條件 -&gt; 小於 20 的原因是因為，我們每次都將 i X 10，整張畫布的高是 400 切成一半為 200 for (let i = 1; i &lt;= 20; i++) { fill(250); line(width / 2, i * 10, width, i * 10); }  ","version":"Next","tagName":"h3"},{"title":"3. 左下角(橫線)​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#3-左下角橫線","content":"需要從下到上，由左而右畫出直線因此第一個點會從( 0,400 - (1 X 10)) -&gt; (0,390) 畫到 ( 400/2,400 - (1 X 10)) -&gt; (200,390)用高度減掉 i X 10 的原因是因為，我們要從邊界往上畫，因此需要從最大邊界每次往上減掉 10 for (let i = 1; i &lt;= 20; i++) { fill(250); line(0, height - i * 10, width / 2, height - i * 10); }  ","version":"Next","tagName":"h3"},{"title":"4. 右下角(直線)​","type":1,"pageTitle":"🎨 線條與迴圈","url":"/en/docs/p5jsNote/LineAndLoop#4-右下角直線","content":"需要從下到上，由右而左畫出直線因此第一個點會從( 400 - (1 X 10),0 ) -&gt; (390,0) 畫到 ( 400 - (1 X 10),400/2 ) -&gt; (390,200)用寬度減掉 i X 10 的原因是因為，我們要從邊界往左畫，因此需要從最大邊界每次往上減掉 10 for (let i = 1; i &lt;= 20; i++) { fill(250); line(width - i * 10, height, width - i * 10, height / 2); }  ","version":"Next","tagName":"h3"},{"title":"🎨 map 函式","type":0,"sectionRef":"#","url":"/en/docs/p5jsNote/MapFunc","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🎨 map 函式","url":"/en/docs/p5jsNote/MapFunc#說明","content":"map 首先需要設定原始參數的範圍並設定要設定的比例範圍並輸入需要縮放的參數透過 map 函式會將輸入的參數做等比例縮放 map(輸入的參數 , 原始參數起始範圍, 原始參數結束範圍, 縮放起始範圍, 縮放結束範圍) ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"🎨 map 函式","url":"/en/docs/p5jsNote/MapFunc#範例","content":"我們以 map(1,0,10,0,100) 為例原始的範圍是 0~10我們要將它變成 0~1000~10 變成 0~100 則需要乘以 10 倍因此我們需要縮放的 1 通過 map 函式的計算後，會變成 10 線上測試 ","version":"Next","tagName":"h2"},{"title":"🎨 arc 函式","type":0,"sectionRef":"#","url":"/en/docs/p5jsNote/MethodArc","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🎨 arc 函式","url":"/en/docs/p5jsNote/MethodArc#說明","content":"用途 : 在螢幕上畫一條 弧線模式 : OPEN : open semi-circle (半開圓形) -&gt; 純粹弧線，並無閉鎖CHORD : closed semi-circle (閉鎖半圓) -&gt; 封閉式半圓PIE : a closed pie segment (圓餅圖) -&gt; 封閉式圓餅圖 從起點到終點，程式皆由順時鐘繪製 arc(x, y, w, h, start, stop, [mode], [detail]) x : 點的 x 軸y : 點的 y 軸w : 圓弧的寬度h : 圓弧的高度start : 起始的角度stop : 結束的角度[mode] : 模式(OPEN, CHORD, PIE) 非必填[detail] : 指定圓弧的周長，默認為 25，不可超過 50 非必填 ","version":"Next","tagName":"h2"},{"title":"OPEN 例​","type":1,"pageTitle":"🎨 arc 函式","url":"/en/docs/p5jsNote/MethodArc#open-例","content":"OPEN : open semi-circle (半開圓形) -&gt; 純粹弧線，並無閉鎖 // 從點(100, 150) 開始，劃出 200 x 200 的開放式半圓 arc(100, 150, 200, 200, 0, 10, OPEN);  結果 : ","version":"Next","tagName":"h3"},{"title":"CHORD 例​","type":1,"pageTitle":"🎨 arc 函式","url":"/en/docs/p5jsNote/MethodArc#chord-例","content":"CHORD : closed semi-circle (閉鎖半圓) -&gt; 封閉式半圓與開放式的差異只在半圓口是否有黑線 // 從點(100, 150) 開始，劃出 200 x 200 的封閉式式半圓 arc(100, 150, 200, 200, 0, 10, CHORD);  結果 : ","version":"Next","tagName":"h3"},{"title":"PIE 例​","type":1,"pageTitle":"🎨 arc 函式","url":"/en/docs/p5jsNote/MethodArc#pie-例","content":"PIE : a closed pie segment (圓餅圖) -&gt; 封閉式圓餅圖 // 從點(100, 150) 開始，劃出 200 x 200 的圓餅圖 arc(100, 150, 200, 200, 0, 10, PIE);  結果 : ","version":"Next","tagName":"h3"},{"title":"🎨 區塊漸層","type":0,"sectionRef":"#","url":"/en/docs/p5jsNote/Gradient","content":"","keywords":"","version":"Next"},{"title":"最終結果​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#最終結果","content":" ","version":"Next","tagName":"h2"},{"title":"簡易作法​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#簡易作法","content":"","version":"Next","tagName":"h2"},{"title":"1. 首先將寬度除以五，來獲得五個區塊​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#1-首先將寬度除以五來獲得五個區塊","content":"let linePosition = width / 5;  ","version":"Next","tagName":"h3"},{"title":"2. 開始畫第一塊​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#2-開始畫第一塊","content":"for (let i = 0; i &lt; height; i++) { let resAmount = map(i, 0, height, 0, 255); stroke(resAmount, 100, 200); line(0, i, linePosition, i); }  ","version":"Next","tagName":"h3"},{"title":"3. 因為我們需要在每個區塊從上而下畫線，而且線需要漸層，所以使用 map 計算紅色​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#3-因為我們需要在每個區塊從上而下畫線而且線需要漸層所以使用-map-計算紅色","content":"由於 i 從上而下，所以 i 的範圍是 0~畫布的高要轉換成 RGB 的範圍 0~255這邊換算出來的是 RGB 中的 R(紅色)由於隨著區塊增長要轉換的三原色起始位置需要越來越大因此將他乘以 30 的倍數 //區塊1 let resAmount = map(i, 0, height, 0, 255); //區塊2 let resAmount = map(i, 0, height, 30, 255); //區塊3 let resAmount = map(i, 0, height, 60, 255); //區塊4 let resAmount = map(i, 0, height, 90, 255); //區塊5 let resAmount = map(i, 0, height, 120, 255);  ","version":"Next","tagName":"h3"},{"title":"4. 設定畫筆顏色(RGB)​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#4-設定畫筆顏色rgb","content":"將每次計算後的紅色置入，其他兩色固定由於紅色隨著迴圈，數字會越來越大因此顏色會越來越偏紫色，藉此達到漸層效果 stroke(resAmount, 100, 200);  ","version":"Next","tagName":"h3"},{"title":"5. 畫線​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#5-畫線","content":"畫線的重點在於要由上而下 -&gt; 所以起點與終點的 y 都帶入 ix 軸則是需要從第一個區塊的起點畫到第二個區塊的起點所以我們用了剛剛算好的區塊(linePosition)例如: 第一塊就是要從 0~第一塊的終點，第二塊則是需要從第一塊終點到第二塊起點 //第一塊 (0 ~ 第一塊) line(0, i, linePosition, i); //第二塊 (第一塊 ~ 第二塊) line(linePosition * 1, i, linePosition * 2, i); //第三塊 (第二塊 ~ 第三塊) line(linePosition * 2, i, linePosition * 3, i); //第四塊 (第三塊 ~ 第四塊) line(linePosition * 3, i, linePosition * 4, i); //第五塊 (第四塊 ~ 第五塊) line(linePosition * 4, i, linePosition * 5, i);   ","version":"Next","tagName":"h3"},{"title":"雙迴圈做法​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#雙迴圈做法","content":"雙迴圈主要是將以上重複的程式精簡化 ","version":"Next","tagName":"h2"},{"title":"1. 紅色計算的精簡化​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#1-紅色計算的精簡化","content":"由於 RGB 的範圍每次都是 30 的倍數因此我們將他*30 let resAmount = map(i, 0, height, position * 30, 255);  ","version":"Next","tagName":"h3"},{"title":"2. 並將劃線的點到點使用運算的方式​","type":1,"pageTitle":"🎨 區塊漸層","url":"/en/docs/p5jsNote/Gradient#2-並將劃線的點到點使用運算的方式","content":"line(linePosition * position, i, linePosition * (position + 1), i);  ","version":"Next","tagName":"h3"},{"title":"🎨 聲波","type":0,"sectionRef":"#","url":"/en/docs/p5jsNote/Wave","content":"","keywords":"","version":"Next"},{"title":"變數宣告​","type":1,"pageTitle":"🎨 聲波","url":"/en/docs/p5jsNote/Wave#變數宣告","content":"分別宣告 角度(用於 y 軸計算) let angle = 0.0; 圓的半徑為 20 let radius = 20;  ","version":"Next","tagName":"h2"},{"title":"設定圓的模式​","type":1,"pageTitle":"🎨 聲波","url":"/en/docs/p5jsNote/Wave#設定圓的模式","content":"半徑最後為半徑模式 circle(x, y, 半徑) ellipseMode(RADIUS); 半徑最後為直徑模式(預設模式) circle(x, y, 直徑) ellipseMode(CENTER);  ","version":"Next","tagName":"h2"},{"title":"開始畫圓​","type":1,"pageTitle":"🎨 聲波","url":"/en/docs/p5jsNote/Wave#開始畫圓","content":"//畫25個圓 for (let i = 0; i &lt; 25; i++) { //計算圓新的x軸(固定不變) let x = map(i, 0, 24, radius, width); //計算圓的y軸 let y = map(sin(angle + frameCount), -1, 1, radius, height); //畫圓 circle(x, y, radius); //每次角度都加上 2pi / 8.75 angle += TWO_PI / 8.75; }  ","version":"Next","tagName":"h2"},{"title":"🎮 前言","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day1","content":"","keywords":"","version":"Next"},{"title":"接下來就讓我們用 30 天來見識糞 Game 的威力吧​","type":1,"pageTitle":"🎮 前言","url":"/en/docs/phaserJs/day1#接下來就讓我們用-30-天來見識糞-game-的威力吧","content":"在許久之前就一直想嘗試寫遊戲，寫出一款屬於自己的遊戲，但每次都心有餘力不足。因此決定藉由這次鐵人賽，一邊學習一邊挑戰自己，看看是否能夠寫出屬於自己的遊戲。 ","version":"Next","tagName":"h2"},{"title":"關於 Phaser 3​","type":1,"pageTitle":"🎮 前言","url":"/en/docs/phaserJs/day1#關於-phaser-3","content":"Phaser 3 是什麼？ Phaser 3 是一個遊戲開發框架。 為什麼選擇使用 Phaser 3？ Phaser 3 的文件非常完整且持續更新。Phaser 3 支持 TypeScript，讓開發更加方便。由於遊戲資源都屬於靜態資源，因此可以使用 Github page 輕鬆地部署自己的遊戲。 ","version":"Next","tagName":"h2"},{"title":"我與 Phaser 3​","type":1,"pageTitle":"🎮 前言","url":"/en/docs/phaserJs/day1#我與-phaser-3","content":"實際上，我決定寫這篇文章時，與 Phaser 3 的接觸時間不到 24 小時。本文將是我一邊研究一邊寫的筆記文章。希望讀者不要對遊戲成品有太高的期望，因為一切都是以「糞 Game」為出發點。雖然本系列文章原本是要在第 14 屆鐵人賽現學現賣的，但因時間和其他因素，未能發布出去。 ","version":"Next","tagName":"h2"},{"title":"接下來就讓我們用 30 天來見識遊戲的魅力吧​","type":1,"pageTitle":"🎮 前言","url":"/en/docs/phaserJs/day1#接下來就讓我們用-30-天來見識遊戲的魅力吧","content":"","version":"Next","tagName":"h2"},{"title":"🎮 環境","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day2","content":"","keywords":"","version":"Next"},{"title":"官網​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#官網","content":"官網圖文豐富內容非常詳細 ","version":"Next","tagName":"h2"},{"title":"靜態資源​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#靜態資源","content":"首先可以到官網下載完整的 JS 與 min.js或是想用 CDN 也可以使用(以下版本有日後有可能會更新，請到官網抓取最新版) &lt;script src=&quot;//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js&quot;&gt;&lt;/script&gt;  官方也有提供 npm(以下版本有日後有可能會更新，請到官網抓取最新版) npm install phaser@3.55.2  ","version":"Next","tagName":"h2"},{"title":"素材庫​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#素材庫","content":"Kenney愛給 ","version":"Next","tagName":"h2"},{"title":"開發工具​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#開發工具","content":"本次文章使用 VS Code可依個人使用習慣來選擇開發工具 ","version":"Next","tagName":"h2"},{"title":"開發起手式​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#開發起手式","content":"","version":"Next","tagName":"h2"},{"title":"1. 建立畫布(遊戲呈現的區塊)​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#1-建立畫布遊戲呈現的區塊","content":"於&lt;bod&gt;加入div標籤 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  ","version":"Next","tagName":"h3"},{"title":"2. 引用 JS​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#2-引用-js","content":"於&lt;bod&gt;加入phaser.js標籤 &lt;script src=&quot;//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js&quot;&gt;&lt;/script&gt;  ","version":"Next","tagName":"h3"},{"title":"3. 建立場景​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#3-建立場景","content":"宣告一個場景 // 宣告一個場景 let scene = new Phaser.Scene(&quot;Game&quot;);  宣告場景的基本資訊 // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 640, // 寬 height: 320, // 高 scene, // 綁定宣告的場景 };  啟動遊戲 let game = new Phaser.Game(config);  ","version":"Next","tagName":"h3"},{"title":"4. 使用Open with Live Server啟動遊戲​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#4-使用open-with-live-server啟動遊戲","content":"可以看到畫面上有一塊黑黑的區域表示成功了喔 ","version":"Next","tagName":"h3"},{"title":"今天介紹了基本的開發環境與開發的起手式，明天就要開始練習 Phaser 了喔​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#今天介紹了基本的開發環境與開發的起手式明天就要開始練習-phaser-了喔","content":" ","version":"Next","tagName":"h2"},{"title":"程式原碼​","type":1,"pageTitle":"🎮 環境","url":"/en/docs/phaserJs/day2#程式原碼","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new Phaser.Scene('Game'); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 640, // 寬 height: 320, // 高 scene // 綁定宣告的場景 } //啟動遊戲 let game = new Phaser.Game(config) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h2"},{"title":"🎮 基本語法(一) - 靜態資源","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day3","content":"","keywords":"","version":"Next"},{"title":"今天開始來把背景與角色加載到遊戲資源裡面吧​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#今天開始來把背景與角色加載到遊戲資源裡面吧","content":"","version":"Next","tagName":"h2"},{"title":"基本 phaser.js 功能 - 加載素材​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#基本-phaserjs-功能---加載素材","content":"","version":"Next","tagName":"h2"},{"title":"使用 preload​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#使用-preload","content":"這步驟稱為 預加載 ","version":"Next","tagName":"h2"},{"title":"1. 先到 config 綁定事件​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#1-先到-config-綁定事件","content":"// 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, }, };  ","version":"Next","tagName":"h3"},{"title":"2. preload() 就與 preload 的事件綁訂了​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#2-preload-就與-preload-的事件綁訂了","content":"function preload() { // 載入素材 }  ","version":"Next","tagName":"h3"},{"title":"載入資源 - 背景圖​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#載入資源---背景圖","content":"先建立一個資料夾名稱命名為 assets再到裡面建立一個 backgroungs 的資料夾將背景圖片放到裡面將圖片引入 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); }   ","version":"Next","tagName":"h2"},{"title":"載入資源 - 角色圖​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#載入資源---角色圖","content":"在 assets 裡面建立一個 roles 的資料夾將背景圖片放到裡面將圖片引入 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;player1&quot;, &quot;../assets/roles/alpaca.png&quot;); }   ","version":"Next","tagName":"h2"},{"title":"載入資源 - 音樂​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#載入資源---音樂","content":"在 assets 裡面建立一個 music 的資料夾將背景圖片放到裡面將圖片引入 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;player1&quot;, &quot;../assets/roles/alpaca.png&quot;); this.load.audio(&quot;music1&quot;, &quot;../assets/music/crrect_answer3.mp3&quot;); }  ","version":"Next","tagName":"h2"},{"title":"以上就是今天的資源加載，明天就會開始使用這些資源啦​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#以上就是今天的資源加載明天就會開始使用這些資源啦","content":" ","version":"Next","tagName":"h2"},{"title":"程式原碼​","type":1,"pageTitle":"🎮 基本語法(一) - 靜態資源","url":"/en/docs/phaserJs/day3#程式原碼","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new Phaser.Scene('Game'); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, } } //啟動遊戲 let game = new Phaser.Game(config) //載入素材 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image('bg1', '../assets/backgrounds/bg_1.webp'); this.load.image('player1', '../assets/roles/alpaca.png'); this.load.audio('music1', '../assets/music/crrect_answer3.mp3'); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h2"},{"title":"🎮 基本語法(二) - 圖片","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day4","content":"","keywords":"","version":"Next"},{"title":"今天來把背景與角色顯示出來吧​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#今天來把背景與角色顯示出來吧","content":"","version":"Next","tagName":"h2"},{"title":"基本 phaser.js 功能 - 生成物件​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#基本-phaserjs-功能---生成物件","content":"","version":"Next","tagName":"h2"},{"title":"使用 create​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#使用-create","content":"","version":"Next","tagName":"h2"},{"title":"1. 先到 config 綁定事件​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#1-先到-config-綁定事件","content":"// 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, create: create, }, };  ","version":"Next","tagName":"h3"},{"title":"2. create() 就與 create 的事件綁訂了​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#2-create-就與-create-的事件綁訂了","content":"function create() { // 載入素材 }  ","version":"Next","tagName":"h3"},{"title":"建立背景圖​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#建立背景圖","content":"","version":"Next","tagName":"h2"},{"title":"1. 放入圖片​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#1-放入圖片","content":"","version":"Next","tagName":"h3"},{"title":"2. sprite(0, 0, \"bg1\") 參數分別為 (x, y, 圖片 key)​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#2-sprite0-0-bg1-參數分別為-x-y-圖片-key","content":" let bg = this.add.sprite(0, 0, &quot;bg1&quot;);  ","version":"Next","tagName":"h3"},{"title":"3. !! 圖片預設都以中心點來做定位 !!​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#3--圖片預設都以中心點來做定位-","content":"","version":"Next","tagName":"h3"},{"title":"4. 因此我們可以計算畫布的中心點來當背景的中心點​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#4-因此我們可以計算畫布的中心點來當背景的中心點","content":"","version":"Next","tagName":"h3"},{"title":"5. / 2 來計算畫布的正中心​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#5--2-來計算畫布的正中心","content":" //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2;  ","version":"Next","tagName":"h3"},{"title":"6. 將背景擺至畫布的正中心​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#6-將背景擺至畫布的正中心","content":" //設定位置 bg.setPosition(width, height);  ","version":"Next","tagName":"h3"},{"title":"置入角色​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#置入角色","content":"放入圖片直接把角色置入指定位置這邊我們使用 this.player 方便日後控制角色使用sprite(0, 0, &quot;bg1&quot;) 參數分別為 (x, y, 圖片 key)這邊把 x, y 分別設定成 450, 85 讓草泥馬站在山上 this.player = this.add.sprite(450, 105, &quot;player1&quot;);  ","version":"Next","tagName":"h2"},{"title":"播放音樂​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#播放音樂","content":"建立音樂檔物件音樂屬性 volume -&gt; 音量loop -&gt; 是否輪播 this.music = this.sound.add(&quot;music1&quot;, { volume: 0.2, //音量 loop: true, // 是否輪播 }); this.music.play();  ","version":"Next","tagName":"h2"},{"title":"今天終於完成仰望大地的草泥馬了，敬請期待明天的內容​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#今天終於完成仰望大地的草泥馬了敬請期待明天的內容","content":" ","version":"Next","tagName":"h2"},{"title":"程式原碼​","type":1,"pageTitle":"🎮 基本語法(二) - 圖片","url":"/en/docs/phaserJs/day4#程式原碼","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day4&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new Phaser.Scene('Game'); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, create: create } } //啟動遊戲 let game = new Phaser.Game(config) //載入素材 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image('bg1', '../assets/backgrounds/bg_1.webp'); this.load.image('player1', '../assets/roles/alpaca.png'); this.load.audio('music1', '../assets/music/crrect_answer3.mp3'); } //生成物件 function create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 音樂 this.music = this.sound.add('music1', { volume: 0.2, //音量 loop: true // 是否輪播 }); this.music.play(); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h2"},{"title":"🎮 基本語法(三) - 圖片串聯","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day5","content":"","keywords":"","version":"Next"},{"title":"今天就來讓圖片動起來吧​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#今天就來讓圖片動起來吧","content":"首先我們今天會新增一個行星的物件可以參考前幾篇來置入行星這邊就不再多做贅述  //載入素材 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;planet1&quot;, &quot;../assets/backgrounds/planet.png&quot;); // 行星 this.load.image(&quot;player1&quot;, &quot;../assets/roles/alpaca.png&quot;); this.load.image(&quot;player2&quot;, &quot;../assets/roles/pinkAlpaca.png&quot;); this.load.audio(&quot;music1&quot;, &quot;../assets/music/crrect_answer3.mp3&quot;); } //生成物件 function create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 行星 this.planet1 = this.add.sprite(-100, 40, &quot;planet1&quot;); // 4. 音樂 this.music = this.sound.add(&quot;music1&quot;, { volume: 0.2, //音量 loop: true, // 是否輪播 }); this.music.play(); }  ","version":"Next","tagName":"h2"},{"title":"基本 phaser.js 功能 - 初始化​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#基本-phaserjs-功能---初始化","content":"","version":"Next","tagName":"h2"},{"title":"使用 init​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#使用-init","content":"","version":"Next","tagName":"h3"},{"title":"1. 先到 config 綁定事件​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#1-先到-config-綁定事件","content":"// 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, create: create, init: init, }, };  ","version":"Next","tagName":"h3"},{"title":"2. init() 就與 init 的事件綁定了​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#2-init-就與-init-的事件綁定了","content":"function init() { // 載入素材 }  ","version":"Next","tagName":"h3"},{"title":"初始化物件​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#初始化物件","content":"","version":"Next","tagName":"h2"},{"title":"1. 加入行星的移動速度 - 我們等等要讓行星移動起來​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#1-加入行星的移動速度---我們等等要讓行星移動起來","content":"// 初始化 function init() { // 設定 行星 的速度 this.planet1Speed = 3; }  ","version":"Next","tagName":"h3"},{"title":"2. 草泥馬陣列 - 這是為了讓草泥馬變身準備的​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#2-草泥馬陣列---這是為了讓草泥馬變身準備的","content":"// 初始化 function init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = [&quot;player1&quot;, &quot;player2&quot;]; }  ","version":"Next","tagName":"h3"},{"title":"3. 計算時間軸 - 用來土炮時間軸變化使用的，稍後的文章會說明用途​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#3-計算時間軸---用來土炮時間軸變化使用的稍後的文章會說明用途","content":"// 初始化 function init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = [&quot;player1&quot;, &quot;player2&quot;]; //計算時間軸 this.index = 0; }  ","version":"Next","tagName":"h3"},{"title":"基本 phaser.js 功能 - 畫面更新​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#基本-phaserjs-功能---畫面更新","content":"","version":"Next","tagName":"h2"},{"title":"使用 update​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#使用-update","content":"它屬於一個偵聽器預設每一幀是以毫秒為單位在做更新 ","version":"Next","tagName":"h2"},{"title":"1. 先到 config綁定事件​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#1-先到-config綁定事件","content":"// 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, create: create, init: init, update: update, }, };  ","version":"Next","tagName":"h3"},{"title":"2. init() 就與 init 的事件綁訂了​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#2-init-就與-init-的事件綁訂了","content":"function update() { // 監聽事件 }  ","version":"Next","tagName":"h3"},{"title":"更新畫面​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#更新畫面","content":"我們這邊先土炮用 this.index 來當時間基準點在 this.index 來到 50 之前，讓行星往右移動因此在需要對行星的 x 軸做增量 //更新畫面 function update() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; this.index++; }  接下來行星到定位後草泥馬要變身草泥馬變身到 this.index &lt; 200 時就完全變身這邊使用 setTexture 來切換圖片由於草泥馬圖片有兩張，我們就利用取餘運算子 %針對陣列 this.allPlayer 的 0,1 切換 //更新畫面 function update() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); this.index++; }  ","version":"Next","tagName":"h2"},{"title":"這樣就完成我們今天的 花好月圓，草泥馬大變身的 功能了​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#這樣就完成我們今天的-花好月圓草泥馬大變身的-功能了","content":" ","version":"Next","tagName":"h2"},{"title":"程式原碼​","type":1,"pageTitle":"🎮 基本語法(三) - 圖片串聯","url":"/en/docs/phaserJs/day5#程式原碼","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new Phaser.Scene('Game'); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, create: create, init: init, update: update } } //啟動遊戲 let game = new Phaser.Game(config) //載入素材 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image('bg1', '../assets/backgrounds/bg_1.webp'); this.load.image('planet1', '../assets/backgrounds/planet.png'); this.load.image('player1', '../assets/roles/alpaca.png'); this.load.image('player2', '../assets/roles/pinkAlpaca.png'); this.load.audio('music1', '../assets/music/crrect_answer3.mp3'); } //生成物件 function create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 行星 this.planet1 = this.add.sprite(-100, 40, &quot;planet1&quot;); // 4. 音樂 this.music = this.sound.add('music1', { volume: 0.2, //音量 loop: true // 是否輪播 }); this.music.play(); } // 初始化 function init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = ['player1', 'player2']; //計算時間軸 this.index = 0; } //更新畫面 function update() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); this.index++; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h2"},{"title":"🎮 基本語法(四) - 操作","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day6","content":"","keywords":"","version":"Next"},{"title":"今天開始要來操作畫面了​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#今天開始要來操作畫面了","content":"今天的任務是要讓變身後的草泥馬噴火因此要先放進噴火的物件，這次使用照片串流的方式之後還會有另一種動畫的使用方式         //載入素材 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;planet1&quot;, &quot;../assets/backgrounds/planet.png&quot;); this.load.image(&quot;player1&quot;, &quot;../assets/roles/alpaca.png&quot;); this.load.image(&quot;player2&quot;, &quot;../assets/roles/pinkAlpaca.png&quot;); this.load.audio(&quot;music1&quot;, &quot;../assets/music/crrect_answer3.mp3&quot;); //載入技能,使用迴圈載入 for (let i = 1; i &lt; 9; i++) { this.load.image(&quot;file&quot; + i, `../assets/skills/fire/file-${i}.png`); } } //生成物件 function create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 行星 this.planet1 = this.add.sprite(-100, 40, &quot;planet1&quot;); // 4. 音樂 this.music = this.sound.add(&quot;music1&quot;, { volume: 0.2, //音量 loop: true, // 是否輪播 }); this.music.play(); // 5. 技能 this.file = this.add.sprite(360, 65, &quot;file1&quot;); this.file.alpha = 0; //透明度設為0 }  ","version":"Next","tagName":"h2"},{"title":"初始化物件​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#初始化物件","content":"我們來初始化噴火的陣列 // 初始化 function init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = [&quot;player1&quot;, &quot;player2&quot;]; //計算時間軸 this.index = 0; //噴火 this.fileArr = [&quot;file1&quot;, &quot;file2&quot;, &quot;file3&quot;, &quot;file4&quot;, &quot;file5&quot;, &quot;file6&quot;, &quot;file7&quot;, &quot;file8&quot;]; }  ","version":"Next","tagName":"h3"},{"title":"基本 phaser.js 功能 - 點擊​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#基本-phaserjs-功能---點擊","content":"","version":"Next","tagName":"h2"},{"title":"使用 input.activePointer.isDown​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#使用-inputactivepointerisdown","content":"在滑鼠或手機畫面被按住時，他會是 true因此我們可以利用 update 一直更新的特性 ","version":"Next","tagName":"h2"},{"title":"1. 首先先做個判斷​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#1-首先先做個判斷","content":"判斷草泥馬變身後才能噴火 // 初始化 function init() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { console.log(&quot;草泥馬變身了!&quot;); } this.index++; }  ","version":"Next","tagName":"h3"},{"title":"2. 判斷是不是有被點擊​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#2-判斷是不是有被點擊","content":"使用 input.activePointer.isDown搭配 if 判斷式 // 初始化 function init() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { if (this.input.activePointer.isDown) { } else { } } this.index++; }  ","version":"Next","tagName":"h3"},{"title":"3. 顯示與不顯示物件​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#3-顯示與不顯示物件","content":"利用物件的透明度來讓它顯示與不顯示alpha 為透明度的屬性alpha = 0 表示全透明alpha = 100 表示不透明 // 初始化 function init() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { if (this.input.activePointer.isDown) { this.file.alpha = 100; //透明度設為100 } else { this.file.alpha = 0; //透明度設為0 } } this.index++; }  ","version":"Next","tagName":"h3"},{"title":"4. 噴火動畫​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#4-噴火動畫","content":"最後利用 update 一直更新的特性來切換圖片讓火焰動畫呈現 // 初始化 function init() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { if (this.input.activePointer.isDown) { this.file.alpha = 100; //透明度設為100 this.file.setTexture(this.fileArr[this.index % 8]); } else { this.file.alpha = 0; //透明度設為0 } } this.index++; }  ","version":"Next","tagName":"h3"},{"title":"以上就是今天的操作啦​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#以上就是今天的操作啦","content":" ","version":"Next","tagName":"h2"},{"title":"程式原碼​","type":1,"pageTitle":"🎮 基本語法(四) - 操作","url":"/en/docs/phaserJs/day6#程式原碼","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day6&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new Phaser.Scene('Game'); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 // 綁定宣告的場景 scene: { preload: preload, create: create, init: init, update: update } } //啟動遊戲 let game = new Phaser.Game(config) //載入素材 function preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image('bg1', '../assets/backgrounds/bg_1.webp'); this.load.image('planet1', '../assets/backgrounds/planet.png'); this.load.image('player1', '../assets/roles/alpaca.png'); this.load.image('player2', '../assets/roles/pinkAlpaca.png'); this.load.audio('music1', '../assets/music/crrect_answer3.mp3'); //載入技能,使用迴圈載入 for (let i = 1; i &lt; 9; i++) { this.load.image(&quot;file&quot; + i, `../assets/skills/fire/file-${i}.png`); } } //生成物件 function create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 行星 this.planet1 = this.add.sprite(-100, 40, &quot;planet1&quot;); // 4. 音樂 this.music = this.sound.add('music1', { volume: 0.2, //音量 loop: true // 是否輪播 }); this.music.play(); // 5. 技能 this.file = this.add.sprite(360, 65, &quot;file1&quot;); this.file.alpha = 0; //透明度設為0 } // 初始化 function init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = ['player1', 'player2']; //計算時間軸 this.index = 0; //噴火 this.fileArr = ['file1', 'file2', 'file3', 'file4', 'file5', 'file6', 'file7', 'file8']; } function update() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { if (this.input.activePointer.isDown) { this.file.alpha = 100; //透明度設為100 this.file.setTexture(this.fileArr[this.index % 8]); } else { this.file.alpha = 0;//透明度設為0 } } this.index++; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h2"},{"title":"🎮 基本語法(五) - 場景切換","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day7","content":"","keywords":"","version":"Next"},{"title":"我們今天來將場景模組化，讓他隨時可以切換​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#我們今天來將場景模組化讓他隨時可以切換","content":"","version":"Next","tagName":"h2"},{"title":"使用 class 包裝場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#使用-class-包裝場景","content":"首先我們在與 index.html 同層建立 scenes 資料夾在資料夾中建立起始場景的檔案 gameStart.js並且繼承 Phaser.Scene class GameStart extends Phaser.Scene { // do something }  ","version":"Next","tagName":"h2"},{"title":"註冊場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#註冊場景","content":"","version":"Next","tagName":"h2"},{"title":"1. 利用 constructor 的 super() 註冊場景 Key​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#1-利用-constructor-的-super-註冊場景-key","content":"class GameStart extends Phaser.Scene { constructor() { super({ key: &quot;gameStart&quot; }); } // do something }  ","version":"Next","tagName":"h3"},{"title":"載入素材​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#載入素材","content":"由於繼承了 Phaser.Scene因此我們直接可以使用 preload()就可以載入素材了 class GameStart extends Phaser.Scene { constructor() { super({ key: &quot;gameStart&quot; }); } /** * 載入素材 */ preload() { this.load.image(&quot;bg&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;start1&quot;, &quot;../assets/others/start/start1.png&quot;); this.load.image(&quot;gameName&quot;, &quot;../assets/others/gameName/alpacaSceneName.png&quot;); } }  ","version":"Next","tagName":"h2"},{"title":"生成物件​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#生成物件","content":"跟 preload() 原理相同直接使用 create() 即可我們在這邊先載入背景跟遊戲標題 class GameStart extends Phaser.Scene { constructor() { super({ key: &quot;gameStart&quot; }); } /** * 載入素材 */ preload() { this.load.image(&quot;bg&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;start1&quot;, &quot;../assets/others/start/start1.png&quot;); this.load.image(&quot;gameName&quot;, &quot;../assets/others/gameName/alpacaSceneName.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 遊戲標題 let gameName = this.add.sprite(width, height - 50, &quot;gameName&quot;, 0); } }  ","version":"Next","tagName":"h2"},{"title":"點擊事件​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#點擊事件","content":"接下來我們要做遊戲開始按鈕因此需要對按鈕物件下 setInteractive() 表示他可以跟玩家互動並且加上一個 pointerdown 的事件只有手機或滑鼠點擊他都會被觸發 class GameStart extends Phaser.Scene { constructor() { super({ key: &quot;gameStart&quot; }); } /** * 載入素材 */ preload() { this.load.image(&quot;bg&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;start1&quot;, &quot;../assets/others/start/start1.png&quot;); this.load.image(&quot;gameName&quot;, &quot;../assets/others/gameName/alpacaSceneName.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 遊戲標題 let gameName = this.add.sprite(width, height - 50, &quot;gameName&quot;, 0); // 3. 開始按鈕 this.start1 = this.add.sprite(width, height + 50, &quot;start1&quot;, 0).setInteractive(); this.start1.on(&quot;pointerdown&quot;, () =&gt; { console.log(&quot;我被點了!&quot;); }); } }  ","version":"Next","tagName":"h2"},{"title":"加入第二場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#加入第二場景","content":"第二場景是將 day6 的 js 分離出來，因此這邊不在做詳細的描述先在 scenes 資料夾中建加入場景的檔案 alpacaScene.js並放入以下程式碼 class AlpacaScene extends Phaser.Scene { constructor() { super({ key: &quot;alpacaScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;planet1&quot;, &quot;../assets/backgrounds/planet.png&quot;); this.load.image(&quot;player1&quot;, &quot;../assets/roles/alpaca.png&quot;); this.load.image(&quot;player2&quot;, &quot;../assets/roles/pinkAlpaca.png&quot;); this.load.audio(&quot;music1&quot;, &quot;../assets/music/crrect_answer3.mp3&quot;); //載入技能,使用迴圈載入 for (let i = 1; i &lt; 9; i++) { this.load.image(&quot;file&quot; + i, `../assets/skills/fire/file-${i}.png`); } } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 行星 this.planet1 = this.add.sprite(-100, 40, &quot;planet1&quot;); // 4. 音樂 this.music = this.sound.add(&quot;music1&quot;, { volume: 0.2, //音量 loop: true, // 是否輪播 }); this.music.play(); // 5. 技能 this.file = this.add.sprite(360, 65, &quot;file1&quot;); this.file.alpha = 0; //透明度設為0 } /** * 初始化 */ init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = [&quot;player1&quot;, &quot;player2&quot;]; //計算時間軸 this.index = 0; //噴火 this.fileArr = [&quot;file1&quot;, &quot;file2&quot;, &quot;file3&quot;, &quot;file4&quot;, &quot;file5&quot;, &quot;file6&quot;, &quot;file7&quot;, &quot;file8&quot;]; } /** * 更新畫面 */ update() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { if (this.input.activePointer.isDown) { this.file.alpha = 100; //透明度設為100 this.file.setTexture(this.fileArr[this.index % 8]); } else { this.file.alpha = 0; //透明度設為0 } } this.index++; } }  ","version":"Next","tagName":"h2"},{"title":"將場景加入遊戲中​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#將場景加入遊戲中","content":"我們將焦點移回 index.html 中首先要先引用剛剛建立的兩個場景 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/gameStart.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/alpacaScene.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;  ","version":"Next","tagName":"h2"},{"title":"宣告場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#宣告場景","content":"因為剛剛已經將場景包裝成 class因此我們這邊使用 new 關鍵字來實例化它 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/gameStart.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/alpacaScene.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new AlpacaScene(); let sceneStart = new GameStart(); &lt;/script&gt; &lt;/body&gt;  ","version":"Next","tagName":"h3"},{"title":"加入遊戲基本設定與場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#加入遊戲基本設定與場景","content":"先新增一個遊戲接下來在新增場景最後啟動場景 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/gameStart.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/alpacaScene.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new AlpacaScene(); let sceneStart = new GameStart(); // 宣告遊戲的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 }; //啟動遊戲 let game = new Phaser.Game(config); //加載場景 game.scene.add(&quot;gameStart&quot;, sceneStart); game.scene.add(&quot;alpacaScene&quot;, scene); //啟動場景 game.scene.start(&quot;gameStart&quot;); &lt;/script&gt; &lt;/body&gt;  ","version":"Next","tagName":"h2"},{"title":"場景切換​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#場景切換","content":"這時我們回到 gameStart.js加入一個場景跳轉( startGame() ) 的 function並且移除掉目前顯示的場景如果沒有移除場景會重疊最後在 pointerdown 事件中觸發它因為在 class 呼叫自己的 function 因此這邊需要用 this /** * 起始場景 */ class GameStart extends Phaser.Scene { constructor() { super({ key: &quot;gameStart&quot; }); } /** * 載入素材 */ preload() { this.load.image(&quot;bg&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;start1&quot;, &quot;../assets/others/start/start1.png&quot;); this.load.image(&quot;gameName&quot;, &quot;../assets/others/gameName/alpacaSceneName.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 遊戲標題 let gameName = this.add.sprite(width, height - 50, &quot;gameName&quot;, 0); // 3. 開始按鈕 this.start1 = this.add.sprite(width, height + 50, &quot;start1&quot;, 0).setInteractive(); this.start1.on(&quot;pointerdown&quot;, () =&gt; { this.startGame(); }); } /** * 場景跳轉 */ startGame() { game.scene.start(&quot;alpacaScene&quot;); game.scene.remove(&quot;gameStart&quot;); } }  ","version":"Next","tagName":"h2"},{"title":"今天我們學到了如何利用 JS 的 class 來模組化場景，並且如何去切換它，明天我們來練習物件的複製吧​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#今天我們學到了如何利用-js-的-class-來模組化場景並且如何去切換它明天我們來練習物件的複製吧","content":" ","version":"Next","tagName":"h2"},{"title":"程式原碼​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#程式原碼","content":"","version":"Next","tagName":"h2"},{"title":"AlpacaScene 場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#alpacascene-場景","content":"class AlpacaScene extends Phaser.Scene { constructor() { super({ key: &quot;alpacaScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;planet1&quot;, &quot;../assets/backgrounds/planet.png&quot;); this.load.image(&quot;player1&quot;, &quot;../assets/roles/alpaca.png&quot;); this.load.image(&quot;player2&quot;, &quot;../assets/roles/pinkAlpaca.png&quot;); this.load.audio(&quot;music1&quot;, &quot;../assets/music/crrect_answer3.mp3&quot;); //載入技能,使用迴圈載入 for (let i = 1; i &lt; 9; i++) { this.load.image(&quot;file&quot; + i, `../assets/skills/fire/file-${i}.png`); } } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 角色 this.player = this.add.sprite(450, 105, &quot;player1&quot;); // 3. 行星 this.planet1 = this.add.sprite(-100, 40, &quot;planet1&quot;); // 4. 音樂 this.music = this.sound.add(&quot;music1&quot;, { volume: 0.2, //音量 loop: true, // 是否輪播 }); this.music.play(); // 5. 技能 this.file = this.add.sprite(360, 65, &quot;file1&quot;); this.file.alpha = 0; //透明度設為0 } /** * 初始化 */ init() { // 設定 行星 的速度 this.planet1Speed = 3; //草泥馬陣列 this.allPlayer = [&quot;player1&quot;, &quot;player2&quot;]; //計算時間軸 this.index = 0; //噴火 this.fileArr = [&quot;file1&quot;, &quot;file2&quot;, &quot;file3&quot;, &quot;file4&quot;, &quot;file5&quot;, &quot;file6&quot;, &quot;file7&quot;, &quot;file8&quot;]; } /** * 更新畫面 */ update() { // 行星出現 if (this.index &lt; 50) this.planet1.x += this.planet1Speed; //草泥馬變身 if (this.index % 5 === 0 &amp;&amp; this.index &gt; 80 &amp;&amp; this.index &lt; 200) this.player.setTexture(this.allPlayer[this.index % 2]); //草尼馬噴火 if (this.index &gt; 200) { if (this.input.activePointer.isDown) { this.file.alpha = 100; //透明度設為100 this.file.setTexture(this.fileArr[this.index % 8]); } else { this.file.alpha = 0; //透明度設為0 } } this.index++; } }  ","version":"Next","tagName":"h3"},{"title":"GameStart 場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#gamestart-場景","content":"/** * 起始場景 */ class GameStart extends Phaser.Scene { constructor() { super({ key: &quot;gameStart&quot; }); } /** * 載入素材 */ preload() { this.load.image(&quot;bg&quot;, &quot;../assets/backgrounds/bg_1.webp&quot;); this.load.image(&quot;start1&quot;, &quot;../assets/others/start/start1.png&quot;); this.load.image(&quot;gameName&quot;, &quot;../assets/others/gameName/alpacaSceneName.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 遊戲標題 let gameName = this.add.sprite(width, height - 50, &quot;gameName&quot;, 0); // 3. 開始按鈕 this.start1 = this.add.sprite(width, height + 50, &quot;start1&quot;, 0).setInteractive(); this.start1.on(&quot;pointerdown&quot;, () =&gt; { this.startGame(); }); } /** * 場景跳轉 */ startGame() { game.scene.start(&quot;alpacaScene&quot;); game.scene.remove(&quot;gameStart&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"主程式 場景​","type":1,"pageTitle":"🎮 基本語法(五) - 場景切換","url":"/en/docs/phaserJs/day7#主程式-場景","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day7&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/gameStart.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/alpacaScene.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new AlpacaScene(); let sceneStart = new GameStart(); // 宣告遊戲的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 } //啟動遊戲 let game = new Phaser.Game(config) //加載場景 game.scene.add('gameStart', sceneStart); game.scene.add('alpacaScene', scene); //啟動場景 game.scene.start('gameStart'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h3"},{"title":"🎮 基本語法(六) - 群組化物件","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day8","content":"","keywords":"","version":"Next"},{"title":"遊戲裡面肯定會遇到很多一模一樣的背景裝飾，每次都要寫一堆重複的設定太麻煩了，因此我們今天就來將物件群組化​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#遊戲裡面肯定會遇到很多一模一樣的背景裝飾每次都要寫一堆重複的設定太麻煩了因此我們今天就來將物件群組化","content":"","version":"Next","tagName":"h2"},{"title":"我們今天就來讓沙漠中長滿草吧​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#我們今天就來讓沙漠中長滿草吧","content":"","version":"Next","tagName":"h3"},{"title":"先載入沙漠背景與草皮​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#先載入沙漠背景與草皮","content":" class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入草皮 this.load.image(&quot;grass&quot;, &quot;../assets/others/Grass.png&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"接下來就是大家熟悉的建立背景​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#接下來就是大家熟悉的建立背景","content":"class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入草皮 this.load.image(&quot;grass&quot;, &quot;../assets/others/Grass.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); } }  ","version":"Next","tagName":"h3"},{"title":"接下來進入建立草皮群組環節​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#接下來進入建立草皮群組環節","content":"首先我們使用 this.add.group 來對場景加入群組接下來設定群組的參數 設定群組的唯一值 key: &quot;grass&quot;複製多少物件 repeat: 10, //種十撮 再來就是設定物件的起始點還有規則 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入草皮 this.load.image(&quot;grass&quot;, &quot;../assets/others/Grass.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 建立草皮群組 // 一次長十撮 this.grassland = this.add.group({ key: &quot;grass&quot;, repeat: 10, //種十撮 setXY: { x: 10, // 從 X 10 開始 y: 250, // 從 Y 250 開始 stepX: 55, // 每間隔10種一撮 stepY: 0, }, }); } }  ","version":"Next","tagName":"h3"},{"title":"因為沙漠太熱了，所以草要集體縮水​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#因為沙漠太熱了所以草要集體縮水","content":"首先可以先取得群組內的所有物件 getChildren()此時我們就可以使用 forEach 迴圈來同時改變群組內的所有物件放大縮小我們使用 setScale() 來處理 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入草皮 this.load.image(&quot;grass&quot;, &quot;../assets/others/Grass.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 建立草皮群組 // 一次長十撮 this.grassland = this.add.group({ key: &quot;grass&quot;, repeat: 10, //種十撮 setXY: { x: 10, // 從 X 10 開始 y: 250, // 從 Y 250 開始 stepX: 55, // 每間隔10種一撮 stepY: 0, }, }); // 一次修改 this.grassland.getChildren().forEach((item) =&gt; { item.setScale(0.5); }); } }  ","version":"Next","tagName":"h3"},{"title":"今天我們學會了大量複製場景中的物件了，大家可以試著在沙漠裡撲滿更多的草​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#今天我們學會了大量複製場景中的物件了大家可以試著在沙漠裡撲滿更多的草","content":" ","version":"Next","tagName":"h3"},{"title":"遊戲場景​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#遊戲場景","content":"class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入草皮 this.load.image(&quot;grass&quot;, &quot;../assets/others/Grass.png&quot;); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 建立草皮群組 // 一次長十撮 this.grassland = this.add.group({ key: &quot;grass&quot;, repeat: 10, //種十撮 setXY: { x: 10, // 從 X 10 開始 y: 250, // 從 Y 250 開始 stepX: 55, // 每間隔10種一撮 stepY: 0, }, }); // 一次修改 this.grassland.getChildren().forEach((item) =&gt; { item.setScale(0.5); }); } }  ","version":"Next","tagName":"h3"},{"title":"主程式​","type":1,"pageTitle":"🎮 基本語法(六) - 群組化物件","url":"/en/docs/phaserJs/day8#主程式","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day8&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/gameScene.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new GameScene(); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 } //啟動遊戲 let game = new Phaser.Game(config) //加載場景 game.scene.add('gameScene', scene); //啟動場景 game.scene.start('gameScene'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h3"},{"title":"🎮 基本語法(七) - 動畫","type":0,"sectionRef":"#","url":"/en/docs/phaserJs/day9","content":"","keywords":"","version":"Next"},{"title":"我們之前是用土炮的方式來切換圖片，達到動畫效果，今天我們來用比較正規得方式來做動畫​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#我們之前是用土炮的方式來切換圖片達到動畫效果今天我們來用比較正規得方式來做動畫","content":"","version":"Next","tagName":"h2"},{"title":"今天的動畫是要讓雞在沙漠走來走去​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#今天的動畫是要讓雞在沙漠走來走去","content":"先載入雞與背景的圖片 我們這邊使用 spritesheet 來設定每一偵的寬高 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入雞動畫 this.load.spritesheet(&quot;chicken&quot;, &quot;../assets/roles/chickenGo.png&quot;, { frameWidth: 32, frameHeight: 32, }); } }  ","version":"Next","tagName":"h3"},{"title":"接下接下來需要設定雞的圖片應該從第幾偵開始​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#接下接下來需要設定雞的圖片應該從第幾偵開始","content":"我們這邊多給一個參數表示從第 12 格開始 this.add.sprite(50, 200, &quot;chicken&quot;, 12)並且把雞放大 1.5 倍 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入雞動畫 this.load.spritesheet(&quot;chicken&quot;, &quot;../assets/roles/chickenGo.png&quot;, { frameWidth: 32, frameHeight: 32, }); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 雞 this.chicken = this.add.sprite(50, 200, &quot;chicken&quot;, 12); // 把雞放大 1.5 倍 this.chicken.setScale(1.5); } }  ","version":"Next","tagName":"h3"},{"title":"建立動畫​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#建立動畫","content":"這邊使用 this.anims.create 來建立動畫start end ，表示動畫應該從哪格開始與結束我們分別建立一個向左走與向右走的動畫 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入雞動畫 this.load.spritesheet(&quot;chicken&quot;, &quot;../assets/roles/chickenGo.png&quot;, { frameWidth: 32, frameHeight: 32, }); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 雞 this.chicken = this.add.sprite(50, 200, &quot;chicken&quot;, 12); // 把雞放大 1.5 倍 this.chicken.setScale(1.5); // 建立雞向右走的動畫 this.anims.create({ key: &quot;chickenGoRight&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 12, end: 15, }), frameRate: 4, }); this.anims.create({ key: &quot;chickenGoLeft&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 4, end: 7, }), frameRate: 4, }); } }  ","version":"Next","tagName":"h3"},{"title":"播放動畫​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#播放動畫","content":"這時候我們想要點擊畫面雞就會出發點擊畫面會用到 this.input.activePointer.isDown接下來就是播放動畫了 this.chicken.anims.play(&quot;chickenGoRight&quot;, true)並且要幫雞的 x 軸 +1 他才會往右前進 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入雞動畫 this.load.spritesheet(&quot;chicken&quot;, &quot;../assets/roles/chickenGo.png&quot;, { frameWidth: 32, frameHeight: 32, }); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 雞 this.chicken = this.add.sprite(50, 200, &quot;chicken&quot;, 12); // 把雞放大 1.5 倍 this.chicken.setScale(1.5); // 建立雞向右走的動畫 this.anims.create({ key: &quot;chickenGoRight&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 12, end: 15, }), frameRate: 4, }); this.anims.create({ key: &quot;chickenGoLeft&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 4, end: 7, }), frameRate: 4, }); } update() { if (this.input.activePointer.isDown) { this.chicken.x += 1; this.chicken.anims.play(&quot;chickenGoRight&quot;, true); } } }  ","version":"Next","tagName":"h3"},{"title":"讓雞回家​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#讓雞回家","content":"現在一直點著螢幕，雞就會離家出走跑出螢幕外就回不了家了因此我們加一個變數，來判斷雞是不是該回家了並且偵測機是不是走到世界的盡頭，是的話就讓他回頭 class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入雞動畫 this.load.spritesheet(&quot;chicken&quot;, &quot;../assets/roles/chickenGo.png&quot;, { frameWidth: 32, frameHeight: 32, }); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 雞 this.chicken = this.add.sprite(50, 200, &quot;chicken&quot;, 12); // 把雞放大 1.5 倍 this.chicken.setScale(1.5); // 建立雞向右走的動畫 this.anims.create({ key: &quot;chickenGoRight&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 12, end: 15, }), frameRate: 4, }); this.anims.create({ key: &quot;chickenGoLeft&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 4, end: 7, }), frameRate: 4, }); } #isChickenGoHome = false; update() { // 雞沒有再回家才能走 if (this.input.activePointer.isDown) { if (this.#isChickenGoHome === false) { this.chicken.x += 1; this.chicken.anims.play(&quot;chickenGoRight&quot;, true); } else { this.chicken.x -= 1; this.chicken.anims.play(&quot;chickenGoLeft&quot;, true); } } // 如果雞超過場景就讓他跑回家 if (this.chicken.x &gt;= this.sys.game.config.width) { this.#isChickenGoHome = true; } else if (this.chicken.x &lt;= 0) { this.#isChickenGoHome = false; } } }  ","version":"Next","tagName":"h3"},{"title":"此時此刻的雞，就會乖乖散步也不會離家出走了，我們明天再來監視這隻雞確保他不會亂跑​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#此時此刻的雞就會乖乖散步也不會離家出走了我們明天再來監視這隻雞確保他不會亂跑","content":" ","version":"Next","tagName":"h3"},{"title":"遊戲場景​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#遊戲場景","content":"class GameScene extends Phaser.Scene { constructor() { super({ key: &quot;gameScene&quot; }); } /** * 載入素材 */ preload() { // 載入素材 // bg1 -&gt; 圖片載入後的物件名稱(key) this.load.image(&quot;bg1&quot;, &quot;../assets/backgrounds/desert.webp&quot;); // 載入雞動畫 this.load.spritesheet(&quot;chicken&quot;, &quot;../assets/roles/chickenGo.png&quot;, { frameWidth: 32, frameHeight: 32, }); } /** * 生成物件 */ create() { // 1. 背景 let bg = this.add.sprite(0, 0, &quot;bg1&quot;); //取得寬高 let width = this.sys.game.config.width / 2; let height = this.sys.game.config.height / 2; //設定位置 bg.setPosition(width, height); // 2. 雞 this.chicken = this.add.sprite(50, 200, &quot;chicken&quot;, 12); // 把雞放大 1.5 倍 this.chicken.setScale(1.5); // 建立雞向右走的動畫 this.anims.create({ key: &quot;chickenGoRight&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 12, end: 15, }), frameRate: 4, }); this.anims.create({ key: &quot;chickenGoLeft&quot;, frames: this.anims.generateFrameNumbers(&quot;chicken&quot;, { start: 4, end: 7, }), frameRate: 4, }); } #isChickenGoHome = false; update() { // 雞沒有再回家才能走 if (this.input.activePointer.isDown) { if (this.#isChickenGoHome === false) { this.chicken.x += 1; this.chicken.anims.play(&quot;chickenGoRight&quot;, true); } else { this.chicken.x -= 1; this.chicken.anims.play(&quot;chickenGoLeft&quot;, true); } } // 如果雞超過場景就讓他跑回家 if (this.chicken.x &gt;= this.sys.game.config.width) { this.#isChickenGoHome = true; } else if (this.chicken.x &lt;= 0) { this.#isChickenGoHome = false; } } }  ","version":"Next","tagName":"h3"},{"title":"主程式​","type":1,"pageTitle":"🎮 基本語法(七) - 動畫","url":"/en/docs/phaserJs/day9#主程式","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Game-day9&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../lib/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./scenes/gameScene.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 宣告一個場景 let scene = new GameScene(); // 宣告場景的基本資訊 let config = { type: Phaser.AUTO, width: 600, // 寬 height: 300, // 高 } //啟動遊戲 let game = new Phaser.Game(config) //加載場景 game.scene.add('gameScene', scene); //啟動場景 game.scene.start('gameScene'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","version":"Next","tagName":"h3"},{"title":"🔐 SSO 功能模組","type":0,"sectionRef":"#","url":"/en/docs/sso/appMpdel","content":"","keywords":"","version":"Next"},{"title":"關於 SSO 功能模組​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#關於-sso-功能模組","content":"單一登錄（Single Sign-On，簡稱SSO）功能模組是一個用於身份驗證和授權的關鍵組件，旨在提供用戶在多個應用程式之間的無縫身份驗證體驗，它通過一次登錄，用戶可以訪問多個相關的應用程式，而無需多次輸入他們的認證信息 這個模組的主要目標是增加安全性和便利性，同時降低管理多個應用程式的身份驗證和授權的複雜性，它包含多個子模組，每個子模組負責不同方面的功能，如用戶管理、會話管理、日誌記錄等等 我們將在以下部分詳細探討每個子模組的功能和操作，這個SSO功能模組旨在幫助開發者輕鬆實現強大的單一登錄體驗，同時確保安全性和可擴展性 ","version":"Next","tagName":"h2"},{"title":"模組拆分​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#模組拆分","content":"","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#authentication","content":"使用者註冊 (User Registration)使用者登錄 (User Login)生成和驗證 Token管理使用者會話 (Session Management) ","version":"Next","tagName":"h3"},{"title":"User Management​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#user-management","content":"使用者新增、編輯和刪除更改密碼和密碼重置更新使用者狀態 ","version":"Next","tagName":"h3"},{"title":"Application​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#application","content":"應用程式模組 新增和管理應用程式設置應用程式的回調 URL ","version":"Next","tagName":"h3"},{"title":"User-App Mapping​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#user-app-mapping","content":"使用者和應用程式關聯模組 使用者與應用程式的關聯管理 ","version":"Next","tagName":"h3"},{"title":"Log​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#log","content":"日誌模組 記錄使用者操作檢索和顯示操作日誌 ","version":"Next","tagName":"h3"},{"title":"Permission and Role​","type":1,"pageTitle":"🔐 SSO 功能模組","url":"/en/docs/sso/appMpdel#permission-and-role","content":"許可權和角色模組 新增、編輯和刪除角色定義、分配和管理許可權管理使用者角色 ","version":"Next","tagName":"h3"},{"title":"🔐 SSO 建立專案","type":0,"sectionRef":"#","url":"/en/docs/sso/createProject","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🔐 SSO 建立專案","url":"/en/docs/sso/createProject#環境","content":"TSNestJS ","version":"Next","tagName":"h2"},{"title":"建立專案​","type":1,"pageTitle":"🔐 SSO 建立專案","url":"/en/docs/sso/createProject#建立專案","content":"","version":"Next","tagName":"h2"},{"title":"建立​","type":1,"pageTitle":"🔐 SSO 建立專案","url":"/en/docs/sso/createProject#建立","content":"nest new sso  ⚡ We will scaffold your app in a few seconds.. ? Which package manager would you ❤️ to use?  ","version":"Next","tagName":"h3"},{"title":"選擇 yarn​","type":1,"pageTitle":"🔐 SSO 建立專案","url":"/en/docs/sso/createProject#選擇-yarn","content":"? Which package manager would you ❤️ to use? yarn CREATE sso/.eslintrc.js (663 bytes) CREATE sso/.prettierrc (51 bytes) CREATE sso/nest-cli.json (171 bytes) CREATE sso/package.json (1934 bytes) CREATE sso/README.md (3347 bytes) CREATE sso/tsconfig.build.json (97 bytes) CREATE sso/tsconfig.json (546 bytes) CREATE sso/src/app.controller.spec.ts (617 bytes) CREATE sso/src/app.controller.ts (274 bytes) CREATE sso/src/app.module.ts (249 bytes) CREATE sso/src/app.service.ts (142 bytes) CREATE sso/src/main.ts (208 bytes) CREATE sso/test/app.e2e-spec.ts (630 bytes) CREATE sso/test/jest-e2e.json (183 bytes) ✔ Installation in progress... ☕ 🚀 Successfully created project sso 👉 Get started with the following commands: $ cd sso $ yarn run start  ","version":"Next","tagName":"h3"},{"title":"設定 port​","type":1,"pageTitle":"🔐 SSO 建立專案","url":"/en/docs/sso/createProject#設定-port","content":"於檔案 src/main.ts import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3050); } bootstrap();  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🔐 SSO 建立專案","url":"/en/docs/sso/createProject#啟動","content":"根據說明的指令啟動 cd sso yarn run start  $ nest start [Nest] 81256 - 2023/09/07 下午10:28:15 LOG [NestFactory] Starting Nest application... [Nest] 81256 - 2023/09/07 下午10:28:15 LOG [InstanceLoader] AppModule dependencies initialized +13ms [Nest] 81256 - 2023/09/07 下午10:28:16 LOG [RoutesResolver] AppController {/}: +72ms [Nest] 81256 - 2023/09/07 下午10:28:16 LOG [RouterExplorer] Mapped {/, GET} route +2ms [Nest] 81256 - 2023/09/07 下午10:28:16 LOG [NestApplication] Nest application successfully started +3ms  啟動後開啟網站 Hello World!  github 連結 ","version":"Next","tagName":"h3"},{"title":"🔐 SSO 資料庫","type":0,"sectionRef":"#","url":"/en/docs/sso/database","content":"","keywords":"","version":"Next"},{"title":"何謂 SSO​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#何謂-sso","content":"單點登錄（Single Sign-On，SSO）是一種身份驗證機制，允許使用者使用一組憑證（通常是使用者名稱和密碼）登錄到多個不同的應用程式或服務，而無需為每個應用程式輸入憑證 ","version":"Next","tagName":"h2"},{"title":"資料庫​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#資料庫","content":"","version":"Next","tagName":"h2"},{"title":"資料庫設計考量​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#資料庫設計考量","content":"SSO系統通常需要一些資料庫表格來存儲使用者資訊、令牌和相關的身份驗證數據以下是一些常見的表格，這些表格可以用於實現SSO ","version":"Next","tagName":"h3"},{"title":"1. User Table（使用者表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#1-user-table使用者表格","content":"存儲使用者的基本資訊，如使用者名稱、密碼雜湊、電子郵件地址、使用者ID等這是SSO系統中最基本的表格 CREATE TABLE user_table ( user_id serial PRIMARY KEY, username VARCHAR(50) NOT NULL, password_hash VARCHAR(100) NOT NULL, email VARCHAR(100), status BOOLEAN );  ","version":"Next","tagName":"h3"},{"title":"2. Session Table（會話表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#2-session-table會話表格","content":"用於存儲使用者的會話資訊，包括會話ID、使用者ID、會話開始時間、過期時間等這些資訊用於追蹤使用者的登錄狀態 CREATE TABLE session_table ( session_id serial PRIMARY KEY, user_id INT NOT NULL, start_time TIMESTAMPTZ NOT NULL DEFAULT current_timestamp, expiration_time TIMESTAMPTZ NOT NULL DEFAULT current_timestamp + interval '1 hour', FOREIGN KEY (user_id) REFERENCES user_table (user_id) );  ","version":"Next","tagName":"h3"},{"title":"3. Token Table（令牌表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#3-token-table令牌表格","content":"用於存儲令牌資訊，令牌是用於身份驗證的臨時憑證表格包括令牌ID、使用者ID、令牌類型、令牌值、過期時間等 CREATE TABLE token_table ( token_id serial PRIMARY KEY, user_id INT NOT NULL, token_type VARCHAR(50) NOT NULL, token_value VARCHAR(255) NOT NULL, expiration_time TIMESTAMPTZ NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id) );  ","version":"Next","tagName":"h3"},{"title":"4. Application Table（應用程式表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#4-application-table應用程式表格","content":"存儲與SSO系統集成的各個應用程式或服務的資訊，包括應用程式ID、應用程式名稱、重定向URL等 CREATE TABLE application_table ( app_id serial PRIMARY KEY, app_name VARCHAR(100) NOT NULL UNIQUE, redirect_url VARCHAR(255) NOT NULL );  ","version":"Next","tagName":"h3"},{"title":"5. User-Application Mapping Table（使用者-應用程式映射表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#5-user-application-mapping-table使用者-應用程式映射表格","content":"用於將使用者與其有權訪問的應用程式關聯起來這個表格包括使用者ID和應用程式ID的關聯資訊 CREATE TABLE user_app_mapping ( mapping_id serial PRIMARY KEY, user_id INT NOT NULL, app_id INT NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id), FOREIGN KEY (app_id) REFERENCES application_table (app_id) );  ","version":"Next","tagName":"h3"},{"title":"6. Audit Log Table（審計日誌表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#6-audit-log-table審計日誌表格","content":"用於記錄與使用者登錄和身份驗證相關的活動，如成功登錄、失敗登錄嘗試、會話終止等 CREATE TABLE audit_log ( log_id serial PRIMARY KEY, user_id INT, action VARCHAR(100) NOT NULL, timestamp TIMESTAMPTZ NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id) );  ","version":"Next","tagName":"h3"},{"title":"7. Metadata Table（元數據表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#7-metadata-table元數據表格","content":"存儲與SSO配置相關的元數據，如令牌簽名金鑰、令牌有效期設置等 CREATE TABLE metadata_table ( metadata_id serial PRIMARY KEY, key VARCHAR(100) NOT NULL UNIQUE, value TEXT );  ","version":"Next","tagName":"h3"},{"title":"8. Role and Permissions Table（角色和權限表格）​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#8-role-and-permissions-table角色和權限表格","content":"如果SSO系統需要處理角色和權限，可以包括用於存儲角色和權限資訊的表格 CREATE TABLE role_table ( role_id serial PRIMARY KEY, role_name VARCHAR(50) NOT NULL ); CREATE TABLE permissions_table ( permission_id serial PRIMARY KEY, permission_name VARCHAR(100) NOT NULL UNIQUE ); CREATE TABLE user_role_mapping ( mapping_id serial PRIMARY KEY UNIQUE, user_id INT NOT NULL, role_id INT NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id), FOREIGN KEY (role_id) REFERENCES role_table (role_id) ); CREATE TABLE role_permission_mapping ( mapping_id serial PRIMARY KEY UNIQUE, role_id INT NOT NULL, permission_id INT NOT NULL, FOREIGN KEY (role_id) REFERENCES role_table (role_id), FOREIGN KEY (permission_id) REFERENCES permissions_table (permission_id) );   ","version":"Next","tagName":"h3"},{"title":"完整 SQL​","type":1,"pageTitle":"🔐 SSO 資料庫","url":"/en/docs/sso/database#完整-sql","content":"CREATE TABLE user_table ( user_id serial PRIMARY KEY, username VARCHAR(50) NOT NULL, password_hash VARCHAR(100) NOT NULL, email VARCHAR(100), status BOOLEAN ); CREATE TABLE session_table ( session_id serial PRIMARY KEY, user_id INT NOT NULL, start_time TIMESTAMPTZ NOT NULL DEFAULT current_timestamp, expiration_time TIMESTAMPTZ NOT NULL DEFAULT current_timestamp + interval '1 hour', FOREIGN KEY (user_id) REFERENCES user_table (user_id) ); CREATE TABLE token_table ( token_id serial PRIMARY KEY, user_id INT NOT NULL, token_type VARCHAR(50) NOT NULL, token_value VARCHAR(255) NOT NULL, expiration_time TIMESTAMPTZ NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id) ); CREATE TABLE application_table ( app_id serial PRIMARY KEY, app_name VARCHAR(100) NOT NULL UNIQUE, redirect_url VARCHAR(255) NOT NULL ); CREATE TABLE user_app_mapping ( mapping_id serial PRIMARY KEY, user_id INT NOT NULL, app_id INT NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id), FOREIGN KEY (app_id) REFERENCES application_table (app_id) ); CREATE TABLE audit_log ( log_id serial PRIMARY KEY, user_id INT, action VARCHAR(100) NOT NULL, timestamp TIMESTAMPTZ NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id) ); CREATE TABLE metadata_table ( metadata_id serial PRIMARY KEY, key VARCHAR(100) NOT NULL UNIQUE, value TEXT ); CREATE TABLE role_table ( role_id serial PRIMARY KEY, role_name VARCHAR(50) NOT NULL ); CREATE TABLE permissions_table ( permission_id serial PRIMARY KEY, permission_name VARCHAR(100) NOT NULL UNIQUE ); CREATE TABLE user_role_mapping ( mapping_id serial PRIMARY KEY UNIQUE, user_id INT NOT NULL, role_id INT NOT NULL, FOREIGN KEY (user_id) REFERENCES user_table (user_id), FOREIGN KEY (role_id) REFERENCES role_table (role_id) ); CREATE TABLE role_permission_mapping ( mapping_id serial PRIMARY KEY UNIQUE, role_id INT NOT NULL, permission_id INT NOT NULL, FOREIGN KEY (role_id) REFERENCES role_table (role_id), FOREIGN KEY (permission_id) REFERENCES permissions_table (permission_id) );  ","version":"Next","tagName":"h2"},{"title":"🔐 SSO 概觀","type":0,"sectionRef":"#","url":"/en/docs/sso/ssoOverView","content":"","keywords":"","version":"Next"},{"title":"關於 SSO​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#關於-sso","content":"SSO (Single Sign-On): 單點登入 是一種身份驗證和授權機制，允許使用者僅需一次登入，然後就能訪問多個相關的應用程式和服務，而無需再次輸入其認證資訊 SSO 提供了方便性和安全性，並提高了使用者體驗 ","version":"Next","tagName":"h2"},{"title":"SSO 適用場景​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#sso-適用場景","content":"單點登入可應用於各種情境，包括： 企業內部環境：在企業內部，使用者可以通過一個登入頁面訪問所有內部應用程式，而無需為每個應用程式都提供不同的認證多個網站或應用程式：當一個組織擁有多個網站或應用程式時，SSO 允許使用者在這些網站或應用程式之間共享相同的登入狀態，以方便他們的訪問雲端服務：SSO 適用於使用各種雲端服務的情境，例如電子郵件、文件共享、專案管理等使用者只需一次登入，即可訪問這些服務，而無需多次輸入密碼 SSO 提供了集中的身份驗證和授權，並減少了對多個登入認證的需求，同時提供了更好的安全性和管理性它簡化了使用者的登入體驗，同時有助於組織維護和監控訪問權限 ","version":"Next","tagName":"h2"},{"title":"傳統登入方式​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#傳統登入方式","content":"","version":"Next","tagName":"h2"},{"title":"傳統登入方式的角色​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#傳統登入方式的角色","content":"使用者：應用程序的使用者，希望進行登入瀏覽器：使用者使用的網頁瀏覽器，用於向後端伺服器發送請求和處理回應後端伺服器：應用程序的伺服器端，負責處理使用者的登入請求並進行身份驗證 ","version":"Next","tagName":"h3"},{"title":"傳統登入方式流程說明​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#傳統登入方式流程說明","content":"使用者開始登入過程，向後端伺服器發送登入請求後端伺服器接收登入請求後，開始驗證使用者提供的資訊驗證成功的情況下，後端伺服器向瀏覽器回應首次登入驗證成功的訊息瀏覽器接收到成功的回應後，執行以下操作： 儲存使用者資訊在 Session 中設定 Set-Cookie 欄位，寫入 SessionId 等資訊，設定過期時間，建立 Cookie瀏覽器保存Cookie資訊 當使用者進行後續請求時，瀏覽器會自動附加 Cookie 資訊到請求中後端伺服器接受後續請求，從請求標頭中取出 SessionId後端伺服器使用 SessionId 從伺服器 Session 中取得使用者資訊根據取得的使用者資訊，後端伺服器執行以下操作： 如果成功取得使用者資訊，則回應 已登入 的訊息給使用者如果未能成功取得使用者資訊，則回應 未登入 的訊息給使用者 如果在初始驗證階段驗證失敗，後端伺服器直接回應 登入驗證失敗 的訊息給使用者 ","version":"Next","tagName":"h3"},{"title":"傳統登入方式流程圖​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#傳統登入方式流程圖","content":"","version":"Next","tagName":"h3"},{"title":"傳統登入多系統的瓶頸​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#傳統登入多系統的瓶頸","content":"在單體的系統中，登入結合了 Cookie 與 Session 在多系統登入之下會有碰到兩個瓶頸 Session 無法共享Cookie 無法跨域 在多系統情況下，服務器端 Session 不共享，這意味著當用戶在不同系統之間切換時，他們的 Session 數據不會共享，這可能會導致登入狀態的丟失 ","version":"Next","tagName":"h3"},{"title":"解決 Session 無法共享​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#解決-session-無法共享","content":"有三種常見的方式來解決 Session 無法共享的問題 Session 拷貝： 當其中服務對 Session 中的資訊進行修改時，這些修改將同步給其他服務，以實現Session共享缺點：可能會增加伺服器端的壓力和可能的延遲 使用 Redis： 它具有高效的存儲和查詢能力，並支持數據持久化，不易丟失資料 使用 JWT（JSON Web Tokens）： 服務只需成功解析 JWT，就可以獲取使用者的資訊前端 Cookie 只需要存儲JWT，而不需要查詢服務的 Session ","version":"Next","tagName":"h3"},{"title":"SSO 原理​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#sso-原理","content":"","version":"Next","tagName":"h2"},{"title":"核心成員 - 應用系統​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#核心成員---應用系統","content":"應用系統（Application System）： 這是需要身份驗證的目標系統，用戶希望訪問的應用程式應用系統可能包括網站、應用程式或其他服務，並需要用戶通過 SSO 進行身份驗證，以確保只有授權的用戶可以訪問它 ","version":"Next","tagName":"h3"},{"title":"核心成員 - 客戶端​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#核心成員---客戶端","content":"SSO 客戶端（SSO Client）： SSO 客戶端負責處理用戶的登入和登出並與 SSO 服務端進行通信以驗證用戶的身份 ","version":"Next","tagName":"h3"},{"title":"核心成員 - 服務端​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#核心成員---服務端","content":"SSO 服務端（SSO Server）：通常包括以下子角色： 登入服務：負責處理用戶的身份驗證和生成 token（例如，JWT）以證明用戶的身份登入狀態服務：提供了驗證用戶的登入狀態和登入訊息查詢的服務退出服務：用戶注銷服務，允許用戶登出 SSO 系統 ","version":"Next","tagName":"h3"},{"title":"核心成員 - 資料庫​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#核心成員---資料庫","content":"資料庫（Database）： 這是用於存儲使用者資訊的地方 ","version":"Next","tagName":"h3"},{"title":"核心成員 - 快取​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#核心成員---快取","content":"快取（Cache）： 這是用於存儲用戶的登入訊息的系統，通常使用 Redis 或類似的快取存儲它用於提高性能，減少對數據庫的查詢，以驗證用戶的登入狀態 ","version":"Next","tagName":"h3"},{"title":"SSO 流程圖 - 登入​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#sso-流程圖---登入","content":"","version":"Next","tagName":"h3"},{"title":"SSO 流程圖 - 登入第二服務​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#sso-流程圖---登入第二服務","content":"","version":"Next","tagName":"h3"},{"title":"SSO 流程圖 - 登出​","type":1,"pageTitle":"🔐 SSO 概觀","url":"/en/docs/sso/ssoOverView#sso-流程圖---登出","content":" REF: 看完这篇你不能再说不懂SSO原理了！ ","version":"Next","tagName":"h3"},{"title":"🌍 WebGL 簡介","type":0,"sectionRef":"#","url":"/en/docs/threeJs/note1","content":"","keywords":"","version":"Next"},{"title":"1.1 何謂 WebGL​","type":1,"pageTitle":"🌍 WebGL 簡介","url":"/en/docs/threeJs/note1#11-何謂-webgl","content":"WebGL (Web Graphics Library) 是一種使用 JavaScript API可在瀏覽器中呈現 2D 或 3D 互動圖形的技術他是基於 OpenGL 組成可使用此連結確認設備是否有支援 WebGL &gt;&gt; 點我 ","version":"Next","tagName":"h2"},{"title":"1.2 WebGL 的設計​","type":1,"pageTitle":"🌍 WebGL 簡介","url":"/en/docs/threeJs/note1#12-webgl-的設計","content":"WebGL 的設計使用了 Html 的 Canvas，並提供自動記憶體管理。 ","version":"Next","tagName":"h2"},{"title":"1.3 WebGL 與 GPU​","type":1,"pageTitle":"🌍 WebGL 簡介","url":"/en/docs/threeJs/note1#13-webgl-與-gpu","content":"它在 GPU 上被分為兩個部分: 處理資料流 (stream of data)將第一部份的資料流畫成像素點 (pixels based) ","version":"Next","tagName":"h2"},{"title":"1.4 電腦影像概念​","type":1,"pageTitle":"🌍 WebGL 簡介","url":"/en/docs/threeJs/note1#14-電腦影像概念","content":"在電腦上，我們使用攝影機 (camera) 的概念來看世界。攝影機拍攝畫面並呈現給使用者。因此，我們可以透過調整攝影機、光線、材質等設定來呈現不同的視角。 ","version":"Next","tagName":"h2"},{"title":"1.5 Shader 簡介​","type":1,"pageTitle":"🌍 WebGL 簡介","url":"/en/docs/threeJs/note1#15-shader-簡介","content":"Shader 是一種程式它用於在 GPU 上渲染 3D 圖形通常會分為兩種: 頂點著色器 (vertex shader): 對每個頂點進行計算，例如轉換座標、計算光照和陰影等。片段著色器 (fragment shader): 對每個像素進行計算，例如計算顏色和紋理等。 Shader 是由開發者自定義的，可以使用 GLSL (OpenGL Shading Language) 等語言編寫。使用不同的 Shader 可以得到不同的圖形效果，例如鏡面反射、高光、陰影等。 ","version":"Next","tagName":"h2"},{"title":"📋 第一章 單元測試的基礎","type":0,"sectionRef":"#","url":"/en/docs/unitTest/note1","content":"","keywords":"","version":"Next"},{"title":"1.1 逐步定義單元測試​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#11-逐步定義單元測試","content":"單元測試:提高程式品質，更加理解類別與方法的功能需求工作單元:從呼叫公用方法到一個測試可見的最終結果，此過程稱之為工作單元定義: 一個單元測試示一段代碼(通常是一個方法或一個函數)，由此方法去呼叫另一段方法，然後檢驗某些假設的正確性，如果假設是錯誤，表示單元測試失敗主專案的程式稱為:被測試系統 (System Under Test SUT)，有的人喜歡稱為 CUT(Class Under Teat)測試最終結果的形式: 被呼叫的公共方法返回一個值(一個返回值不可為空的函數)方法被呼叫的前後，系統的狀態或行為有可見的變化，這種變化無須查詢私有狀態即可判斷(ex:一個以前不存在的用戶可以登入系統)呼叫一個不受控制的第三方系統，這個系統不會返回任何值，或返回值被忽略(ex:呼叫 log4Net，代碼不是你寫的，你也沒源碼) 單元測試最小可以小到一個方法，大可以包括實現某個功能或多個函數。 ","version":"Next","tagName":"h2"},{"title":"1.1.1 編寫優秀單元測試的重要性​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#111-編寫優秀單元測試的重要性","content":"要理解單元測試，光理解工作單元還不構如果編寫差勁的單元測試是沒意義的，還會造成日後維護的麻煩 ","version":"Next","tagName":"h3"},{"title":"1.1.2 我們都寫過單元測試​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#112-我們都寫過單元測試","content":"或許你曾經使用過控制台程序來調用一個類別或組件，來驗證最終結果是否能讓你確信代碼工作是正常的這些測試或許很有用，而且也很接近傳統的單元測試 ","version":"Next","tagName":"h3"},{"title":"1.2 優秀單元測試的特性​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#12-優秀單元測試的特性","content":"一個單元測試應具有以下特徵: 自動化，且可以重複執行很容易實現第二天還要有意義任何人都應該能一鍵運行他結果需要是穩定的(運行之前沒有進行任何修改的話，多次運行一個測試結果應該要是不變的)要能完全控制被測試的單元需要是完全隔離的(獨立於其他程式的運行)如果執行失敗，我們要很容易地知道什麼是期待的結果，進一步定位問題所在 很多人將單元測試的概念與軟體測試的行為混為一談，如果要澄清這問題。首先要先回顧自己以前寫過的測試，並問自己問題: 以前寫的一個單元測試，今天還能順利運行嗎以前寫的測試，團隊裡有任何一個人可以運行他並得到結果嗎我能一鍵運行過所有的單元測試嗎我能在幾分鐘內寫出一個基本的測試嗎 如果以上答案任何一個為否定，那很可能就不是單元測試，實際上是集成測試 ","version":"Next","tagName":"h2"},{"title":"1.3 集成測試​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#13-集成測試","content":"集成測試:任何測試，如果運行速度不快，結果不穩定，或者要用到被測試單元一個或多個真實依賴物，(ex:一個測試要使用真實的系統時間，真實的文件或真實的資料庫) 如果一個測試不能控制系統時間，每次都要使用 DateTime.Now，那麼每次執行都是使用不同的時間，因此測試的本質都是不同的，這測試就不穩定了 集成測試與單元測試具有相同的地位都非常重要，但兩種測試應該被被分開來 如果一個測試使用的是真實資料庫，那麼和那些只使用內存中的偽數據測試相比: 測試痕跡難以消除運行時間相對更長如果有成千上萬個測試，每分每秒都是關鍵 大多人都是通過用戶介面的最終功能來測試軟體的功能，單擊按鈕會觸發一系列的事件，如果最終結果失敗，那所有這些組鍵做為一整體就失敗了，也很難找出整體操作的失敗 集成測試定義: 一個循序漸進的測試，軟硬體相結合進行測試直到整個系統集成在一起對一個工作單元進行測試，這個測試對工作單元沒有完全控制，並使用該單元的一個或多個真實依賴物集成測試會使用真實依賴物，單元測試則把被測試單元和其依賴物隔開，以保證測試結果高度穩定 ","version":"Next","tagName":"h2"},{"title":"與自動化單元測試相比，非自動化集成測試的缺點​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#與自動化單元測試相比非自動化集成測試的缺點","content":"我兩周前寫的一個單元測試，今天還能運行並得到結果嗎?更久之前的呢? 如果答案是&quot;否&quot;，那或許已經破壞之前的功能了無法對之前所有功能進行測試，就有可能破壞了某個功能而毫不知情，這種情況稱為&quot;偶然引入缺陷&quot;回歸是以前運行良好但是現在布工作的一個或多個工作單元 ","version":"Next","tagName":"h3"},{"title":"1.4 什麼是優秀的單元測試​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#14-什麼是優秀的單元測試","content":"單元測試最終定義: 一個單元測試是一段自動化的程式，這段程式去呼叫要被測試的工作單元，之後對這個工作單元的結果的某些假設進行檢驗，容易編寫，能快速運行可靠可讀容易維護只要程式不發生改變，測試結果是穩定的 ","version":"Next","tagName":"h2"},{"title":"1.5 一個簡單的單元測試範例​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#15-一個簡單的單元測試範例","content":"有一個 class (SimpleParser)需要被測試，裡面有一個方法(ParseAndSum) ParseAndSum 輸入是由 0 或多個逗號組成的字串陣列如果輸入的字串不含數值，就回傳 0如果包含單一一個數值，就將數值轉成 int 回傳如果包含多個數值，就回傳數值總和的 int // Define other methods and classes here public class SimpleParser { public int ParseAndSum(string numbers) { if(numbers.Length==0) { return 0; } if(!numbers.Contains(&quot;,&quot;)) { return int.Parse(numbers); } else { throw new InvalidOperationException( &quot;I can only handle 0 or 1 numbers for now!&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"1.6 測試驅動開發​","type":1,"pageTitle":"📋 第一章 單元測試的基礎","url":"/en/docs/unitTest/note1#16-測試驅動開發","content":"有一個 class (SimpleParser)需要被測試，裡面有一個方法(ParseAndSum) ","version":"Next","tagName":"h2"},{"title":"🛰 Web 結構","type":0,"sectionRef":"#","url":"/en/docs/webapi4Net/note1","content":"","keywords":"","version":"Next"},{"title":"web 體系結構擁有三個核心觀念​","type":1,"pageTitle":"🛰 Web 結構","url":"/en/docs/webapi4Net/note1#web-體系結構擁有三個核心觀念","content":"資源 (resource)URI (Uniform Resource Identifier)表示 (representation) ","version":"Next","tagName":"h2"},{"title":"資源 (resource)​","type":1,"pageTitle":"🛰 Web 結構","url":"/en/docs/webapi4Net/note1#資源-resource","content":"只要任何有 identity (註 1) 的東西都屬於資源資源本身會是一個或多個實體 (entity) 的概念映射他可能是一格種文字格式，也可能是文件、圖片、影片等而資源不需要對應到資料庫的實體，也不須對應到業務邏輯的物件 註 1:identity : 是一個唯一的物件，可以被當成身分的東西 ","version":"Next","tagName":"h3"},{"title":"URI (Uniform Resource Identifier)​","type":1,"pageTitle":"🛰 Web 結構","url":"/en/docs/webapi4Net/note1#uri-uniform-resource-identifier","content":"他可以被視為一個資源的 主鍵 (primary key)URI 被分為兩種: 統一資源定位符 (Universal Resource Locator, URL)統一資源名稱 (Universal Resource Name, URN) 大多數看到的 URI 都是 URL ，因此他們常常被當成同義詞 ","version":"Next","tagName":"h3"},{"title":"表示 (representation)​","type":1,"pageTitle":"🛰 Web 結構","url":"/en/docs/webapi4Net/note1#表示-representation","content":" ","version":"Next","tagName":"h3"},{"title":"參考​","type":1,"pageTitle":"🛰 Web 結構","url":"/en/docs/webapi4Net/note1#參考","content":"resource - rfc2396URI - rfc3986 ","version":"Next","tagName":"h2"},{"title":"(持續更新中 ....)​","type":1,"pageTitle":"🛰 Web 結構","url":"/en/docs/webapi4Net/note1#持續更新中-","content":"","version":"Next","tagName":"h3"}]